(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction = function isFunction2(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc) {
          doc = doc || document2;
          var i, val, script = doc.createElement("script");
          script.text = code;
          if (node) {
            for (i in preservedScriptAttributes) {
              val = node[i] || node.getAttribute && node.getAttribute(i);
              if (val) {
                script.setAttribute(i, val);
              }
            }
          }
          doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var version = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery24 = function(selector, context) {
          return new jQuery24.fn.init(selector, context);
        };
        jQuery24.fn = jQuery24.prototype = {
          // The current version of jQuery being used
          jquery: version,
          constructor: jQuery24,
          // The default length of a jQuery object is 0
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          // Get the Nth element in the matched element set OR
          // Get the whole matched element set as a clean array
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          // Take an array of elements and push it onto the stack
          // (returning the new matched element set)
          pushStack: function(elems) {
            var ret = jQuery24.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          // Execute a callback for every element in the matched set.
          each: function(callback) {
            return jQuery24.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery24.map(this, function(elem, i) {
              return callback.call(elem, i, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery24.grep(this, function(_elem, i) {
              return (i + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery24.grep(this, function(_elem, i) {
              return i % 2;
            }));
          },
          eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          // For internal use only.
          // Behaves like an Array's method, not like a jQuery method.
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery24.extend = jQuery24.fn.extend = function() {
          var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
          }
          if (typeof target !== "object" && !isFunction(target)) {
            target = {};
          }
          if (i === length) {
            target = this;
            i--;
          }
          for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
              for (name in options) {
                copy = options[name];
                if (name === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery24.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone = [];
                  } else if (!copyIsArray && !jQuery24.isPlainObject(src)) {
                    clone = {};
                  } else {
                    clone = src;
                  }
                  copyIsArray = false;
                  target[name] = jQuery24.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery24.extend({
          // Unique for each copy of jQuery on the page
          expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
          // Assume jQuery is ready without the ready module
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          // Evaluates a script in a provided context; falls back to the global one
          // if not specified.
          globalEval: function(code, options, doc) {
            DOMEval(code, { nonce: options && options.nonce }, doc);
          },
          each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i < length; i++) {
                if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
                }
              }
            } else {
              for (i in obj) {
                if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          // Retrieve the text value of an array of DOM nodes
          text: function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i++]) {
                ret += jQuery24.text(node);
              }
            }
            if (nodeType === 1 || nodeType === 11) {
              return elem.textContent;
            }
            if (nodeType === 9) {
              return elem.documentElement.textContent;
            }
            if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          },
          // results is for internal usage only
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery24.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i) {
            return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
          },
          isXMLDoc: function(elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
          },
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
              first[i++] = second[j];
            }
            first.length = i;
            return first;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
              callbackInverse = !callback(elems[i], i);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i]);
              }
            }
            return matches;
          },
          // arg is for internal usage only
          map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i < length; i++) {
                value = callback(elems[i], i, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i in elems) {
                value = callback(elems[i], i, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          // A global GUID counter for objects
          guid: 1,
          // jQuery.support is not used in Core but other projects attach their
          // properties to it so it needs to exist.
          support
        });
        if (typeof Symbol === "function") {
          jQuery24.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery24.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
          }
        );
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType(obj);
          if (isFunction(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        function nodeName(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        var pop = arr.pop;
        var sort = arr.sort;
        var splice = arr.splice;
        var whitespace = "[\\x20\\t\\r\\n\\f]";
        var rtrimCSS = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        );
        jQuery24.contains = function(a, b) {
          var bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
          // IE doesn't have `contains` on SVG.
          (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        };
        var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
        function fcssescape(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }
        jQuery24.escapeSelector = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        var preferredDoc = document2, pushNative = push;
        (function() {
          var i, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery24.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
              hasDuplicate = true;
            }
            return 0;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
          "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp(
              "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
              "i"
            ),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
            var high = "0x" + escape.slice(1) - 65536;
            if (nonHex) {
              return nonHex;
            }
            return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, unloadHandler = function() {
            setDocument();
          }, inDisabledFieldset = addCombinator(
            function(elem) {
              return elem.disabled === true && nodeName(elem, "fieldset");
            },
            { dir: "parentNode", next: "legend" }
          );
          function safeActiveElement() {
            try {
              return document3.activeElement;
            } catch (err) {
            }
          }
          try {
            push2.apply(
              arr = slice.call(preferredDoc.childNodes),
              preferredDoc.childNodes
            );
            arr[preferredDoc.childNodes.length].nodeType;
          } catch (e) {
            push2 = {
              apply: function(target, els) {
                pushNative.apply(target, slice.call(els));
              },
              call: function(target) {
                pushNative.apply(target, slice.call(arguments, 1));
              }
            };
          }
          function find(selector, context, results, seed) {
            var m2, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed) {
              setDocument(context);
              context = context || document3;
              if (documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                  if (m2 = match[1]) {
                    if (nodeType === 9) {
                      if (elem = context.getElementById(m2)) {
                        if (elem.id === m2) {
                          push2.call(results, elem);
                          return results;
                        }
                      } else {
                        return results;
                      }
                    } else {
                      if (newContext && (elem = newContext.getElementById(m2)) && find.contains(context, elem) && elem.id === m2) {
                        push2.call(results, elem);
                        return results;
                      }
                    }
                  } else if (match[2]) {
                    push2.apply(results, context.getElementsByTagName(selector));
                    return results;
                  } else if ((m2 = match[3]) && context.getElementsByClassName) {
                    push2.apply(results, context.getElementsByClassName(m2));
                    return results;
                  }
                }
                if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                  newSelector = selector;
                  newContext = context;
                  if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    if (newContext != context || !support.scope) {
                      if (nid = context.getAttribute("id")) {
                        nid = jQuery24.escapeSelector(nid);
                      } else {
                        context.setAttribute("id", nid = expando);
                      }
                    }
                    groups = tokenize(selector);
                    i2 = groups.length;
                    while (i2--) {
                      groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                    }
                    newSelector = groups.join(",");
                  }
                  try {
                    push2.apply(
                      results,
                      newContext.querySelectorAll(newSelector)
                    );
                    return results;
                  } catch (qsaError) {
                    nonnativeSelectorCache(selector, true);
                  } finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
          }
          function createCache() {
            var keys = [];
            function cache(key, value) {
              if (keys.push(key + " ") > Expr.cacheLength) {
                delete cache[keys.shift()];
              }
              return cache[key + " "] = value;
            }
            return cache;
          }
          function markFunction(fn) {
            fn[expando] = true;
            return fn;
          }
          function assert(fn) {
            var el = document3.createElement("fieldset");
            try {
              return !!fn(el);
            } catch (e) {
              return false;
            } finally {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
              el = null;
            }
          }
          function createInputPseudo(type) {
            return function(elem) {
              return nodeName(elem, "input") && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
            };
          }
          function createDisabledPseudo(disabled) {
            return function(elem) {
              if ("form" in elem) {
                if (elem.parentNode && elem.disabled === false) {
                  if ("label" in elem) {
                    if ("label" in elem.parentNode) {
                      return elem.parentNode.disabled === disabled;
                    } else {
                      return elem.disabled === disabled;
                    }
                  }
                  return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                  elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
              } else if ("label" in elem) {
                return elem.disabled === disabled;
              }
              return false;
            };
          }
          function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches2) {
                var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
                while (i2--) {
                  if (seed[j = matchIndexes[i2]]) {
                    seed[j] = !(matches2[j] = seed[j]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          function setDocument(node) {
            var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
              return document3;
            }
            document3 = doc;
            documentElement2 = document3.documentElement;
            documentIsHTML = !jQuery24.isXMLDoc(document3);
            matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
            if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
              subWindow.addEventListener("unload", unloadHandler);
            }
            support.getById = assert(function(el) {
              documentElement2.appendChild(el).id = jQuery24.expando;
              return !document3.getElementsByName || !document3.getElementsByName(jQuery24.expando).length;
            });
            support.disconnectedMatch = assert(function(el) {
              return matches.call(el, "*");
            });
            support.scope = assert(function() {
              return document3.querySelectorAll(":scope");
            });
            support.cssHas = assert(function() {
              try {
                document3.querySelector(":has(*,:jqfake)");
                return false;
              } catch (e) {
                return true;
              }
            });
            if (support.getById) {
              Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
              Expr.find.ID = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var elem = context.getElementById(id);
                  return elem ? [elem] : [];
                }
              };
            } else {
              Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
              Expr.find.ID = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var node2, i2, elems, elem = context.getElementById(id);
                  if (elem) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                    elems = context.getElementsByName(id);
                    i2 = 0;
                    while (elem = elems[i2++]) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                    }
                  }
                  return [];
                }
              };
            }
            Expr.find.TAG = function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else {
                return context.querySelectorAll(tag);
              }
            };
            Expr.find.CLASS = function(className, context) {
              if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                return context.getElementsByClassName(className);
              }
            };
            rbuggyQSA = [];
            assert(function(el) {
              var input;
              documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D");
              documentElement2.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              input = document3.createElement("input");
              input.setAttribute("name", "");
              el.appendChild(input);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
              }
            });
            if (!support.cssHas) {
              rbuggyQSA.push(":has");
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            sortOrder = function(a, b) {
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
                // Otherwise we know they are disconnected
                1
              );
              if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                if (a === document3 || a.ownerDocument == preferredDoc && find.contains(preferredDoc, a)) {
                  return -1;
                }
                if (b === document3 || b.ownerDocument == preferredDoc && find.contains(preferredDoc, b)) {
                  return 1;
                }
                return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
              }
              return compare & 4 ? -1 : 1;
            };
            return document3;
          }
          find.matches = function(expr, elements) {
            return find(expr, null, null, elements);
          };
          find.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e) {
                nonnativeSelectorCache(expr, true);
              }
            }
            return find(expr, document3, null, [elem]).length > 0;
          };
          find.contains = function(context, elem) {
            if ((context.ownerDocument || context) != document3) {
              setDocument(context);
            }
            return jQuery24.contains(context, elem);
          };
          find.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) != document3) {
              setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            if (val !== void 0) {
              return val;
            }
            return elem.getAttribute(name);
          };
          find.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          jQuery24.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i2 = 0;
            hasDuplicate = !support.sortStable;
            sortInput = !support.sortStable && slice.call(results, 0);
            sort.call(results, sortOrder);
            if (hasDuplicate) {
              while (elem = results[i2++]) {
                if (elem === results[i2]) {
                  j = duplicates.push(i2);
                }
              }
              while (j--) {
                splice.call(results, duplicates[j], 1);
              }
            }
            sortInput = null;
            return results;
          };
          jQuery24.fn.uniqueSort = function() {
            return this.pushStack(jQuery24.uniqueSort(slice.apply(this)));
          };
          Expr = jQuery24.expr = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              ATTR: function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                  match[3] = " " + match[3] + " ";
                }
                return match.slice(0, 4);
              },
              CHILD: function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                  if (!match[3]) {
                    find.error(match[0]);
                  }
                  match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                  match[5] = +(match[7] + match[8] || match[3] === "odd");
                } else if (match[3]) {
                  find.error(match[0]);
                }
                return match;
              },
              PSEUDO: function(match) {
                var excess, unquoted = !match[6] && match[2];
                if (matchExpr.CHILD.test(match[0])) {
                  return null;
                }
                if (match[3]) {
                  match[2] = match[4] || match[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
                (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match[0] = match[0].slice(0, excess);
                  match[2] = unquoted.slice(0, excess);
                }
                return match.slice(0, 3);
              }
            },
            filter: {
              TAG: function(nodeNameSelector) {
                var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return nodeName(elem, expectedNodeName);
                };
              },
              CLASS: function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                  return pattern.test(
                    typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                  );
                });
              },
              ATTR: function(name, operator, check) {
                return function(elem) {
                  var result = find.attr(elem, name);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  if (operator === "=") {
                    return result === check;
                  }
                  if (operator === "!=") {
                    return result !== check;
                  }
                  if (operator === "^=") {
                    return check && result.indexOf(check) === 0;
                  }
                  if (operator === "*=") {
                    return check && result.indexOf(check) > -1;
                  }
                  if (operator === "$=") {
                    return check && result.slice(-check.length) === check;
                  }
                  if (operator === "~=") {
                    return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                  }
                  if (operator === "|=") {
                    return result === check || result.slice(0, check.length + 1) === check + "-";
                  }
                  return false;
                };
              },
              CHILD: function(type, what, _argument, first, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last === 0 ? (
                  // Shortcut for :nth-*(n)
                  function(elem) {
                    return !!elem.parentNode;
                  }
                ) : function(elem, _context, xml) {
                  var cache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                  if (parent) {
                    if (simple) {
                      while (dir2) {
                        node = elem;
                        while (node = node[dir2]) {
                          if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start = dir2 = type === "only" && !start && "nextSibling";
                      }
                      return true;
                    }
                    start = [forward ? parent.firstChild : parent.lastChild];
                    if (forward && useCache) {
                      outerCache = parent[expando] || (parent[expando] = {});
                      cache = outerCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex && cache[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                      (diff = nodeIndex = 0) || start.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          outerCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      if (useCache) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        cache = outerCache[type] || [];
                        nodeIndex = cache[0] === dirruns && cache[1];
                        diff = nodeIndex;
                      }
                      if (diff === false) {
                        while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                          if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                            if (useCache) {
                              outerCache = node[expando] || (node[expando] = {});
                              outerCache[type] = [dirruns, diff];
                            }
                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }
                    diff -= last;
                    return diff === first || diff % first === 0 && diff / first >= 0;
                  }
                };
              },
              PSEUDO: function(pseudo, argument) {
                var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
                if (fn[expando]) {
                  return fn(argument);
                }
                if (fn.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                    var idx, matched = fn(seed, argument), i2 = matched.length;
                    while (i2--) {
                      idx = indexOf.call(seed, matched[i2]);
                      seed[idx] = !(matches2[idx] = matched[i2]);
                    }
                  }) : function(elem) {
                    return fn(elem, 0, args);
                  };
                }
                return fn;
              }
            },
            pseudos: {
              // Potentially complex pseudos
              not: markFunction(function(selector) {
                var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                  while (i2--) {
                    if (elem = unmatched[i2]) {
                      seed[i2] = !(matches2[i2] = elem);
                    }
                  }
                }) : function(elem, _context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  input[0] = null;
                  return !results.pop();
                };
              }),
              has: markFunction(function(selector) {
                return function(elem) {
                  return find(selector, elem).length > 0;
                };
              }),
              contains: markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || jQuery24.text(elem)).indexOf(text) > -1;
                };
              }),
              // "Whether an element is represented by a :lang() selector
              // is based solely on the element's language value
              // being equal to the identifier C,
              // or beginning with the identifier C immediately followed by "-".
              // The matching of C against the element's language value is performed case-insensitively.
              // The identifier C does not have to be a valid language name."
              // https://www.w3.org/TR/selectors/#lang-pseudo
              lang: markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  find.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              // Miscellaneous
              target: function(elem) {
                var hash = window2.location && window2.location.hash;
                return hash && hash.slice(1) === elem.id;
              },
              root: function(elem) {
                return elem === documentElement2;
              },
              focus: function(elem) {
                return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              // Boolean properties
              enabled: createDisabledPseudo(false),
              disabled: createDisabledPseudo(true),
              checked: function(elem) {
                return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
              },
              selected: function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              // Contents
              empty: function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              parent: function(elem) {
                return !Expr.pseudos.empty(elem);
              },
              // Element/input types
              header: function(elem) {
                return rheader.test(elem.nodeName);
              },
              input: function(elem) {
                return rinputs.test(elem.nodeName);
              },
              button: function(elem) {
                return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
              },
              text: function(elem) {
                var attr;
                return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
                // New HTML5 attribute values (e.g., "search") appear
                // with elem.type === "text"
                ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              // Position-in-collection
              first: createPositionalPseudo(function() {
                return [0];
              }),
              last: createPositionalPseudo(function(_matchIndexes, length) {
                return [length - 1];
              }),
              eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              even: createPositionalPseudo(function(matchIndexes, length) {
                var i2 = 0;
                for (; i2 < length; i2 += 2) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              }),
              odd: createPositionalPseudo(function(matchIndexes, length) {
                var i2 = 1;
                for (; i2 < length; i2 += 2) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              }),
              lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i2;
                if (argument < 0) {
                  i2 = argument + length;
                } else if (argument > length) {
                  i2 = length;
                } else {
                  i2 = argument;
                }
                for (; --i2 >= 0; ) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              }),
              gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i2 = argument < 0 ? argument + length : argument;
                for (; ++i2 < length; ) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos.nth = Expr.pseudos.eq;
          for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i] = createInputPseudo(i);
          }
          for (i in { submit: true, reset: true }) {
            Expr.pseudos[i] = createButtonPseudo(i);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          function tokenize(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                  soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match = rleadingCombinator.exec(soFar)) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  // Cast descendant combinators to space
                  type: match[0].replace(rtrimCSS, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            if (parseOnly) {
              return soFar.length;
            }
            return soFar ? find.error(selector) : (
              // Cache the tokens
              tokenCache(selector, groups).slice(0)
            );
          }
          function toSelector(tokens) {
            var i2 = 0, len = tokens.length, selector = "";
            for (; i2 < len; i2++) {
              selector += tokens[i2].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? (
              // Check against closest ancestor/preceding element
              function(elem, context, xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    return matcher(elem, context, xml);
                  }
                }
                return false;
              }
            ) : (
              // Check against all ancestor/preceding elements
              function(elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                if (xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      if (matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                } else {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      if (skip && nodeName(elem, skip)) {
                        elem = elem[dir2] || elem;
                      } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                        return newCache[2] = oldCache[2];
                      } else {
                        outerCache[key] = newCache;
                        if (newCache[2] = matcher(elem, context, xml)) {
                          return true;
                        }
                      }
                    }
                  }
                }
                return false;
              }
            );
          }
          function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
              var i2 = matchers.length;
              while (i2--) {
                if (!matchers[i2](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers[0];
          }
          function multipleContexts(selector, contexts, results) {
            var i2 = 0, len = contexts.length;
            for (; i2 < len; i2++) {
              find(selector, contexts[i2], results);
            }
            return results;
          }
          function condense(unmatched, map2, filter, context, xml) {
            var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
            for (; i2 < len; i2++) {
              if (elem = unmatched[i2]) {
                if (!filter || filter(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map2.push(i2);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i2, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
              if (matcher) {
                matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                  // ...intermediate processing is necessary
                  []
                ) : (
                  // ...otherwise use results directly
                  results
                );
                matcher(matcherIn, matcherOut, context, xml);
              } else {
                matcherOut = matcherIn;
              }
              if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i2 = temp.length;
                while (i2--) {
                  if (elem = temp[i2]) {
                    matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i2 = matcherOut.length;
                    while (i2--) {
                      if (elem = matcherOut[i2]) {
                        temp.push(matcherIn[i2] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i2 = matcherOut.length;
                  while (i2--) {
                    if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i2]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense(
                  matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                );
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf.call(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i2 < len; i2++) {
              if (matcher = Expr.relative[tokens[i2].type]) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
              } else {
                matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
                if (matcher[expando]) {
                  j = ++i2;
                  for (; j < len; j++) {
                    if (Expr.relative[tokens[j].type]) {
                      break;
                    }
                  }
                  return setMatcher(
                    i2 > 1 && elementMatcher(matchers),
                    i2 > 1 && toSelector(
                      // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                      tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                    ).replace(rtrimCSS, "$1"),
                    matcher,
                    i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                    j < len && matcherFromTokens(tokens = tokens.slice(j)),
                    j < len && toSelector(tokens)
                  );
                }
                matchers.push(matcher);
              }
            }
            return elementMatcher(matchers);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context == document3 || context || outermost;
              }
              for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
                if (byElement && elem) {
                  j = 0;
                  if (!context && elem.ownerDocument != document3) {
                    setDocument(elem);
                    xml = !documentIsHTML;
                  }
                  while (matcher = elementMatchers[j++]) {
                    if (matcher(elem, context || document3, xml)) {
                      push2.call(results, elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i2;
              if (bySet && i2 !== matchedCount) {
                j = 0;
                while (matcher = setMatchers[j++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i2--) {
                      if (!(unmatched[i2] || setMatched[i2])) {
                        setMatched[i2] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  jQuery24.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          function compile(selector, match) {
            var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match) {
                match = tokenize(selector);
              }
              i2 = match.length;
              while (i2--) {
                cached = matcherFromTokens(match[i2]);
                if (cached[expando]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(
                selector,
                matcherFromGroupMatchers(elementMatchers, setMatchers)
              );
              cached.selector = selector;
            }
            return cached;
          }
          function select(selector, context, results, seed) {
            var i2, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
              tokens = match[0] = match[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find.ID(
                  token.matches[0].replace(runescape, funescape),
                  context
                ) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
              while (i2--) {
                token = tokens[i2];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find2 = Expr.find[type]) {
                  if (seed = find2(
                    token.matches[0].replace(runescape, funescape),
                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                  )) {
                    tokens.splice(i2, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile(selector, match))(
              seed,
              context,
              !documentIsHTML,
              results,
              !context || rsibling.test(selector) && testContext(context.parentNode) || context
            );
            return results;
          }
          support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
          setDocument();
          support.sortDetached = assert(function(el) {
            return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
          });
          jQuery24.find = find;
          jQuery24.expr[":"] = jQuery24.expr.pseudos;
          jQuery24.unique = jQuery24.uniqueSort;
          find.compile = compile;
          find.select = select;
          find.setDocument = setDocument;
          find.tokenize = tokenize;
          find.escape = jQuery24.escapeSelector;
          find.getText = jQuery24.text;
          find.isXML = jQuery24.isXMLDoc;
          find.selectors = jQuery24.expr;
          find.support = jQuery24.support;
          find.uniqueSort = jQuery24.uniqueSort;
        })();
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery24(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n, elem) {
          var matched = [];
          for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
              matched.push(n);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery24.expr.match.needsContext;
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction(qualifier)) {
            return jQuery24.grep(elements, function(elem, i) {
              return !!qualifier.call(elem, i, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery24.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery24.grep(elements, function(elem) {
              return indexOf.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery24.filter(qualifier, elements, not);
        }
        jQuery24.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery24.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery24.find.matches(expr, jQuery24.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery24.fn.extend({
          find: function(selector) {
            var i, ret, len = this.length, self = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery24(selector).filter(function() {
                for (i = 0; i < len; i++) {
                  if (jQuery24.contains(self[i], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i = 0; i < len; i++) {
              jQuery24.find(selector, self[i], ret);
            }
            return len > 1 ? jQuery24.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              // If this is a positional/relative selector, check membership in the returned set
              // so $("p:first").is("p:last") won't return true for a doc with two "p".
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery24(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init2 = jQuery24.fn.init = function(selector, context, root) {
          var match, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
              if (match[1]) {
                context = context instanceof jQuery24 ? context[0] : context;
                jQuery24.merge(this, jQuery24.parseHTML(
                  match[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match[1]) && jQuery24.isPlainObject(context)) {
                  for (match in context) {
                    if (isFunction(this[match])) {
                      this[match](context[match]);
                    } else {
                      this.attr(match, context[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : (
              // Execute immediately if ready is not present
              selector(jQuery24)
            );
          }
          return jQuery24.makeArray(selector, this);
        };
        init2.prototype = jQuery24.fn;
        rootjQuery = jQuery24(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery24.fn.extend({
          has: function(target) {
            var targets = jQuery24(target, this), l = targets.length;
            return this.filter(function() {
              var i = 0;
              for (; i < l; i++) {
                if (jQuery24.contains(this, targets[i])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery24(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                    // Don't pass non-elements to jQuery#find
                    cur.nodeType === 1 && jQuery24.find.matchesSelector(cur, selectors)
                  ))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery24.uniqueSort(matched) : matched);
          },
          // Determine the position of an element within the set
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf.call(jQuery24(elem), this[0]);
            }
            return indexOf.call(
              this,
              // If it receives a jQuery object, the first element is used
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery24.uniqueSort(
                jQuery24.merge(this.get(), jQuery24(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery24.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery24.merge([], elem.childNodes);
          }
        }, function(name, fn) {
          jQuery24.fn[name] = function(until, selector) {
            var matched = jQuery24.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery24.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery24.uniqueSort(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options) {
          var object = {};
          jQuery24.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery24.Callbacks = function(options) {
          options = typeof options === "string" ? createOptions(options) : jQuery24.extend({}, options);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add(args) {
                  jQuery24.each(args, function(_, arg) {
                    if (isFunction(arg)) {
                      if (!options.unique || !self.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType(arg) !== "string") {
                      add(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            // Remove a callback from the list
            remove: function() {
              jQuery24.each(arguments, function(_, arg) {
                var index;
                while ((index = jQuery24.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
              return fn ? jQuery24.inArray(fn, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
              self.fireWith(this, arguments);
              return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
              return !!fired;
            }
          };
          return self;
        };
        function Identity(v) {
          return v;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve, reject, noValue) {
          var method;
          try {
            if (value && isFunction(method = value.promise)) {
              method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction(method = value.then)) {
              method.call(value, resolve, reject);
            } else {
              resolve.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery24.extend({
          Deferred: function(func) {
            var tuples = [
              // action, add listener, callbacks,
              // ... .then handlers, argument index, [final state]
              [
                "notify",
                "progress",
                jQuery24.Callbacks("memory"),
                jQuery24.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery24.Callbacks("once memory"),
                jQuery24.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery24.Callbacks("once memory"),
                jQuery24.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn) {
                return promise.then(null, fn);
              },
              // Keep pipe for back-compat
              pipe: function() {
                var fns = arguments;
                return jQuery24.Deferred(function(newDefer) {
                  jQuery24.each(tuples, function(_i, tuple) {
                    var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn && fn.apply(this, arguments);
                      if (returned && isFunction(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special),
                            resolve(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e) {
                        if (jQuery24.Deferred.exceptionHook) {
                          jQuery24.Deferred.exceptionHook(
                            e,
                            process.error
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process();
                    } else {
                      if (jQuery24.Deferred.getErrorHook) {
                        process.error = jQuery24.Deferred.getErrorHook();
                      } else if (jQuery24.Deferred.getStackHook) {
                        process.error = jQuery24.Deferred.getStackHook();
                      }
                      window2.setTimeout(process);
                    }
                  };
                }
                return jQuery24.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              // Get a promise for this deferred
              // If obj is provided, the promise aspect is added to the object
              promise: function(obj) {
                return obj != null ? jQuery24.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery24.each(tuples, function(i, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  // rejected_callbacks.disable
                  // fulfilled_callbacks.disable
                  tuples[3 - i][2].disable,
                  // rejected_handlers.disable
                  // fulfilled_handlers.disable
                  tuples[3 - i][3].disable,
                  // progress_callbacks.lock
                  tuples[0][2].lock,
                  // progress_handlers.lock
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          // Deferred helper
          when: function(singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery24.Deferred(), updateFunc = function(i2) {
              return function(value) {
                resolveContexts[i2] = this;
                resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  primary.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                primary.done(updateFunc(i)).resolve,
                primary.reject,
                !remaining
              );
              if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
                return primary.then();
              }
            }
            while (i--) {
              adoptValue(resolveValues[i], updateFunc(i), primary.reject);
            }
            return primary.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery24.Deferred.exceptionHook = function(error, asyncError) {
          if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
            window2.console.warn(
              "jQuery.Deferred exception: " + error.message,
              error.stack,
              asyncError
            );
          }
        };
        jQuery24.readyException = function(error) {
          window2.setTimeout(function() {
            throw error;
          });
        };
        var readyList = jQuery24.Deferred();
        jQuery24.fn.ready = function(fn) {
          readyList.then(fn).catch(function(error) {
            jQuery24.readyException(error);
          });
          return this;
        };
        jQuery24.extend({
          // Is the DOM ready to be used? Set to true once it occurs.
          isReady: false,
          // A counter to track how many items to wait for before
          // the ready event fires. See trac-6781
          readyWait: 1,
          // Handle when the DOM is ready
          ready: function(wait) {
            if (wait === true ? --jQuery24.readyWait : jQuery24.isReady) {
              return;
            }
            jQuery24.isReady = true;
            if (wait !== true && --jQuery24.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery24]);
          }
        });
        jQuery24.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery24.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery24.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
          var i = 0, len = elems.length, bulk = key == null;
          if (toType(key) === "object") {
            chainable = true;
            for (i in key) {
              access(elems, fn, i, key[i], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn.call(elems, value);
                fn = null;
              } else {
                bulk = fn;
                fn = function(elem, _key, value2) {
                  return bulk.call(jQuery24(elem), value2);
                };
              }
            }
            if (fn) {
              for (; i < len; i++) {
                fn(
                  elems[i],
                  key,
                  raw ? value : value.call(elems[i], i, fn(elems[i], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn.call(elems);
          }
          return len ? fn(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          this.expando = jQuery24.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === "string") {
              cache[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache[camelCase(prop)] = data[prop];
              }
            }
            return cache;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : (
              // Always use camelCase key (gh-2257)
              owner[this.expando] && owner[this.expando][camelCase(key)]
            );
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (cache === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
              }
              i = key.length;
              while (i--) {
                delete cache[key[i]];
              }
            }
            if (key === void 0 || jQuery24.isEmptyObject(cache)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== void 0 && !jQuery24.isEmptyObject(cache);
          }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery24.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
          },
          removeData: function(elem, name) {
            dataUser.remove(elem, name);
          },
          // TODO: Now that all calls to _data and _removeData have been replaced
          // with direct calls to dataPriv methods, these can be deprecated.
          _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
          }
        });
        jQuery24.fn.extend({
          data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i = attrs.length;
                  while (i--) {
                    if (attrs[i]) {
                      name = attrs[i].name;
                      if (name.indexOf("data-") === 0) {
                        name = camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery24.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data) {
                if (!queue || Array.isArray(data)) {
                  queue = dataPriv.access(elem, type, jQuery24.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery24.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery24._queueHooks(elem, type), next = function() {
              jQuery24.dequeue(elem, type);
            };
            if (fn === "inprogress") {
              fn = queue.shift();
              startLength--;
            }
            if (fn) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          // Not public - generate a queueHooks object, or return the current one
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery24.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery24.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery24.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery24.queue(this, type, data);
              jQuery24._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery24.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery24.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          // Get a promise resolved when queues of a certain type
          // are emptied (fx is the type by default)
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery24.Deferred(), elements = this, i = this.length, resolve = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i--) {
              tmp = dataPriv.get(elements[i], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve);
              }
            }
            resolve();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery24.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery24.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
          // Support: Firefox <=43 - 45
          // Disconnected elements can have computed display: none, so first confirm that elem is
          // in the document.
          isAttached(elem) && jQuery24.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery24.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery24.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery24.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery24.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery24.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery24.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc.body.appendChild(doc.createElement(nodeName2));
          display = jQuery24.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show) {
          var display, elem, values = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values[index] = dataPriv.get(elem, "display") || null;
                if (!values[index]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index = 0; index < length; index++) {
            if (values[index] != null) {
              elements[index].style.display = values[index];
            }
          }
          return elements;
        }
        jQuery24.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery24(this).show();
              } else {
                jQuery24(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div.appendChild(input);
          support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
          div.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
          div.innerHTML = "<option></option>";
          support.option = !!div.lastChild;
        })();
        var wrapMap = {
          // XHTML parsers do not magically insert elements in the
          // same way that tag soup parsers do. So we cannot shorten
          // this by omitting <tbody> or other required elements.
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery24.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i = 0, l = elems.length;
          for (; i < l; i++) {
            dataPriv.set(
              elems[i],
              "globalEval",
              !refElements || dataPriv.get(refElements[i], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
          for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
              if (toType(elem) === "object") {
                jQuery24.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + jQuery24.htmlPrefilter(elem) + wrap[2];
                j = wrap[0];
                while (j--) {
                  tmp = tmp.lastChild;
                }
                jQuery24.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i = 0;
          while (elem = nodes[i++]) {
            if (selection && jQuery24.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j = 0;
              while (elem = tmp[j++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function on(elem, types, selector, data, fn, one) {
          var origFn, type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types) {
              on(elem, type, selector, data, types[type], one);
            }
            return elem;
          }
          if (data == null && fn == null) {
            fn = selector;
            data = selector = void 0;
          } else if (fn == null) {
            if (typeof selector === "string") {
              fn = data;
              data = void 0;
            } else {
              fn = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn === false) {
            fn = returnFalse;
          } else if (!fn) {
            return elem;
          }
          if (one === 1) {
            origFn = fn;
            fn = function(event) {
              jQuery24().off(event);
              return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery24.guid++);
          }
          return elem.each(function() {
            jQuery24.event.add(this, types, fn, data, selector);
          });
        }
        jQuery24.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery24.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery24.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e) {
                return typeof jQuery24 !== "undefined" && jQuery24.event.triggered !== e.type ? jQuery24.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery24.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery24.event.special[type] || {};
              handleObj = jQuery24.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery24.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery24.event.global[type] = true;
            }
          },
          // Detach an event or set of events from an element
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery24.event.remove(elem, type + types[t], handler, selector, true);
                }
                continue;
              }
              special = jQuery24.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j = handlers.length;
              while (j--) {
                handleObj = handlers[j];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery24.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery24.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery24.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery24.event.special[event.type] || {};
            args[0] = event;
            for (i = 1; i < arguments.length; i++) {
              args[i] = arguments[i];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery24.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j = 0;
              while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery24.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i = 0; i < delegateCount; i++) {
                    handleObj = handlers[i];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery24(sel, this).index(cur) > -1 : jQuery24.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name, hook) {
            Object.defineProperty(jQuery24.Event.prototype, name, {
              enumerable: true,
              configurable: true,
              get: isFunction(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery24.expando] ? originalEvent : new jQuery24.Event(originalEvent);
          },
          special: {
            load: {
              // Prevent triggered image.load events from bubbling to window.load
              noBubble: true
            },
            click: {
              // Utilize native event to ensure correct state for checkable inputs
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", true);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              // For cross-browser consistency, suppress native .click() on links
              // Also prevent it if we're currently inside a leveraged native-event stack
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, isSetup) {
          if (!isSetup) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery24.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery24.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  this[type]();
                  result = dataPriv.get(this, type);
                  dataPriv.set(this, type, false);
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result;
                  }
                } else if ((jQuery24.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved) {
                dataPriv.set(this, type, jQuery24.event.trigger(
                  saved[0],
                  saved.slice(1),
                  this
                ));
                event.stopPropagation();
                event.isImmediatePropagationStopped = returnTrue;
              }
            }
          });
        }
        jQuery24.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery24.Event = function(src, props) {
          if (!(this instanceof jQuery24.Event)) {
            return new jQuery24.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery24.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery24.expando] = true;
        };
        jQuery24.Event.prototype = {
          constructor: jQuery24.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
              e.preventDefault();
            }
          },
          stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery24.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, jQuery24.event.addProp);
        jQuery24.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          function focusMappedHandler(nativeEvent) {
            if (document2.documentMode) {
              var handle = dataPriv.get(this, "handle"), event = jQuery24.event.fix(nativeEvent);
              event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
              event.isSimulated = true;
              handle(nativeEvent);
              if (event.target === event.currentTarget) {
                handle(event);
              }
            } else {
              jQuery24.event.simulate(
                delegateType,
                nativeEvent.target,
                jQuery24.event.fix(nativeEvent)
              );
            }
          }
          jQuery24.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
              var attaches;
              leverageNative(this, type, true);
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType);
                if (!attaches) {
                  this.addEventListener(delegateType, focusMappedHandler);
                }
                dataPriv.set(this, delegateType, (attaches || 0) + 1);
              } else {
                return false;
              }
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            teardown: function() {
              var attaches;
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType) - 1;
                if (!attaches) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                  dataPriv.remove(this, delegateType);
                } else {
                  dataPriv.set(this, delegateType, attaches);
                }
              } else {
                return false;
              }
            },
            // Suppress native focus or blur if we're currently inside
            // a leveraged native-event stack
            _default: function(event) {
              return dataPriv.get(event.target, type);
            },
            delegateType
          };
          jQuery24.event.special[delegateType] = {
            setup: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
              if (!attaches) {
                if (document2.documentMode) {
                  this.addEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.addEventListener(type, focusMappedHandler, true);
                }
              }
              dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
            },
            teardown: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
              if (!attaches) {
                if (document2.documentMode) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.removeEventListener(type, focusMappedHandler, true);
                }
                dataPriv.remove(dataHolder, delegateType);
              } else {
                dataPriv.set(dataHolder, delegateType, attaches);
              }
            }
          };
        });
        jQuery24.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery24.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery24.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery24.fn.extend({
          on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
          },
          one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
          },
          off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery24(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn = selector;
              selector = void 0;
            }
            if (fn === false) {
              fn = returnFalse;
            }
            return this.each(function() {
              jQuery24.event.remove(this, types, fn, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery24(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i, l, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                  jQuery24.event.add(dest, type, events[type][i]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery24.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
          if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
              var self = collection.eq(index);
              if (valueIsFunction) {
                args[0] = value.call(this, index, self.html());
              }
              domManip(self, args, callback, ignored);
            });
          }
          if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts = jQuery24.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i < l; i++) {
                node = fragment;
                if (i !== iNoClone) {
                  node = jQuery24.clone(node, true, true);
                  if (hasScripts) {
                    jQuery24.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(collection[i], node, i);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery24.map(scripts, restoreScript);
                for (i = 0; i < hasScripts; i++) {
                  node = scripts[i];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery24.contains(doc, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery24._evalUrl && !node.noModule) {
                        jQuery24._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove(elem, selector, keepData) {
          var node, nodes = selector ? jQuery24.filter(selector, elem) : elem, i = 0;
          for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
              jQuery24.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery24.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery24.isXMLDoc(elem)) {
              destElements = getAll(clone);
              srcElements = getAll(elem);
              for (i = 0, l = srcElements.length; i < l; i++) {
                fixInput(srcElements[i], destElements[i]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone);
                for (i = 0, l = srcElements.length; i < l; i++) {
                  cloneCopyEvent(srcElements[i], destElements[i]);
                }
              } else {
                cloneCopyEvent(elem, clone);
              }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery24.event.special, i = 0;
            for (; (elem = elems[i]) !== void 0; i++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery24.event.remove(elem, type);
                      } else {
                        jQuery24.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery24.fn.extend({
          detach: function(selector) {
            return remove(this, selector, true);
          },
          remove: function(selector) {
            return remove(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery24.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
              if (elem.nodeType === 1) {
                jQuery24.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery24.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i = 0, l = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery24.htmlPrefilter(value2);
                try {
                  for (; i < l; i++) {
                    elem = this[i] || {};
                    if (elem.nodeType === 1) {
                      jQuery24.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery24.inArray(this, ignored) < 0) {
                jQuery24.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery24.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery24.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery24(selector), last = insert.length - 1, i = 0;
            for (; i <= last; i++) {
              elems = i === last ? this : this.clone(true);
              jQuery24(insert[i])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var rcustomProp = /^--/;
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options, callback) {
          var ret, name, old = {};
          for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
          }
          ret = callback.call(elem);
          for (name in options) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
          function computeStyleTests() {
            if (!div) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window2.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
          if (!div.style) {
            return;
          }
          div.style.backgroundClip = "content-box";
          div.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div.style.backgroundClip === "content-box";
          jQuery24.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
              var table, tr, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                tr.style.cssText = "box-sizing:content-box;border:1px solid";
                tr.style.height = "1px";
                trChild.style.height = "9px";
                trChild.style.display = "block";
                documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr);
                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name, computed) {
          var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (isCustomProp && ret) {
              ret = ret.replace(rtrimCSS, "$1") || void 0;
            }
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery24.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? (
            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + ""
          ) : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name) {
          var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
          while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        }
        function finalPropName(name) {
          var final = jQuery24.cssProps[name] || vendorProps[name];
          if (final) {
            return final;
          }
          if (name in emptyStyle) {
            return name;
          }
          return vendorProps[name] = vendorPropName(name) || name;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches = rcssNum.exec(value);
          return matches ? (
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
          ) : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i < 4; i += 2) {
            if (box === "margin") {
              marginDelta += jQuery24.css(elem, box + cssExpand[i], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery24.css(elem, "padding" + cssExpand[i], true, styles);
              if (box !== "padding") {
                delta += jQuery24.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              } else {
                extra += jQuery24.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery24.css(elem, "padding" + cssExpand[i], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery24.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
              // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
              // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
          }
          return delta + marginDelta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery24.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Interestingly, in some cases IE 9 doesn't suffer from this issue.
          !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
          // This happens for inline elements with no explicit setting (gh-3571)
          val === "auto" || // Support: Android <=4.1 - 4.3 only
          // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
          !parseFloat(val) && jQuery24.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
          elem.getClientRects().length) {
            isBorderBox = jQuery24.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            // Provide the current computed size to request scroll gutter calculation (gh-3589)
            val
          ) + "px";
        }
        jQuery24.extend({
          // Add in style property hooks for overriding the default
          // behavior of getting and setting a style property
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          // Don't automatically add "px" to these possibly-unitless properties
          cssNumber: {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageSlice: true,
            columnCount: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            gridArea: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnStart: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowStart: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            scale: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeMiterlimit: true,
            strokeOpacity: true
          },
          // Add in properties whose names you wish to fix before
          // setting or getting the value
          cssProps: {},
          // Get and set the style property on a DOM Node
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery24.cssHooks[name] || jQuery24.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery24.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name, value);
                } else {
                  style[name] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery24.cssHooks[name] || jQuery24.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery24.each(["height", "width"], function(_i, dimension) {
          jQuery24.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery24.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery24.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery24.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery24.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed) {
            if (computed) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery24.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery24.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i < 4; i++) {
                expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery24.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery24.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map2 = {}, i = 0;
              if (Array.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i < len; i++) {
                  map2[name2[i]] = jQuery24.css(elem, name2[i], false, styles);
                }
                return map2;
              }
              return value2 !== void 0 ? jQuery24.style(elem, name2, value2) : jQuery24.css(elem, name2);
            }, name, value, arguments.length > 1);
          }
        });
        function Tween(elem, options, prop, end, easing) {
          return new Tween.prototype.init(elem, options, prop, end, easing);
        }
        jQuery24.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery24.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery24.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery24.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery24.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery24.fx.step[tween.prop]) {
                jQuery24.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery24.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery24.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery24.easing = {
          linear: function(p) {
            return p;
          },
          swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery24.fx = Tween.prototype.init;
        jQuery24.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery24.fx.interval);
            }
            jQuery24.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery24._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery24.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery24.style(elem, prop);
            }
          }
          propTween = !jQuery24.isEmptyObject(props);
          if (!propTween && jQuery24.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery24.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery24.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery24.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery24.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery24.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options) {
          var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery24.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery24.extend({}, properties),
            opts: jQuery24.extend(true, {
              specialEasing: {},
              easing: jQuery24.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
              var tween = jQuery24.Tween(
                elem,
                animation.opts,
                prop,
                end,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction(result.stop)) {
                jQuery24._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery24.map(props, createTween, animation);
          if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery24.fx.timer(
            jQuery24.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery24.Animation = jQuery24.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery24.speed = function(speed, easing, fn) {
          var opt = speed && typeof speed === "object" ? jQuery24.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
          };
          if (jQuery24.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery24.fx.speeds) {
                opt.duration = jQuery24.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery24.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery24.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery24.fn.extend({
          fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery24.isEmptyObject(prop), optall = jQuery24.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery24.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery24.timers, data = dataPriv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery24.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery24.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery24.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue[index] && queue[index].finish) {
                  queue[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery24.each(["toggle", "show", "hide"], function(_i, name) {
          var cssFn = jQuery24.fn[name];
          jQuery24.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery24.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery24.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery24.timers = [];
        jQuery24.fx.tick = function() {
          var timer, i = 0, timers = jQuery24.timers;
          fxNow = Date.now();
          for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
              timers.splice(i--, 1);
            }
          }
          if (!timers.length) {
            jQuery24.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery24.fx.timer = function(timer) {
          jQuery24.timers.push(timer);
          jQuery24.fx.start();
        };
        jQuery24.fx.interval = 13;
        jQuery24.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery24.fx.stop = function() {
          inProgress = null;
        };
        jQuery24.fx.speeds = {
          slow: 600,
          fast: 200,
          // Default speed
          _default: 400
        };
        jQuery24.fn.delay = function(time, type) {
          time = jQuery24.fx ? jQuery24.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery24.expr.attrHandle;
        jQuery24.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery24.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery24.removeAttr(this, name);
            });
          }
        });
        jQuery24.extend({
          attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery24.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery24.isXMLDoc(elem)) {
              hooks = jQuery24.attrHooks[name.toLowerCase()] || (jQuery24.expr.match.bool.test(name) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery24.removeAttr(elem, name);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            ret = jQuery24.find.attr(elem, name);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i++]) {
                elem.removeAttribute(name);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery24.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery24.each(jQuery24.expr.match.bool.source.match(/\w+/g), function(_i, name) {
          var getter = attrHandle[name] || jQuery24.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle, lowercaseName = name2.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery24.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery24.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery24.propFix[name] || name];
            });
          }
        });
        jQuery24.extend({
          prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery24.isXMLDoc(elem)) {
              name = jQuery24.propFix[name] || name;
              hooks = jQuery24.propHooks[name];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            return elem[name];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery24.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery24.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery24.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery24.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery24.fn.extend({
          addClass: function(value) {
            var classNames, cur, curValue, className, i, finalValue;
            if (isFunction(value)) {
              return this.each(function(j) {
                jQuery24(this).addClass(value.call(this, j, getClass(this)));
              });
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i = 0; i < classNames.length; i++) {
                    className = classNames[i];
                    if (cur.indexOf(" " + className + " ") < 0) {
                      cur += className + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          removeClass: function(value) {
            var classNames, cur, curValue, className, i, finalValue;
            if (isFunction(value)) {
              return this.each(function(j) {
                jQuery24(this).removeClass(value.call(this, j, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i = 0; i < classNames.length; i++) {
                    className = classNames[i];
                    while (cur.indexOf(" " + className + " ") > -1) {
                      cur = cur.replace(" " + className + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var classNames, className, i, self, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (isFunction(value)) {
              return this.each(function(i2) {
                jQuery24(this).toggleClass(
                  value.call(this, i2, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            classNames = classesToArray(value);
            return this.each(function() {
              if (isValidValue) {
                self = jQuery24(this);
                for (i = 0; i < classNames.length; i++) {
                  className = classNames[i];
                  if (self.hasClass(className)) {
                    self.removeClass(className);
                  } else {
                    self.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while (elem = this[i++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery24.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery24.valHooks[elem.type] || jQuery24.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i, jQuery24(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery24.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery24.valHooks[this.type] || jQuery24.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery24.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery24.find.attr(elem, "value");
                return val != null ? val : (
                  // Support: IE <=10 - 11 only
                  // option.text throws exceptions (trac-14686, trac-14858)
                  // Strip and collapse whitespace
                  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                  stripAndCollapse(jQuery24.text(elem))
                );
              }
            },
            select: {
              get: function(elem) {
                var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
                if (index < 0) {
                  i = max;
                } else {
                  i = one ? index : 0;
                }
                for (; i < max; i++) {
                  option = options[i];
                  if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                  !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery24(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options = elem.options, values = jQuery24.makeArray(value), i = options.length;
                while (i--) {
                  option = options[i];
                  if (option.selected = jQuery24.inArray(jQuery24.valHooks.option.get(option), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery24.each(["radio", "checkbox"], function() {
          jQuery24.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery24.inArray(jQuery24(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery24.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery24.parseXML = function(data) {
          var xml, parserErrorElem;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e) {
          }
          parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
          if (!xml || parserErrorElem) {
            jQuery24.error("Invalid XML: " + (parserErrorElem ? jQuery24.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data));
          }
          return xml;
        };
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
          e.stopPropagation();
        };
        jQuery24.extend(jQuery24.event, {
          trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery24.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery24.expando] ? event : new jQuery24.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery24.makeArray(data, [event]);
            special = jQuery24.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery24.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery24.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          // Piggyback on a donor event to simulate a different one
          // Used only for `focus(in | out)` events
          simulate: function(type, elem, event) {
            var e = jQuery24.extend(
              new jQuery24.Event(),
              event,
              {
                type,
                isSimulated: true
              }
            );
            jQuery24.event.trigger(e, null, elem);
          }
        });
        jQuery24.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery24.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery24.event.trigger(type, data, elem, true);
            }
          }
        });
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add) {
          var name;
          if (Array.isArray(obj)) {
            jQuery24.each(obj, function(i, v) {
              if (traditional || rbracket.test(prefix)) {
                add(prefix, v);
              } else {
                buildParams(
                  prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                  v,
                  traditional,
                  add
                );
              }
            });
          } else if (!traditional && toType(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
          } else {
            add(prefix, obj);
          }
        }
        jQuery24.param = function(a, traditional) {
          var prefix, s = [], add = function(key, valueOrFunction) {
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a == null) {
            return "";
          }
          if (Array.isArray(a) || a.jquery && !jQuery24.isPlainObject(a)) {
            jQuery24.each(a, function() {
              add(this.name, this.value);
            });
          } else {
            for (prefix in a) {
              buildParams(prefix, a[prefix], traditional, add);
            }
          }
          return s.join("&");
        };
        jQuery24.fn.extend({
          serialize: function() {
            return jQuery24.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery24.prop(this, "elements");
              return elements ? jQuery24.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery24(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
              var val = jQuery24(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery24.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
              while (dataType = dataTypes[i++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery24.each(structure[dataType] || [], function(_, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery24.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery24.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s, jqXHR, responses) {
          var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === void 0) {
              ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s.converters) {
              converters[conv.toLowerCase()] = s.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s.responseFields[current]) {
              jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
              response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e) {
                      return {
                        state: "parsererror",
                        error: conv ? e : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery24.extend({
          // Counter for holding the number of active queries
          active: 0,
          // Last-Modified header cache for next request
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
              // Convert anything to text
              "* text": String,
              // Text to html (true = no transformation)
              "text html": true,
              // Evaluate text as a json expression
              "text json": JSON.parse,
              // Parse text as xml
              "text xml": jQuery24.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
              url: true,
              context: true
            }
          },
          // Creates a full fledged settings object into target
          // with both ajaxSettings and settings fields.
          // If target is omitted, writes into ajaxSettings.
          ajaxSetup: function(target, settings) {
            return settings ? (
              // Building a settings object
              ajaxExtend(ajaxExtend(target, jQuery24.ajaxSettings), settings)
            ) : (
              // Extending ajaxSettings
              ajaxExtend(jQuery24.ajaxSettings, target)
            );
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          // Main method
          ajax: function(url, options) {
            if (typeof url === "object") {
              options = url;
              url = void 0;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery24.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery24(callbackContext) : jQuery24.event, deferred = jQuery24.Deferred(), completeDeferred = jQuery24.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              // Builds headers hashtable if needed
              getResponseHeader: function(key) {
                var match;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                    }
                  }
                  match = responseHeaders[key.toLowerCase() + " "];
                }
                return match == null ? null : match.join(", ");
              },
              // Raw string
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              // Caches the header
              setRequestHeader: function(name, value) {
                if (completed2 == null) {
                  name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              // Overrides response content-type header
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s.mimeType = type;
                }
                return this;
              },
              // Status-dependent callbacks
              statusCode: function(map2) {
                var code;
                if (map2) {
                  if (completed2) {
                    jqXHR.always(map2[jqXHR.status]);
                  } else {
                    for (code in map2) {
                      statusCode[code] = [statusCode[code], map2[code]];
                    }
                  }
                }
                return this;
              },
              // Cancel the request
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s.url;
                urlAnchor.href = urlAnchor.href;
                s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e) {
                s.crossDomain = true;
              }
            }
            if (s.data && s.processData && typeof s.data !== "string") {
              s.data = jQuery24.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery24.event && s.global;
            if (fireGlobals && jQuery24.active++ === 0) {
              jQuery24.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, "");
            if (!s.hasContent) {
              uncached = s.url.slice(cacheURL.length);
              if (s.data && (s.processData || typeof s.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                delete s.data;
              }
              if (s.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s.data = s.data.replace(r20, "+");
            }
            if (s.ifModified) {
              if (jQuery24.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery24.lastModified[cacheURL]);
              }
              if (jQuery24.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery24.etag[cacheURL]);
              }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
              jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
            );
            for (i in s.headers) {
              jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s.async && s.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e) {
                if (completed2) {
                  throw e;
                }
                done(-1, e);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s, jqXHR, responses);
              }
              if (!isSuccess && jQuery24.inArray("script", s.dataTypes) > -1 && jQuery24.inArray("json", s.dataTypes) < 0) {
                s.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery24.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery24.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error = response.error;
                  isSuccess = !error;
                }
              } else {
                error = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s, isSuccess ? success : error]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                if (!--jQuery24.active) {
                  jQuery24.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery24.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery24.get(url, void 0, callback, "script");
          }
        });
        jQuery24.each(["get", "post"], function(_i, method) {
          jQuery24[method] = function(url, data, callback, type) {
            if (isFunction(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery24.ajax(jQuery24.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            }, jQuery24.isPlainObject(url) && url));
          };
        });
        jQuery24.ajaxPrefilter(function(s) {
          var i;
          for (i in s.headers) {
            if (i.toLowerCase() === "content-type") {
              s.contentType = s.headers[i] || "";
            }
          }
        });
        jQuery24._evalUrl = function(url, options, doc) {
          return jQuery24.ajax({
            url,
            // Make this explicit, since user can override this through ajaxSetup (trac-11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery24.globalEval(response, options, doc);
            }
          });
        };
        jQuery24.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (this[0]) {
              if (isFunction(html)) {
                html = html.call(this[0]);
              }
              wrap = jQuery24(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction(html)) {
              return this.each(function(i) {
                jQuery24(this).wrapInner(html.call(this, i));
              });
            }
            return this.each(function() {
              var self = jQuery24(this), contents = self.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i) {
              jQuery24(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery24(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery24.expr.pseudos.hidden = function(elem) {
          return !jQuery24.expr.pseudos.visible(elem);
        };
        jQuery24.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery24.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e) {
          }
        };
        var xhrSuccessStatus = {
          // File protocol always yields status code 0, assume 200
          0: 200,
          // Support: IE <=9 only
          // trac-1450: sometimes IE returns 1223 when it should be 204
          1223: 204
        }, xhrSupported = jQuery24.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery24.ajaxTransport(function(options) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options.crossDomain) {
            return {
              send: function(headers, complete) {
                var i, xhr = options.xhr();
                xhr.open(
                  options.type,
                  options.url,
                  options.async,
                  options.username,
                  options.password
                );
                if (options.xhrFields) {
                  for (i in options.xhrFields) {
                    xhr[i] = options.xhrFields[i];
                  }
                }
                if (options.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options.mimeType);
                }
                if (!options.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i in headers) {
                  xhr.setRequestHeader(i, headers[i]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            // File: protocol always yields status 0; see trac-8605, trac-14207
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          // Support: IE <=9 only
                          // IE9 has no XHR2 but throws on binary (trac-11426)
                          // For XHR2 non-text, let the caller handle it (gh-2498)
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                  if (callback) {
                    throw e;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery24.ajaxPrefilter(function(s) {
          if (s.crossDomain) {
            s.contents.script = false;
          }
        });
        jQuery24.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery24.globalEval(text);
              return text;
            }
          }
        });
        jQuery24.ajaxPrefilter("script", function(s) {
          if (s.cache === void 0) {
            s.cache = false;
          }
          if (s.crossDomain) {
            s.type = "GET";
          }
        });
        jQuery24.ajaxTransport("script", function(s) {
          if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
              send: function(_, complete) {
                script = jQuery24("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery24.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery24.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery24.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
          if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
              s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
              s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery24.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery24(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s[callbackName]) {
                s.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery24.parseHTML = function(data, context, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base = context.createElement("base");
              base.href = document2.location.href;
              context.head.appendChild(base);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery24(scripts).remove();
          }
          return jQuery24.merge([], parsed.childNodes);
        };
        jQuery24.fn.load = function(url, params, callback) {
          var selector, type, response, self = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self.length > 0) {
            jQuery24.ajax({
              url,
              // If "type" variable is undefined, then "GET" method will be used.
              // Make value of this field explicit since
              // user can override it through ajaxSetup method
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self.html(selector ? (
                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery24("<div>").append(jQuery24.parseHTML(responseText)).find(selector)
              ) : (
                // Otherwise use the full result
                responseText
              ));
            }).always(callback && function(jqXHR, status) {
              self.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery24.expr.pseudos.animated = function(elem) {
          return jQuery24.grep(jQuery24.timers, function(fn) {
            return elem === fn.elem;
          }).length;
        };
        jQuery24.offset = {
          setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery24.css(elem, "position"), curElem = jQuery24(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery24.css(elem, "top");
            curCSSLeft = jQuery24.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) {
              options = options.call(elem, i, jQuery24.extend({}, curOffset));
            }
            if (options.top != null) {
              props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
              props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
              options.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery24.fn.extend({
          // offset() relates an element's border box to the document origin
          offset: function(options) {
            if (arguments.length) {
              return options === void 0 ? this : this.each(function(i) {
                jQuery24.offset.setOffset(this, options, i);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          // position() relates an element's margin box to its offset parent's padding box
          // This corresponds to the behavior of CSS absolute positioning
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery24.css(elem, "position") === "fixed") {
              offset = elem.getBoundingClientRect();
            } else {
              offset = this.offset();
              doc = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc.documentElement;
              while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery24.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery24(offsetParent).offset();
                parentOffset.top += jQuery24.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery24.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset.top - parentOffset.top - jQuery24.css(elem, "marginTop", true),
              left: offset.left - parentOffset.left - jQuery24.css(elem, "marginLeft", true)
            };
          },
          // This method will return documentElement in the following cases:
          // 1) For the element inside the iframe without offsetParent, this method will return
          //    documentElement of the parent window
          // 2) For the hidden or detached element
          // 3) For body or html element, i.e. in case of the html node - it will return itself
          //
          // but those exceptions were never presented as a real life use-cases
          // and might be considered as more preferable results.
          //
          // This logic, however, is not guaranteed and can change at any point in the future
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery24.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery24.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top = "pageYOffset" === prop;
          jQuery24.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top ? val2 : win.pageXOffset,
                  top ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery24.each(["top", "left"], function(_i, prop) {
          jQuery24.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery24(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery24.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery24.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
          }, function(defaultExtra, funcName) {
            jQuery24.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name],
                    doc["scroll" + name],
                    elem.body["offset" + name],
                    doc["offset" + name],
                    doc["client" + name]
                  );
                }
                return value2 === void 0 ? (
                  // Get width or height on the element, requesting but not forcing parseFloat
                  jQuery24.css(elem, type2, extra)
                ) : (
                  // Set width or height on the element
                  jQuery24.style(elem, type2, value2, extra)
                );
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery24.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i, type) {
          jQuery24.fn[type] = function(fn) {
            return this.on(type, fn);
          };
        });
        jQuery24.fn.extend({
          bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
          },
          unbind: function(types, fn) {
            return this.off(types, null, fn);
          },
          delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
          },
          undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
          },
          hover: function(fnOver, fnOut) {
            return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
          }
        });
        jQuery24.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i, name) {
            jQuery24.fn[name] = function(data, fn) {
              return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        jQuery24.proxy = function(fn, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
          }
          if (!isFunction(fn)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn.guid = fn.guid || jQuery24.guid++;
          return proxy;
        };
        jQuery24.holdReady = function(hold) {
          if (hold) {
            jQuery24.readyWait++;
          } else {
            jQuery24.ready(true);
          }
        };
        jQuery24.isArray = Array.isArray;
        jQuery24.parseJSON = JSON.parse;
        jQuery24.nodeName = nodeName;
        jQuery24.isFunction = isFunction;
        jQuery24.isWindow = isWindow;
        jQuery24.camelCase = camelCase;
        jQuery24.type = toType;
        jQuery24.now = Date.now;
        jQuery24.isNumeric = function(obj) {
          var type = jQuery24.type(obj);
          return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          !isNaN(obj - parseFloat(obj));
        };
        jQuery24.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "$1");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery24;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery24.noConflict = function(deep) {
          if (window2.$ === jQuery24) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery24) {
            window2.jQuery = _jQuery;
          }
          return jQuery24;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery24;
        }
        return jQuery24;
      });
    }
  });

  // node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs
  var import_jquery2 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net/js/dataTables.mjs
  var import_jquery = __toESM(require_jquery(), 1);
  var $ = import_jquery.default;
  var DataTable = function(selector, options) {
    if (DataTable.factory(selector, options)) {
      return DataTable;
    }
    if (this instanceof DataTable) {
      return $(selector).DataTable(options);
    } else {
      options = selector;
    }
    var _that = this;
    var emptyInit = options === void 0;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.api = function() {
      return new _Api(this);
    };
    this.each(function() {
      var o = {};
      var oInit = len > 1 ? (
        // optimisation for single table case
        _fnExtend(o, options, true)
      ) : options;
      var i = 0, iLen;
      var sId = this.getAttribute("id");
      var defaults = DataTable.defaults;
      var $this = $(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      $(this).trigger("options.dt", oInit);
      _fnCompatOpts(defaults);
      _fnCompatCols(defaults.column);
      _fnCamelToHungarian(defaults, defaults, true);
      _fnCamelToHungarian(defaults.column, defaults.column, true);
      _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()), true);
      var allSettings = DataTable.settings;
      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            new DataTable.Api(s).destroy();
            break;
          } else {
            _fnLog(s, 0, "Cannot reinitialise DataTable", 3);
            return;
          }
        }
        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable.ext._unique++;
        this.id = sId;
      }
      var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId,
        colgroup: $("<colgroup>").prependTo(this),
        fastData: function(row, column, type) {
          return _fnGetCellData(oSettings, row, column, type);
        }
      });
      oSettings.nTable = this;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.api = new _Api(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts(oInit);
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : $.isPlainObject(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0].value : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend($.extend(true, {}, defaults), oInit);
      _fnMap(oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ]);
      _fnMap(oSettings, oInit, [
        "ajax",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "iStateDuration",
        "bSortCellsTop",
        "iTabIndex",
        "sDom",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        "caption",
        "layout",
        "orderDescReverse",
        "typeDetect",
        ["iCookieDuration", "iStateDuration"],
        // backwards compat
        ["oSearch", "oPreviousSearch"],
        ["aoSearchCols", "aoPreSearchCols"],
        ["iDisplayLength", "_iDisplayLength"]
      ]);
      _fnMap(oSettings.oScroll, oInit, [
        ["sScrollX", "sX"],
        ["sScrollXInner", "sXInner"],
        ["sScrollY", "sY"],
        ["bScrollCollapse", "bCollapse"]
      ]);
      _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg(oSettings, "aoDrawCallback", oInit.fnDrawCallback);
      _fnCallbackReg(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams);
      _fnCallbackReg(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams);
      _fnCallbackReg(oSettings, "aoStateLoaded", oInit.fnStateLoaded);
      _fnCallbackReg(oSettings, "aoRowCallback", oInit.fnRowCallback);
      _fnCallbackReg(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow);
      _fnCallbackReg(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback);
      _fnCallbackReg(oSettings, "aoFooterCallback", oInit.fnFooterCallback);
      _fnCallbackReg(oSettings, "aoInitComplete", oInit.fnInitComplete);
      _fnCallbackReg(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback);
      oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
      _fnBrowserDetect(oSettings);
      var oClasses = oSettings.oClasses;
      $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.table);
      if (!oSettings.oFeatures.bPaginate) {
        oInit.iDisplayStart = 0;
      }
      if (oSettings.iInitDisplayStart === void 0) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      var defer = oInit.iDeferLoading;
      if (defer !== null) {
        oSettings.deferLoading = true;
        var tmp = Array.isArray(defer);
        oSettings._iRecordsDisplay = tmp ? defer[0] : defer;
        oSettings._iRecordsTotal = tmp ? defer[1] : defer;
      }
      var columnsInit = [];
      var thead = this.getElementsByTagName("thead");
      var initHeaderLayout = _fnDetectHeader(oSettings, thead[0]);
      if (oInit.aoColumns) {
        columnsInit = oInit.aoColumns;
      } else if (initHeaderLayout.length) {
        for (i = 0, iLen = initHeaderLayout[0].length; i < iLen; i++) {
          columnsInit.push(null);
        }
      }
      for (i = 0, iLen = columnsInit.length; i < iLen; i++) {
        _fnAddColumn(oSettings);
      }
      _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function(iCol, oDef) {
        _fnColumnOptions(oSettings, iCol, oDef);
      });
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if (rowOne.length) {
        var a = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $(rowOne[0]).children("th, td").each(function(i2, cell) {
          var col = oSettings.aoColumns[i2];
          if (!col) {
            _fnLog(oSettings, 0, "Incorrect column count", 18);
          }
          if (col.mData === i2) {
            var sort = a(cell, "sort") || a(cell, "order");
            var filter = a(cell, "filter") || a(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {
                _: i2 + ".display",
                sort: sort !== null ? i2 + ".@data-" + sort : void 0,
                type: sort !== null ? i2 + ".@data-" + sort : void 0,
                filter: filter !== null ? i2 + ".@data-" + filter : void 0
              };
              col._isArrayHost = true;
              _fnColumnOptions(oSettings, i2);
            }
          }
        });
      }
      _fnCallbackReg(oSettings, "aoDrawCallback", _fnSaveState);
      var features = oSettings.oFeatures;
      if (oInit.bStateSave) {
        features.bStateSave = true;
      }
      if (oInit.aaSorting === void 0) {
        var sorting = oSettings.aaSorting;
        for (i = 0, iLen = sorting.length; i < iLen; i++) {
          sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
        }
      }
      _fnSortingClasses(oSettings);
      _fnCallbackReg(oSettings, "aoDrawCallback", function() {
        if (oSettings.bSorted || _fnDataSource(oSettings) === "ssp" || features.bDeferRender) {
          _fnSortingClasses(oSettings);
        }
      });
      var caption = $this.children("caption");
      if (oSettings.caption) {
        if (caption.length === 0) {
          caption = $("<caption/>").appendTo($this);
        }
        caption.html(oSettings.caption);
      }
      if (caption.length) {
        caption[0]._captionSide = caption.css("caption-side");
        oSettings.captionNode = caption[0];
      }
      if (thead.length === 0) {
        thead = $("<thead/>").appendTo($this);
      }
      oSettings.nTHead = thead[0];
      $("tr", thead).addClass(oClasses.thead.row);
      var tbody = $this.children("tbody");
      if (tbody.length === 0) {
        tbody = $("<tbody/>").insertAfter(thead);
      }
      oSettings.nTBody = tbody[0];
      var tfoot = $this.children("tfoot");
      if (tfoot.length === 0) {
        tfoot = $("<tfoot/>").appendTo($this);
      }
      oSettings.nTFoot = tfoot[0];
      $("tr", tfoot).addClass(oClasses.tfoot.row);
      oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
      oSettings.bInitialised = true;
      var oLanguage = oSettings.oLanguage;
      $.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl) {
        $.ajax({
          dataType: "json",
          url: oLanguage.sUrl,
          success: function(json) {
            _fnCamelToHungarian(defaults.oLanguage, json);
            $.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
            _fnCallbackFire(oSettings, null, "i18n", [oSettings], true);
            _fnInitialise(oSettings);
          },
          error: function() {
            _fnLog(oSettings, 0, "i18n file loading error", 21);
            _fnInitialise(oSettings);
          }
        });
      } else {
        _fnCallbackFire(oSettings, null, "i18n", [oSettings], true);
        _fnInitialise(oSettings);
      }
    });
    _that = null;
    return this;
  };
  DataTable.ext = _ext = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",
    /**
     * Legacy so v1 plug-ins don't throw js errors on load
     */
    feature: [],
    /**
     * Feature plug-ins.
     * 
     * This is an object of callbacks which provide the features for DataTables
     * to be initialised via the `layout` option.
     */
    features: {},
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Automatic column class assignment
       */
      className: {},
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
      /**
       * Automatic renderer assignment
       */
      render: {},
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatibility only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable.fnVersionCheck,
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable.version
  };
  $.extend(_ext, {
    afnFiltering: _ext.search,
    aTypes: _ext.type.detect,
    ofnSearch: _ext.type.search,
    oSort: _ext.type.order,
    afnSortData: _ext.order,
    aoFeatures: _ext.feature,
    oStdClasses: _ext.classes,
    oPagination: _ext.pager
  });
  $.extend(DataTable.ext.classes, {
    container: "dt-container",
    empty: {
      row: "dt-empty"
    },
    info: {
      container: "dt-info"
    },
    layout: {
      row: "dt-layout-row",
      cell: "dt-layout-cell",
      tableRow: "dt-layout-table",
      tableCell: "",
      start: "dt-layout-start",
      end: "dt-layout-end",
      full: "dt-layout-full"
    },
    length: {
      container: "dt-length",
      select: "dt-input"
    },
    order: {
      canAsc: "dt-orderable-asc",
      canDesc: "dt-orderable-desc",
      isAsc: "dt-ordering-asc",
      isDesc: "dt-ordering-desc",
      none: "dt-orderable-none",
      position: "sorting_"
    },
    processing: {
      container: "dt-processing"
    },
    scrolling: {
      body: "dt-scroll-body",
      container: "dt-scroll",
      footer: {
        self: "dt-scroll-foot",
        inner: "dt-scroll-footInner"
      },
      header: {
        self: "dt-scroll-head",
        inner: "dt-scroll-headInner"
      }
    },
    search: {
      container: "dt-search",
      input: "dt-input"
    },
    table: "dataTable",
    tbody: {
      cell: "",
      row: ""
    },
    thead: {
      cell: "",
      row: ""
    },
    tfoot: {
      cell: "",
      row: ""
    },
    paging: {
      active: "current",
      button: "dt-paging-button",
      container: "dt-paging",
      disabled: "disabled",
      nav: ""
    }
  });
  var _ext;
  var _Api;
  var _api_register;
  var _api_registerPlural;
  var _re_dic = {};
  var _re_new_lines = /[\r\n\u2028]/g;
  var _re_html = /<([^>]*>)/g;
  var _max_str_len = Math.pow(2, 28);
  var _re_date = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;
  var _re_escape_regex = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty = function(d) {
    return !d || d === true || d === "-" ? true : false;
  };
  var _intVal = function(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  var _numToDecimal = function(num, decimalPoint) {
    if (!_re_dic[decimalPoint]) {
      _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic[decimalPoint], ".") : num;
  };
  var _isNumber = function(d, decimalPoint, formatted, allowEmpty) {
    var type = typeof d;
    var strType = type === "string";
    if (type === "number" || type === "bigint") {
      return true;
    }
    if (allowEmpty && _empty(d)) {
      return true;
    }
    if (decimalPoint && strType) {
      d = _numToDecimal(d, decimalPoint);
    }
    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric, "");
    }
    return !isNaN(parseFloat(d)) && isFinite(d);
  };
  var _isHtml = function(d) {
    return _empty(d) || typeof d === "string";
  };
  var _htmlNumeric = function(d, decimalPoint, formatted, allowEmpty) {
    if (allowEmpty && _empty(d)) {
      return true;
    }
    if (typeof d === "string" && d.match(/<(input|select)/i)) {
      return null;
    }
    var html = _isHtml(d);
    return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted, allowEmpty) ? true : null;
  };
  var _pluck = function(a, prop, prop2) {
    var out = [];
    var i = 0, ien = a.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order = function(a, order, prop, prop2) {
    var out = [];
    var i = 0, ien = order.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[order[i]] && a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[order[i]]) {
          out.push(a[order[i]][prop]);
        }
      }
    }
    return out;
  };
  var _range = function(len, start) {
    var out = [];
    var end;
    if (start === void 0) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }
    for (var i = start; i < end; i++) {
      out.push(i);
    }
    return out;
  };
  var _removeEmpty = function(a) {
    var out = [];
    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        out.push(a[i]);
      }
    }
    return out;
  };
  var _stripHtml = function(input) {
    if (!input || typeof input !== "string") {
      return input;
    }
    if (input.length > _max_str_len) {
      throw new Error("Exceeded max str len");
    }
    var previous;
    input = input.replace(_re_html, "");
    do {
      previous = input;
      input = input.replace(/<script/i, "");
    } while (input !== previous);
    return previous;
  };
  var _escapeHtml = function(d) {
    if (Array.isArray(d)) {
      d = d.join(",");
    }
    return typeof d === "string" ? d.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d;
  };
  var _normalize = function(str, both) {
    if (typeof str !== "string") {
      return str;
    }
    var res = str.normalize ? str.normalize("NFD") : str;
    return res.length !== str.length ? (both === true ? str + " " : "") + res.replace(/[\u0300-\u036f]/g, "") : res;
  };
  var _areAllUnique = function(src) {
    if (src.length < 2) {
      return true;
    }
    var sorted = src.slice().sort();
    var last = sorted[0];
    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }
      last = sorted[i];
    }
    return true;
  };
  var _unique = function(src) {
    if (Array.from && Set) {
      return Array.from(new Set(src));
    }
    if (_areAllUnique(src)) {
      return src.slice();
    }
    var out = [], val, i, ien = src.length, j, k = 0;
    again: for (i = 0; i < ien; i++) {
      val = src[i];
      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }
      out.push(val);
      k++;
    }
    return out;
  };
  var _flatten = function(out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten(out, val[i]);
      }
    } else {
      out.push(val);
    }
    return out;
  };
  function _addClass(el, name) {
    if (name) {
      name.split(" ").forEach(function(n) {
        if (n) {
          el.classList.add(n);
        }
      });
    }
  }
  DataTable.util = {
    /**
     * Return a string with diacritic characters decomposed
     * @param {*} mixed Function or string to normalize
     * @param {*} both Return original string and the normalized string
     * @returns String or undefined
     */
    diacritics: function(mixed, both) {
      var type = typeof mixed;
      if (type !== "function") {
        return _normalize(mixed, both);
      }
      _normalize = mixed;
    },
    /**
     * Debounce a function
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    debounce: function(fn, timeout) {
      var timer;
      return function() {
        var that = this;
        var args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(that, args);
        }, timeout || 250);
      };
    },
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function(fn, freq) {
      var frequency = freq !== void 0 ? freq : 200, last, timer;
      return function() {
        var that = this, now = +/* @__PURE__ */ new Date(), args = arguments;
        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            last = void 0;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },
    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function(val) {
      return val.replace(_re_escape_regex, "\\$1");
    },
    /**
     * Create a function that will write to a nested object or array
     * @param {*} source JSON notation string
     * @returns Write function
     */
    set: function(source) {
      if ($.isPlainObject(source)) {
        return DataTable.util.set(source._);
      } else if (source === null) {
        return function() {
        };
      } else if (typeof source === "function") {
        return function(data, val, meta) {
          source(data, "set", val, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var setData = function(data, val, src) {
          var a = _fnSplitObjNotation(src), b;
          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;
          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            if (a[i] === "__proto__" || a[i] === "constructor") {
              throw new Error("Cannot set prototype values");
            }
            arrayNotation = a[i].match(__reArray);
            funcNotation = a[i].match(__reFn);
            if (arrayNotation) {
              a[i] = a[i].replace(__reArray, "");
              data[a[i]] = [];
              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join(".");
              if (Array.isArray(val)) {
                for (var j = 0, jLen = val.length; j < jLen; j++) {
                  o = {};
                  setData(o, val[j], innerSrc);
                  data[a[i]].push(o);
                }
              } else {
                data[a[i]] = val;
              }
              return;
            } else if (funcNotation) {
              a[i] = a[i].replace(__reFn, "");
              data = data[a[i]](val);
            }
            if (data[a[i]] === null || data[a[i]] === void 0) {
              data[a[i]] = {};
            }
            data = data[a[i]];
          }
          if (aLast.match(__reFn)) {
            data = data[aLast.replace(__reFn, "")](val);
          } else {
            data[aLast.replace(__reArray, "")] = val;
          }
        };
        return function(data, val) {
          return setData(data, val, source);
        };
      } else {
        return function(data, val) {
          data[source] = val;
        };
      }
    },
    /**
     * Create a function that will read nested objects from arrays, based on JSON notation
     * @param {*} source JSON notation string
     * @returns Value read
     */
    get: function(source) {
      if ($.isPlainObject(source)) {
        var o = {};
        $.each(source, function(key, val) {
          if (val) {
            o[key] = DataTable.util.get(val);
          }
        });
        return function(data, type, row, meta) {
          var t = o[type] || o._;
          return t !== void 0 ? t(data, type, row, meta) : data;
        };
      } else if (source === null) {
        return function(data) {
          return data;
        };
      } else if (typeof source === "function") {
        return function(data, type, row, meta) {
          return source(data, type, row, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var fetchData = function(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== "") {
            var a = _fnSplitObjNotation(src);
            for (var i = 0, iLen = a.length; i < iLen; i++) {
              arrayNotation = a[i].match(__reArray);
              funcNotation = a[i].match(__reFn);
              if (arrayNotation) {
                a[i] = a[i].replace(__reArray, "");
                if (a[i] !== "") {
                  data = data[a[i]];
                }
                out = [];
                a.splice(0, i + 1);
                innerSrc = a.join(".");
                if (Array.isArray(data)) {
                  for (var j = 0, jLen = data.length; j < jLen; j++) {
                    out.push(fetchData(data[j], type, innerSrc));
                  }
                }
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join);
                break;
              } else if (funcNotation) {
                a[i] = a[i].replace(__reFn, "");
                data = data[a[i]]();
                continue;
              }
              if (data === null || data[a[i]] === null) {
                return null;
              } else if (data === void 0 || data[a[i]] === void 0) {
                return void 0;
              }
              data = data[a[i]];
            }
          }
          return data;
        };
        return function(data, type) {
          return fetchData(data, type, source);
        };
      } else {
        return function(data) {
          return data[source];
        };
      }
    },
    stripHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _stripHtml = mixed;
        return;
      } else if (type === "string") {
        return _stripHtml(mixed);
      }
      return mixed;
    },
    escapeHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _escapeHtml = mixed;
        return;
      } else if (type === "string" || Array.isArray(mixed)) {
        return _escapeHtml(mixed);
      }
      return mixed;
    },
    unique: _unique
  };
  function _fnHungarianMap(o) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map2 = {};
    $.each(o, function(key) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map2[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap(o[key]);
        }
      }
    });
    o._hungarianMap = map2;
  }
  function _fnCamelToHungarian(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap(src);
    }
    var hungarianKey;
    $.each(user, function(key) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  var _fnCompatMap = function(o, knew, old) {
    if (o[knew] !== void 0) {
      o[old] = o[knew];
    }
  };
  function _fnCompatOpts(init2) {
    _fnCompatMap(init2, "ordering", "bSort");
    _fnCompatMap(init2, "orderMulti", "bSortMulti");
    _fnCompatMap(init2, "orderClasses", "bSortClasses");
    _fnCompatMap(init2, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap(init2, "order", "aaSorting");
    _fnCompatMap(init2, "orderFixed", "aaSortingFixed");
    _fnCompatMap(init2, "paging", "bPaginate");
    _fnCompatMap(init2, "pagingType", "sPaginationType");
    _fnCompatMap(init2, "pageLength", "iDisplayLength");
    _fnCompatMap(init2, "searching", "bFilter");
    if (typeof init2.sScrollX === "boolean") {
      init2.sScrollX = init2.sScrollX ? "100%" : "";
    }
    if (typeof init2.scrollX === "boolean") {
      init2.scrollX = init2.scrollX ? "100%" : "";
    }
    var searchCols = init2.aoSearchCols;
    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
        }
      }
    }
    if (init2.serverSide && !init2.searchDelay) {
      init2.searchDelay = 400;
    }
  }
  function _fnCompatCols(init2) {
    _fnCompatMap(init2, "orderable", "bSortable");
    _fnCompatMap(init2, "orderData", "aDataSort");
    _fnCompatMap(init2, "orderSequence", "asSorting");
    _fnCompatMap(init2, "orderDataType", "sortDataType");
    var dataSort = init2.aDataSort;
    if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
      init2.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect(settings) {
    if (!DataTable.__browser) {
      var browser = {};
      DataTable.__browser = browser;
      var n = $("<div/>").css({
        position: "fixed",
        top: 0,
        left: -1 * window.pageXOffset,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(
        $("<div/>").css({
          position: "absolute",
          top: 1,
          left: 1,
          width: 100,
          overflow: "scroll"
        }).append(
          $("<div/>").css({
            width: "100%",
            height: 10
          })
        )
      ).appendTo("body");
      var outer = n.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      n.remove();
    }
    $.extend(settings.oBrowser, DataTable.__browser);
    settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
  }
  function _fnAddColumn(oSettings) {
    var oDefaults = DataTable.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol,
      searchFixed: {},
      colEl: $("<col>").attr("data-dt-column", iCol)
    });
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);
  }
  function _fnColumnOptions(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    if (oOptions !== void 0 && oOptions !== null) {
      _fnCompatCols(oOptions);
      _fnCamelToHungarian(DataTable.defaults.column, oOptions, true);
      if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      var origClass = oCol.sClass;
      $.extend(oCol, oOptions);
      _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
      if (origClass !== oCol.sClass) {
        oCol.sClass = origClass + " " + oCol.sClass;
      }
      if (oOptions.iDataSort !== void 0) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap(oCol, oOptions, "aDataSort");
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn(mDataSrc);
    if (oCol.mRender && Array.isArray(oCol.mRender)) {
      var copy = oCol.mRender.slice();
      var name = copy.shift();
      oCol.mRender = DataTable.render[name].apply(window, copy);
    }
    oCol._render = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, void 0, meta);
      return oCol._render && type ? oCol._render(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
    }
  }
  function _fnAdjustColumnSizing(settings) {
    _fnCalculateColumnWidths(settings);
    _fnColumnSizes(settings);
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw(settings);
    }
    _fnCallbackFire(settings, null, "column-sizing", [settings]);
  }
  function _fnColumnSizes(settings) {
    var cols = settings.aoColumns;
    for (var i = 0; i < cols.length; i++) {
      var width = _fnColumnsSumWidth(settings, [i], false, false);
      cols[i].colEl.css("width", width);
    }
  }
  function _fnVisibleToColumnIndex(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, "bVisible");
    var iPos = aiVis.indexOf(iMatch);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns(settings) {
    var layout = settings.aoHeader;
    var columns = settings.aoColumns;
    var vis = 0;
    if (layout.length) {
      for (var i = 0, ien = layout[0].length; i < ien; i++) {
        if (columns[i].bVisible && $(layout[0][i].cell).css("display") !== "none") {
          vis++;
        }
      }
    }
    return vis;
  }
  function _fnGetColumns(oSettings, sParam) {
    var a = [];
    oSettings.aoColumns.map(function(val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  function _typeResult(typeDetect, res) {
    return res === true ? typeDetect._name : res;
  }
  function _fnColumnTypes(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, detectedType, cache;
    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        if (!settings.typeDetect) {
          return;
        }
        for (j = 0, jen = types.length; j < jen; j++) {
          var typeDetect = types[j];
          var oneOf = typeDetect.oneOf;
          var allOf = typeDetect.allOf || typeDetect;
          var init2 = typeDetect.init;
          var one = false;
          detectedType = null;
          if (init2) {
            detectedType = _typeResult(typeDetect, init2(settings, col, i));
            if (detectedType) {
              col.sType = detectedType;
              break;
            }
          }
          for (k = 0, ken = data.length; k < ken; k++) {
            if (!data[k]) {
              continue;
            }
            if (cache[k] === void 0) {
              cache[k] = _fnGetCellData(settings, k, i, "type");
            }
            if (oneOf && !one) {
              one = _typeResult(typeDetect, oneOf(cache[k], settings));
            }
            detectedType = _typeResult(typeDetect, allOf(cache[k], settings));
            if (!detectedType && j !== types.length - 3) {
              break;
            }
            if (detectedType === "html" && !_empty(cache[k])) {
              break;
            }
          }
          if (oneOf && one && detectedType || !oneOf && detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        if (!col.sType) {
          col.sType = "string";
        }
      }
      var autoClass = _ext.type.className[col.sType];
      if (autoClass) {
        _columnAutoClass(settings.aoHeader, i, autoClass);
        _columnAutoClass(settings.aoFooter, i, autoClass);
      }
      var renderer = _ext.type.render[col.sType];
      if (renderer && !col._render) {
        col._render = DataTable.util.get(renderer);
        _columnAutoRender(settings, i);
      }
    }
  }
  function _columnAutoRender(settings, colIdx) {
    var data = settings.aoData;
    for (var i = 0; i < data.length; i++) {
      if (data[i].nTr) {
        var display = _fnGetCellData(settings, i, colIdx, "display");
        data[i].displayData[colIdx] = display;
        _fnWriteCell(data[i].anCells[colIdx], display);
      }
    }
  }
  function _columnAutoClass(container, colIdx, className) {
    container.forEach(function(row) {
      if (row[colIdx] && row[colIdx].unique) {
        _addClass(row[colIdx].cell, className);
      }
    });
  }
  function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, headerLayout, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        if (aoCols[i] && aoCols[i].name) {
          columns[i].sName = aoCols[i].name;
        }
      }
    }
    if (aoColDefs) {
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        var aTargets = def.target !== void 0 ? def.target : def.targets !== void 0 ? def.targets : def.aTargets;
        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          var target = aTargets[j];
          if (typeof target === "number" && target >= 0) {
            while (columns.length <= target) {
              _fnAddColumn(oSettings);
            }
            fn(target, def);
          } else if (typeof target === "number" && target < 0) {
            fn(columns.length + target, def);
          } else if (typeof target === "string") {
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (target === "_all") {
                fn(k, def);
              } else if (target.indexOf(":name") !== -1) {
                if (columns[k].sName === target.replace(":name", "")) {
                  fn(k, def);
                }
              } else {
                headerLayout.forEach(function(row) {
                  if (row[k]) {
                    var cell = $(row[k].cell);
                    if (target.match(/^[a-z][\w-]*$/i)) {
                      target = "." + target;
                    }
                    if (cell.is(target)) {
                      fn(k, def);
                    }
                  }
                });
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  function _fnColumnsSumWidth(settings, targets, original, incVisible) {
    if (!Array.isArray(targets)) {
      targets = _fnColumnsFromHeader(targets);
    }
    var sum = 0;
    var unit;
    var columns = settings.aoColumns;
    for (var i = 0, ien = targets.length; i < ien; i++) {
      var column = columns[targets[i]];
      var definedWidth = original ? column.sWidthOrig : column.sWidth;
      if (!incVisible && column.bVisible === false) {
        continue;
      }
      if (definedWidth === null || definedWidth === void 0) {
        return null;
      } else if (typeof definedWidth === "number") {
        unit = "px";
        sum += definedWidth;
      } else {
        var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);
        if (matched) {
          sum += matched[1] * 1;
          unit = matched.length === 3 ? matched[2] : "px";
        }
      }
    }
    return sum + unit;
  }
  function _fnColumnsFromHeader(cell) {
    var attr = $(cell).closest("[data-dt-column]").attr("data-dt-column");
    if (!attr) {
      return [];
    }
    return attr.split(",").map(function(val) {
      return val * 1;
    });
  }
  function _fnAddData(settings, dataIn, tr, tds) {
    var rowIdx = settings.aoData.length;
    var rowModel = $.extend(true, {}, DataTable.models.oRow, {
      src: tr ? "dom" : "data",
      idx: rowIdx
    });
    rowModel._aData = dataIn;
    settings.aoData.push(rowModel);
    var columns = settings.aoColumns;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    settings.aiDisplayMaster.push(rowIdx);
    var id = settings.rowIdFn(dataIn);
    if (id !== void 0) {
      settings.aIds[id] = rowModel;
    }
    if (tr || !settings.oFeatures.bDeferRender) {
      _fnCreateTr(settings, rowIdx, tr, tds);
    }
    return rowIdx;
  }
  function _fnAddTr(settings, trs) {
    var row;
    if (!(trs instanceof $)) {
      trs = $(trs);
    }
    return trs.map(function(i, el) {
      row = _fnGetRowElements(settings, el);
      return _fnAddData(settings, row.data, el, row.cells);
    });
  }
  function _fnGetCellData(settings, rowIdx, colIdx, type) {
    if (type === "search") {
      type = "filter";
    } else if (type === "order") {
      type = "sort";
    }
    var row = settings.aoData[rowIdx];
    if (!row) {
      return void 0;
    }
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = row._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings,
      row: rowIdx,
      col: colIdx
    });
    if (type !== "display" && cellData && typeof cellData === "object" && cellData.nodeName) {
      cellData = cellData.innerHTML;
    }
    if (cellData === void 0) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
      cellData = defaultContent;
    } else if (typeof cellData === "function") {
      return cellData.call(rowData);
    }
    if (cellData === null && type === "display") {
      return "";
    }
    if (type === "filter") {
      var fomatters = DataTable.ext.type.search;
      if (fomatters[col.sType]) {
        cellData = fomatters[col.sType](cellData);
      }
    }
    return cellData;
  }
  function _fnSetCellData(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings,
      row: rowIdx,
      col: colIdx
    });
  }
  function _fnWriteCell(td, val) {
    if (val && typeof val === "object" && val.nodeName) {
      $(td).empty().append(val);
    } else {
      td.innerHTML = val;
    }
  }
  var __reArray = /\[.*?\]$/;
  var __reFn = /\(\)$/;
  function _fnSplitObjNotation(str) {
    var parts = str.match(/(\\.|[^.])+/g) || [""];
    return parts.map(function(s) {
      return s.replace(/\\\./g, ".");
    });
  }
  var _fnGetObjectDataFn = DataTable.util.get;
  var _fnSetObjectDataFn = DataTable.util.set;
  function _fnGetDataMaster(settings) {
    return _pluck(settings.aoData, "_aData");
  }
  function _fnClearTable(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnInvalidate(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;
    row._aSortData = null;
    row._aFilterData = null;
    row.displayData = null;
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements(
        settings,
        row,
        colIdx,
        colIdx === void 0 ? void 0 : row._aData
      ).data;
    } else {
      var cells = row.anCells;
      var display = _fnGetRowDisplay(settings, rowIdx);
      if (cells) {
        if (colIdx !== void 0) {
          _fnWriteCell(cells[colIdx], display[colIdx]);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            _fnWriteCell(cells[i], display[i]);
          }
        }
      }
    }
    var cols = settings.aoColumns;
    if (colIdx !== void 0) {
      cols[colIdx].sType = null;
      cols[colIdx].maxLenString = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
        cols[i].maxLenString = null;
      }
      _fnRowAttributes(settings, row);
    }
  }
  function _fnGetRowElements(settings, row, colIdx, d) {
    var tds = [], td = row.firstChild, name, col, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d = d !== void 0 ? d : objectRead ? {} : [];
    var attr = function(str, td2) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr2 = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn(str);
          setter(d, td2.getAttribute(attr2));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === void 0 || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn(col.mData._);
          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn(col.mData);
            }
            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }
      i++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn(settings.rowId)(d, id);
      }
    }
    return {
      data: d,
      cells: tds
    };
  }
  function _fnGetRowDisplay(settings, rowIdx) {
    var rowModal = settings.aoData[rowIdx];
    var columns = settings.aoColumns;
    if (!rowModal.displayData) {
      rowModal.displayData = [];
      for (var colIdx = 0, len = columns.length; colIdx < len; colIdx++) {
        rowModal.displayData.push(
          _fnGetCellData(settings, rowIdx, colIdx, "display")
        );
      }
    }
    return rowModal.displayData;
  }
  function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create, trClass = oSettings.oClasses.tbody.row;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      _addClass(nTr, trClass);
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes(oSettings, row);
      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn && anTds[i] ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        if (!nTd) {
          _fnLog(oSettings, 0, "Incorrect column count", 18);
        }
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd);
        var display = _fnGetRowDisplay(oSettings, iRow);
        if (create || (oCol.mRender || oCol.mData !== i) && (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
          _fnWriteCell(nTd, display[i]);
        }
        _addClass(nTd, oCol.sClass);
        if (oCol.bVisible && create) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && !create) {
          nTd.parentNode.removeChild(nTd);
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(
            oSettings.oInstance,
            nTd,
            _fnGetCellData(oSettings, iRow, i),
            rowData,
            iRow,
            i
          );
        }
      }
      _fnCallbackFire(oSettings, "aoRowCreatedCallback", "row-created", [nTr, rowData, iRow, cells]);
    } else {
      _addClass(row.nTr, trClass);
    }
  }
  function _fnRowAttributes(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;
        $(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead(settings, side) {
    var classes = settings.oClasses;
    var columns = settings.aoColumns;
    var i, ien, row;
    var target = side === "header" ? settings.nTHead : settings.nTFoot;
    var titleProp = side === "header" ? "sTitle" : side;
    if (!target) {
      return;
    }
    if (side === "header" || _pluck(settings.aoColumns, titleProp).join("")) {
      row = $("tr", target);
      if (!row.length) {
        row = $("<tr/>").appendTo(target);
      }
      if (row.length === 1) {
        var cells = $("td, th", row);
        for (i = cells.length, ien = columns.length; i < ien; i++) {
          $("<th/>").html(columns[i][titleProp] || "").appendTo(row);
        }
      }
    }
    var detected = _fnDetectHeader(settings, target, true);
    if (side === "header") {
      settings.aoHeader = detected;
    } else {
      settings.aoFooter = detected;
    }
    $(target).children("tr").attr("role", "row");
    $(target).children("tr").children("th, td").each(function() {
      _fnRenderer(settings, side)(
        settings,
        $(this),
        classes
      );
    });
  }
  function _fnHeaderLayout(settings, source, incColumns) {
    var row, column, cell;
    var local = [];
    var structure = [];
    var columns = settings.aoColumns;
    var columnCount = columns.length;
    var rowspan, colspan;
    if (!source) {
      return;
    }
    if (!incColumns) {
      incColumns = _range(columnCount).filter(function(idx) {
        return columns[idx].bVisible;
      });
    }
    for (row = 0; row < source.length; row++) {
      local[row] = source[row].slice().filter(function(cell2, i) {
        return incColumns.includes(i);
      });
      structure.push([]);
    }
    for (row = 0; row < local.length; row++) {
      for (column = 0; column < local[row].length; column++) {
        rowspan = 1;
        colspan = 1;
        if (structure[row][column] === void 0) {
          cell = local[row][column].cell;
          while (local[row + rowspan] !== void 0 && local[row][column].cell == local[row + rowspan][column].cell) {
            structure[row + rowspan][column] = null;
            rowspan++;
          }
          while (local[row][column + colspan] !== void 0 && local[row][column].cell == local[row][column + colspan].cell) {
            for (var k = 0; k < rowspan; k++) {
              structure[row + k][column + colspan] = null;
            }
            colspan++;
          }
          var titleSpan = $("span.dt-column-title", cell);
          structure[row][column] = {
            cell,
            colspan,
            rowspan,
            title: titleSpan.length ? titleSpan.html() : $(cell).html()
          };
        }
      }
    }
    return structure;
  }
  function _fnDrawHead(settings, source) {
    var layout = _fnHeaderLayout(settings, source);
    var tr, n;
    for (var row = 0; row < source.length; row++) {
      tr = source[row].row;
      if (tr) {
        while (n = tr.firstChild) {
          tr.removeChild(n);
        }
      }
      for (var column = 0; column < layout[row].length; column++) {
        var point = layout[row][column];
        if (point) {
          $(point.cell).appendTo(tr).attr("rowspan", point.rowspan).attr("colspan", point.colspan);
        }
      }
    }
  }
  function _fnDraw(oSettings, ajaxComplete) {
    _fnStart(oSettings);
    var aPreDraw = _fnCallbackFire(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if (aPreDraw.indexOf(false) !== -1) {
      _fnProcessingDisplay(oSettings, false);
      return;
    }
    var anRows = [];
    var iRowCount = 0;
    var bServerSide = _fnDataSource(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    var columns = oSettings.aoColumns;
    var body = $(oSettings.nTBody);
    oSettings.bDrawing = true;
    if (oSettings.deferLoading) {
      oSettings.deferLoading = false;
      oSettings.iDraw++;
      _fnProcessingDisplay(oSettings, false);
    } else if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !ajaxComplete) {
      if (oSettings.iDraw === 0) {
        body.empty().append(_emptyRow(oSettings));
      }
      _fnAjaxUpdate(oSettings);
      return;
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        for (var i = 0; i < columns.length; i++) {
          var col = columns[i];
          var td = aoData.anCells[i];
          _addClass(td, _ext.type.className[col.sType]);
          _addClass(td, oSettings.oClasses.tbody.cell);
        }
        _fnCallbackFire(
          oSettings,
          "aoRowCallback",
          null,
          [nRow, aoData._aData, iRowCount, j, iDataIndex]
        );
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      anRows[0] = _emptyRow(oSettings);
    }
    _fnCallbackFire(oSettings, "aoHeaderCallback", "header", [
      $(oSettings.nTHead).children("tr")[0],
      _fnGetDataMaster(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    _fnCallbackFire(oSettings, "aoFooterCallback", "footer", [
      $(oSettings.nTFoot).children("tr")[0],
      _fnGetDataMaster(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    if (body[0].replaceChildren) {
      body[0].replaceChildren.apply(body[0], anRows);
    } else {
      body.children().detach();
      body.append($(anRows));
    }
    $(oSettings.nTableWrapper).toggleClass("dt-empty-footer", $("tr", oSettings.nTFoot).length === 0);
    _fnCallbackFire(oSettings, "aoDrawCallback", "draw", [oSettings], true);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw(settings, holdPosition, recompute) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (recompute === void 0 || recompute === true) {
      _fnColumnTypes(settings);
      if (sort) {
        _fnSort(settings);
      }
      if (filter) {
        _fnFilterComplete(settings, settings.oPreviousSearch);
      } else {
        settings.aiDisplay = settings.aiDisplayMaster.slice();
      }
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw(settings);
    settings._drawHold = false;
  }
  function _emptyRow(settings) {
    var oLang = settings.oLanguage;
    var zero = oLang.sZeroRecords;
    var dataSrc = _fnDataSource(settings);
    if (settings.iDraw < 1 && dataSrc === "ssp" || settings.iDraw <= 1 && dataSrc === "ajax") {
      zero = oLang.sLoadingRecords;
    } else if (oLang.sEmptyTable && settings.fnRecordsTotal() === 0) {
      zero = oLang.sEmptyTable;
    }
    return $("<tr/>").append($("<td />", {
      "colSpan": _fnVisbleColumns(settings),
      "class": settings.oClasses.empty.row
    }).html(zero))[0];
  }
  function _layoutItems(row, align, items) {
    if (Array.isArray(items)) {
      for (var i = 0; i < items.length; i++) {
        _layoutItems(row, align, items[i]);
      }
      return;
    }
    var rowCell = row[align];
    if ($.isPlainObject(items)) {
      if (items.features) {
        if (items.rowId) {
          row.id = items.rowId;
        }
        if (items.rowClass) {
          row.className = items.rowClass;
        }
        rowCell.id = items.id;
        rowCell.className = items.className;
        _layoutItems(row, align, items.features);
      } else {
        Object.keys(items).map(function(key) {
          rowCell.contents.push({
            feature: key,
            opts: items[key]
          });
        });
      }
    } else {
      rowCell.contents.push(items);
    }
  }
  function _layoutGetRow(rows, rowNum, align) {
    var row;
    for (var i = 0; i < rows.length; i++) {
      row = rows[i];
      if (row.rowNum === rowNum) {
        if (align === "full" && row.full || (align === "start" || align === "end") && (row.start || row.end)) {
          if (!row[align]) {
            row[align] = {
              contents: []
            };
          }
          return row;
        }
      }
    }
    row = {
      rowNum
    };
    row[align] = {
      contents: []
    };
    rows.push(row);
    return row;
  }
  function _layoutArray(settings, layout, side) {
    var rows = [];
    $.each(layout, function(pos, items) {
      if (items === null) {
        return;
      }
      var parts = pos.match(/^([a-z]+)([0-9]*)([A-Za-z]*)$/);
      var rowNum = parts[2] ? parts[2] * 1 : 0;
      var align = parts[3] ? parts[3].toLowerCase() : "full";
      if (parts[1] !== side) {
        return;
      }
      var row2 = _layoutGetRow(rows, rowNum, align);
      _layoutItems(row2, align, items);
    });
    rows.sort(function(a, b) {
      var order1 = a.rowNum;
      var order2 = b.rowNum;
      if (order1 === order2) {
        var ret = a.full && !b.full ? -1 : 1;
        return side === "bottom" ? ret * -1 : ret;
      }
      return order2 - order1;
    });
    if (side === "bottom") {
      rows.reverse();
    }
    for (var row = 0; row < rows.length; row++) {
      delete rows[row].rowNum;
      _layoutResolve(settings, rows[row]);
    }
    return rows;
  }
  function _layoutResolve(settings, row) {
    var getFeature = function(feature, opts) {
      if (!_ext.features[feature]) {
        _fnLog(settings, 0, "Unknown feature: " + feature);
      }
      return _ext.features[feature].apply(this, [settings, opts]);
    };
    var resolve = function(item) {
      if (!row[item]) {
        return;
      }
      var line = row[item].contents;
      for (var i = 0, ien = line.length; i < ien; i++) {
        if (!line[i]) {
          continue;
        } else if (typeof line[i] === "string") {
          line[i] = getFeature(line[i], null);
        } else if ($.isPlainObject(line[i])) {
          line[i] = getFeature(line[i].feature, line[i].opts);
        } else if (typeof line[i].node === "function") {
          line[i] = line[i].node(settings);
        } else if (typeof line[i] === "function") {
          var inst = line[i](settings);
          line[i] = typeof inst.node === "function" ? inst.node() : inst;
        }
      }
    };
    resolve("start");
    resolve("end");
    resolve("full");
  }
  function _fnAddOptionsHtml(settings) {
    var classes = settings.oClasses;
    var table = $(settings.nTable);
    var insert = $("<div/>").attr({
      id: settings.sTableId + "_wrapper",
      "class": classes.container
    }).insertBefore(table);
    settings.nTableWrapper = insert[0];
    if (settings.sDom) {
      _fnLayoutDom(settings, settings.sDom, insert);
    } else {
      var top = _layoutArray(settings, settings.layout, "top");
      var bottom = _layoutArray(settings, settings.layout, "bottom");
      var renderer = _fnRenderer(settings, "layout");
      top.forEach(function(item) {
        renderer(settings, insert, item);
      });
      renderer(settings, insert, {
        full: {
          table: true,
          contents: [_fnFeatureHtmlTable(settings)]
        }
      });
      bottom.forEach(function(item) {
        renderer(settings, insert, item);
      });
    }
    _processingHtml(settings);
  }
  function _fnLayoutDom(settings, dom, insert) {
    var parts = dom.match(/(".*?")|('.*?')|./g);
    var featureNode, option, newNode, next, attr;
    for (var i = 0; i < parts.length; i++) {
      featureNode = null;
      option = parts[i];
      if (option == "<") {
        newNode = $("<div/>");
        next = parts[i + 1];
        if (next[0] == "'" || next[0] == '"') {
          attr = next.replace(/['"]/g, "");
          var id = "", className;
          if (attr.indexOf(".") != -1) {
            var split = attr.split(".");
            id = split[0];
            className = split[1];
          } else if (attr[0] == "#") {
            id = attr;
          } else {
            className = attr;
          }
          newNode.attr("id", id.substring(1)).addClass(className);
          i++;
        }
        insert.append(newNode);
        insert = newNode;
      } else if (option == ">") {
        insert = insert.parent();
      } else if (option == "t") {
        featureNode = _fnFeatureHtmlTable(settings);
      } else {
        DataTable.ext.feature.forEach(function(feature) {
          if (option == feature.cFeature) {
            featureNode = feature.fnInit(settings);
          }
        });
      }
      if (featureNode) {
        insert.append(featureNode);
      }
    }
  }
  function _fnDetectHeader(settings, thead, write) {
    var columns = settings.aoColumns;
    var rows = $(thead).children("tr");
    var row, cell;
    var i, k, l, iLen, shifted, column, colspan, rowspan;
    var isHeader = thead && thead.nodeName.toLowerCase() === "thead";
    var layout = [];
    var unique;
    var shift = function(a, i2, j) {
      var k2 = a[i2];
      while (k2[j]) {
        j++;
      }
      return j;
    };
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      layout.push([]);
    }
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      row = rows[i];
      column = 0;
      cell = row.firstChild;
      while (cell) {
        if (cell.nodeName.toUpperCase() == "TD" || cell.nodeName.toUpperCase() == "TH") {
          var cols = [];
          colspan = cell.getAttribute("colspan") * 1;
          rowspan = cell.getAttribute("rowspan") * 1;
          colspan = !colspan || colspan === 0 || colspan === 1 ? 1 : colspan;
          rowspan = !rowspan || rowspan === 0 || rowspan === 1 ? 1 : rowspan;
          shifted = shift(layout, i, column);
          unique = colspan === 1 ? true : false;
          if (write) {
            if (unique) {
              _fnColumnOptions(settings, shifted, $(cell).data());
              var columnDef = columns[shifted];
              var width = cell.getAttribute("width") || null;
              var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
              if (t) {
                width = t[1];
              }
              columnDef.sWidthOrig = columnDef.sWidth || width;
              if (isHeader) {
                if (columnDef.sTitle !== null && !columnDef.autoTitle) {
                  cell.innerHTML = columnDef.sTitle;
                }
                if (!columnDef.sTitle && unique) {
                  columnDef.sTitle = _stripHtml(cell.innerHTML);
                  columnDef.autoTitle = true;
                }
              } else {
                if (columnDef.footer) {
                  cell.innerHTML = columnDef.footer;
                }
              }
              if (!columnDef.ariaTitle) {
                columnDef.ariaTitle = $(cell).attr("aria-label") || columnDef.sTitle;
              }
              if (columnDef.className) {
                $(cell).addClass(columnDef.className);
              }
            }
            if ($("span.dt-column-title", cell).length === 0) {
              $("<span>").addClass("dt-column-title").append(cell.childNodes).appendTo(cell);
            }
            if (isHeader && $("span.dt-column-order", cell).length === 0) {
              $("<span>").addClass("dt-column-order").appendTo(cell);
            }
          }
          for (l = 0; l < colspan; l++) {
            for (k = 0; k < rowspan; k++) {
              layout[i + k][shifted + l] = {
                cell,
                unique
              };
              layout[i + k].row = row;
            }
            cols.push(shifted + l);
          }
          cell.setAttribute("data-dt-column", _unique(cols).join(","));
        }
        cell = cell.nextSibling;
      }
    }
    return layout;
  }
  function _fnStart(oSettings) {
    var bServerSide = _fnDataSource(oSettings) == "ssp";
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
  }
  function _fnBuildAjax(oSettings, data, fn) {
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
      if (json === null || typeof status === "number" && status == 204) {
        json = {};
        _fnAjaxDataSrc(oSettings, json, []);
      }
      var error = json.error || json.sError;
      if (error) {
        _fnLog(oSettings, 0, error);
      }
      if (json.d && typeof json.d === "string") {
        try {
          json = JSON.parse(json.d);
        } catch (e) {
        }
      }
      oSettings.json = json;
      _fnCallbackFire(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR], true);
      fn(json);
    };
    if ($.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === "function" ? ajaxData(data, oSettings) : (
        // fn can manipulate data or return
        ajaxData
      );
      data = typeof ajaxData === "function" && newData ? newData : $.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {
      "url": typeof ajax === "string" ? ajax : "",
      "data": data,
      "success": callback,
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function(xhr, error) {
        var ret = _fnCallbackFire(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR], true);
        if (ret.indexOf(true) === -1) {
          if (error == "parsererror") {
            _fnLog(oSettings, 0, "Invalid JSON response", 1);
          } else if (xhr.readyState === 4) {
            _fnLog(oSettings, 0, "Ajax error", 7);
          }
        }
        _fnProcessingDisplay(oSettings, false);
      }
    };
    if ($.isPlainObject(ajax)) {
      $.extend(baseAjax, ajax);
    }
    oSettings.oAjaxData = data;
    _fnCallbackFire(oSettings, null, "preXhr", [oSettings, data, baseAjax], true);
    if (typeof ajax === "function") {
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else if (ajax.url === "") {
      var empty = {};
      DataTable.util.set(ajax.dataSrc)(empty, []);
      callback(empty);
    } else {
      oSettings.jqXHR = $.ajax(baseAjax);
    }
    if (ajaxData) {
      ajax.data = ajaxData;
    }
  }
  function _fnAjaxUpdate(settings) {
    settings.iDraw++;
    _fnProcessingDisplay(settings, true);
    _fnBuildAjax(
      settings,
      _fnAjaxParameters(settings),
      function(json) {
        _fnAjaxUpdateDraw(settings, json);
      }
    );
  }
  function _fnAjaxParameters(settings) {
    var columns = settings.aoColumns, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, colData = function(idx, prop) {
      return typeof columns[idx][prop] === "function" ? "function" : columns[idx][prop];
    };
    return {
      draw: settings.iDraw,
      columns: columns.map(function(column, i) {
        return {
          data: colData(i, "mData"),
          name: column.sName,
          searchable: column.bSearchable,
          orderable: column.bSortable,
          search: {
            value: preColSearch[i].search,
            regex: preColSearch[i].regex,
            fixed: Object.keys(column.searchFixed).map(function(name) {
              return {
                name,
                term: column.searchFixed[name].toString()
              };
            })
          }
        };
      }),
      order: _fnSortFlatten(settings).map(function(val) {
        return {
          column: val.col,
          dir: val.dir,
          name: colData(val.col, "sName")
        };
      }),
      start: settings._iDisplayStart,
      length: features.bPaginate ? settings._iDisplayLength : -1,
      search: {
        value: preSearch.search,
        regex: preSearch.regex,
        fixed: Object.keys(settings.searchFixed).map(function(name) {
          return {
            name,
            term: settings.searchFixed[name].toString()
          };
        })
      }
    };
  }
  function _fnAjaxUpdateDraw(settings, json) {
    var data = _fnAjaxDataSrc(settings, json);
    var draw = _fnAjaxDataSrcParam(settings, "draw", json);
    var recordsTotal = _fnAjaxDataSrcParam(settings, "recordsTotal", json);
    var recordsFiltered = _fnAjaxDataSrcParam(settings, "recordsFiltered", json);
    if (draw !== void 0) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    if (!data) {
      data = [];
    }
    _fnClearTable(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData(settings, data[i]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnColumnTypes(settings);
    _fnDraw(settings, true);
    _fnInitComplete(settings);
    _fnProcessingDisplay(settings, false);
  }
  function _fnAjaxDataSrc(settings, json, write) {
    var dataProp = "data";
    if ($.isPlainObject(settings.ajax) && settings.ajax.dataSrc !== void 0) {
      var dataSrc = settings.ajax.dataSrc;
      if (typeof dataSrc === "string" || typeof dataSrc === "function") {
        dataProp = dataSrc;
      } else if (dataSrc.data !== void 0) {
        dataProp = dataSrc.data;
      }
    }
    if (!write) {
      if (dataProp === "data") {
        return json.aaData || json[dataProp];
      }
      return dataProp !== "" ? _fnGetObjectDataFn(dataProp)(json) : json;
    }
    _fnSetObjectDataFn(dataProp)(json, write);
  }
  function _fnAjaxDataSrcParam(settings, param, json) {
    var dataSrc = $.isPlainObject(settings.ajax) ? settings.ajax.dataSrc : null;
    if (dataSrc && dataSrc[param]) {
      return _fnGetObjectDataFn(dataSrc[param])(json);
    }
    var old = "";
    if (param === "draw") {
      old = "sEcho";
    } else if (param === "recordsTotal") {
      old = "iTotalRecords";
    } else if (param === "recordsFiltered") {
      old = "iTotalDisplayRecords";
    }
    return json[old] !== void 0 ? json[old] : json[param];
  }
  function _fnFilterComplete(settings, input) {
    var columnsSearch = settings.aoPreSearchCols;
    if (_fnDataSource(settings) != "ssp") {
      _fnFilterData(settings);
      settings.aiDisplay = settings.aiDisplayMaster.slice();
      _fnFilter(settings.aiDisplay, settings, input.search, input);
      $.each(settings.searchFixed, function(name, term) {
        _fnFilter(settings.aiDisplay, settings, term, {});
      });
      for (var i = 0; i < columnsSearch.length; i++) {
        var col = columnsSearch[i];
        _fnFilter(
          settings.aiDisplay,
          settings,
          col.search,
          col,
          i
        );
        $.each(settings.aoColumns[i].searchFixed, function(name, term) {
          _fnFilter(settings.aiDisplay, settings, term, {}, i);
        });
      }
      _fnFilterCustom(settings);
    }
    settings.bFiltered = true;
    _fnCallbackFire(settings, null, "search", [settings]);
  }
  function _fnFilterCustom(settings) {
    var filters = DataTable.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = [];
      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];
        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      displayRows.push.apply(displayRows, rows);
    }
  }
  function _fnFilter(searchRows, settings, input, options, column) {
    if (input === "") {
      return;
    }
    var i = 0;
    var matched = [];
    var searchFunc = typeof input === "function" ? input : null;
    var rpSearch = input instanceof RegExp ? input : searchFunc ? null : _fnFilterCreateSearch(input, options);
    for (i = 0; i < searchRows.length; i++) {
      var row = settings.aoData[searchRows[i]];
      var data = column === void 0 ? row._sFilterRow : row._aFilterData[column];
      if (searchFunc && searchFunc(data, row._aData, searchRows[i], column) || rpSearch && rpSearch.test(data)) {
        matched.push(searchRows[i]);
      }
    }
    searchRows.length = matched.length;
    for (i = 0; i < matched.length; i++) {
      searchRows[i] = matched[i];
    }
  }
  function _fnFilterCreateSearch(search, inOpts) {
    var not = [];
    var options = $.extend({}, {
      boundary: false,
      caseInsensitive: true,
      exact: false,
      regex: false,
      smart: true
    }, inOpts);
    if (typeof search !== "string") {
      search = search.toString();
    }
    search = _normalize(search);
    if (options.exact) {
      return new RegExp(
        "^" + _fnEscapeRegex(search) + "$",
        options.caseInsensitive ? "i" : ""
      );
    }
    search = options.regex ? search : _fnEscapeRegex(search);
    if (options.smart) {
      var parts = search.match(/!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""];
      var a = parts.map(function(word) {
        var negative = false;
        var m2;
        if (word.charAt(0) === "!") {
          negative = true;
          word = word.substring(1);
        }
        if (word.charAt(0) === '"') {
          m2 = word.match(/^"(.*)"$/);
          word = m2 ? m2[1] : word;
        } else if (word.charAt(0) === "\u201C") {
          m2 = word.match(/^\u201C(.*)\u201D$/);
          word = m2 ? m2[1] : word;
        }
        if (negative) {
          if (word.length > 1) {
            not.push("(?!" + word + ")");
          }
          word = "";
        }
        return word.replace(/"/g, "");
      });
      var match = not.length ? not.join("") : "";
      var boundary = options.boundary ? "\\b" : "";
      search = "^(?=.*?" + boundary + a.join(")(?=.*?" + boundary) + ")(" + match + ".)*$";
    }
    return new RegExp(search, options.caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex = DataTable.util.escapeRegex;
  var __filter_div = $("<div>")[0];
  var __filter_div_textContent = __filter_div.textContent !== void 0;
  function _fnFilterData(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var column;
    var j, jen, filterData, cellData, row;
    var wasInvalidated = false;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aFilterData) {
        filterData = [];
        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];
          if (column.bSearchable) {
            cellData = _fnGetCellData(settings, rowIdx, j, "filter");
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div.innerHTML = cellData;
            cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnInitialise(settings) {
    var i;
    var init2 = settings.oInit;
    var deferLoading = settings.deferLoading;
    var dataSrc = _fnDataSource(settings);
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise(settings);
      }, 200);
      return;
    }
    _fnBuildHead(settings, "header");
    _fnBuildHead(settings, "footer");
    _fnLoadState(settings, init2, function() {
      _fnDrawHead(settings, settings.aoHeader);
      _fnDrawHead(settings, settings.aoFooter);
      var iAjaxStart = settings.iInitDisplayStart;
      if (init2.aaData) {
        for (i = 0; i < init2.aaData.length; i++) {
          _fnAddData(settings, init2.aaData[i]);
        }
      } else if (deferLoading || dataSrc == "dom") {
        _fnAddTr(settings, $(settings.nTBody).children("tr"));
      }
      settings.aiDisplay = settings.aiDisplayMaster.slice();
      _fnAddOptionsHtml(settings);
      _fnSortInit(settings);
      _colGroup(settings);
      _fnProcessingDisplay(settings, true);
      _fnCallbackFire(settings, null, "preInit", [settings], true);
      _fnReDraw(settings);
      if (dataSrc != "ssp" || deferLoading) {
        if (dataSrc == "ajax") {
          _fnBuildAjax(settings, {}, function(json) {
            var aData = _fnAjaxDataSrc(settings, json);
            for (i = 0; i < aData.length; i++) {
              _fnAddData(settings, aData[i]);
            }
            settings.iInitDisplayStart = iAjaxStart;
            _fnReDraw(settings);
            _fnProcessingDisplay(settings, false);
            _fnInitComplete(settings);
          }, settings);
        } else {
          _fnInitComplete(settings);
          _fnProcessingDisplay(settings, false);
        }
      }
    });
  }
  function _fnInitComplete(settings) {
    if (settings._bInitComplete) {
      return;
    }
    var args = [settings, settings.json];
    settings._bInitComplete = true;
    _fnAdjustColumnSizing(settings);
    _fnCallbackFire(settings, null, "plugin-init", args, true);
    _fnCallbackFire(settings, "aoInitComplete", "init", args, true);
  }
  function _fnLengthChange(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow(settings);
    _fnCallbackFire(settings, null, "length", [settings, len]);
  }
  function _fnPageChange(settings, action, redraw) {
    var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;
      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;
      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else if (action === "ellipsis") {
      return;
    } else {
      _fnLog(settings, 0, "Unknown paging action: " + action, 5);
    }
    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;
    _fnCallbackFire(settings, null, changed ? "page" : "page-nc", [settings]);
    if (changed && redraw) {
      _fnDraw(settings);
    }
    return changed;
  }
  function _processingHtml(settings) {
    var table = settings.nTable;
    var scrolling = settings.oScroll.sX !== "" || settings.oScroll.sY !== "";
    if (settings.oFeatures.bProcessing) {
      var n = $("<div/>", {
        "id": settings.sTableId + "_processing",
        "class": settings.oClasses.processing.container,
        "role": "status"
      }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>");
      if (scrolling) {
        n.prependTo($("div.dt-scroll", settings.nTableWrapper));
      } else {
        n.insertBefore(table);
      }
      $(table).on("processing.dt.DT", function(e, s, show) {
        n.css("display", show ? "block" : "none");
      });
    }
  }
  function _fnProcessingDisplay(settings, show) {
    if (settings.bDrawing && show === false) {
      return;
    }
    _fnCallbackFire(settings, null, "processing", [settings, show]);
  }
  function _fnProcessingRun(settings, enable, run) {
    if (!enable) {
      run();
    } else {
      _fnProcessingDisplay(settings, true);
      setTimeout(function() {
        run();
        _fnProcessingDisplay(settings, false);
      }, 0);
    }
  }
  function _fnFeatureHtmlTable(settings) {
    var table = $(settings.nTable);
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses.scrolling;
    var caption = settings.captionNode;
    var captionSide = caption ? caption._captionSide : null;
    var headerClone = $(table[0].cloneNode(false));
    var footerClone = $(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size = function(s) {
      return !s ? null : _fnStringToCss(s);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $(_div, { "class": classes.container }).append(
      $(_div, { "class": classes.header.self }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: scrollX ? size(scrollX) : "100%"
      }).append(
        $(_div, { "class": classes.header.inner }).css({
          "box-sizing": "content-box",
          width: scroll.sXInner || "100%"
        }).append(
          headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
            table.children("thead")
          )
        )
      )
    ).append(
      $(_div, { "class": classes.body }).css({
        position: "relative",
        overflow: "auto",
        width: size(scrollX)
      }).append(table)
    );
    if (footer) {
      scroller.append(
        $(_div, { "class": classes.footer.self }).css({
          overflow: "hidden",
          border: 0,
          width: scrollX ? size(scrollX) : "100%"
        }).append(
          $(_div, { "class": classes.footer.inner }).append(
            footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
              table.children("tfoot")
            )
          )
        )
      );
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    $(scrollBody).on("scroll.DT", function() {
      var scrollLeft = this.scrollLeft;
      scrollHead.scrollLeft = scrollLeft;
      if (footer) {
        scrollFoot.scrollLeft = scrollLeft;
      }
    });
    $("th, td", scrollHead).on("focus", function() {
      var scrollLeft = scrollHead.scrollLeft;
      scrollBody.scrollLeft = scrollLeft;
      if (footer) {
        scrollBody.scrollLeft = scrollLeft;
      }
    });
    $(scrollBody).css("max-height", scrollY);
    if (!scroll.bCollapse) {
      $(scrollBody).css("height", scrollY);
    }
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push(_fnScrollDraw);
    return scroller[0];
  }
  function _fnScrollDraw(settings) {
    var scroll = settings.oScroll, barWidth = scroll.iBarWidth, divHeader = $(settings.nScrollHead), divHeaderInner = divHeader.children("div"), divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $(divBodyEl), divFooter = $(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $(settings.nTHead), table = $(settings.nTable), footer = settings.nTFoot && $("th, td", settings.nTFoot).length ? $(settings.nTFoot) : null, browser = settings.oBrowser, headerCopy, footerCopy;
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    headerCopy = header.clone().prependTo(table);
    headerCopy.find("th, td").removeAttr("tabindex");
    headerCopy.find("[id]").removeAttr("id");
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerCopy.find("[id]").removeAttr("id");
    }
    if (settings.aiDisplay.length) {
      var firstTr = null;
      for (i = 0; i < settings.aiDisplay.length; i++) {
        var idx = settings.aiDisplay[i];
        var tr = settings.aoData[idx].nTr;
        if (tr) {
          firstTr = tr;
          break;
        }
      }
      if (firstTr) {
        var colSizes = $(firstTr).children("th, td").map(function(vis) {
          return {
            idx: _fnVisibleToColumnIndex(settings, vis),
            width: $(this).outerWidth()
          };
        });
        for (var i = 0; i < colSizes.length; i++) {
          var colEl = settings.aoColumns[colSizes[i].idx].colEl[0];
          var colWidth = colEl.style.width.replace("px", "");
          if (colWidth !== colSizes[i].width) {
            colEl.style.width = colSizes[i].width + "px";
          }
        }
      }
    }
    divHeaderTable.find("colgroup").remove();
    divHeaderTable.append(settings.colgroup.clone());
    if (footer) {
      divFooterTable.find("colgroup").remove();
      divFooterTable.append(settings.colgroup.clone());
    }
    $("th, td", headerCopy).each(function() {
      $(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
    });
    if (footer) {
      $("th, td", footerCopy).each(function() {
        $(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
      });
    }
    var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var paddingSide = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    var outerWidth = table.outerWidth();
    divHeaderTable.css("width", _fnStringToCss(outerWidth));
    divHeaderInner.css("width", _fnStringToCss(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    if (footer) {
      divFooterTable.css("width", _fnStringToCss(outerWidth));
      divFooterInner.css("width", _fnStringToCss(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    }
    table.children("colgroup").prependTo(table);
    divBody.trigger("scroll");
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnCalculateColumnWidths(settings) {
    if (!settings.oFeatures.bAutoWidth) {
      return;
    }
    var table = settings.nTable, columns = settings.aoColumns, scroll = settings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, visibleColumns = _fnGetColumns(settings, "bVisible"), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, i, column, columnIdx;
    var styleWidth = table.style.width;
    if (!styleWidth && !tableWidthAttr) {
      table.style.width = "100%";
      styleWidth = "100%";
    }
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    _fnCallbackFire(
      settings,
      null,
      "column-calc",
      { visible: visibleColumns },
      false
    );
    var tmpTable = $(table.cloneNode()).css("visibility", "hidden").removeAttr("id");
    tmpTable.append("<tbody>");
    var tr = $("<tr/>").appendTo(tmpTable.find("tbody"));
    tmpTable.append($(settings.nTHead).clone()).append($(settings.nTFoot).clone());
    tmpTable.find("tfoot th, tfoot td").css("width", "");
    tmpTable.find("thead th, thead td").each(function() {
      var width = _fnColumnsSumWidth(settings, this, true, false);
      if (width) {
        this.style.width = width;
        if (scrollX) {
          $(this).append($("<div/>").css({
            width,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } else {
        this.style.width = "";
      }
    });
    for (i = 0; i < visibleColumns.length; i++) {
      columnIdx = visibleColumns[i];
      column = columns[columnIdx];
      var longest = _fnGetMaxLenString(settings, columnIdx);
      var autoClass = _ext.type.className[column.sType];
      var text = longest + column.sContentPadding;
      var insert = longest.indexOf("<") === -1 ? document.createTextNode(text) : text;
      $("<td/>").addClass(autoClass).addClass(column.sClass).append(insert).appendTo(tr);
    }
    $("[name]", tmpTable).removeAttr("name");
    var holder = $("<div/>").css(
      scrollX || scrollY ? {
        position: "absolute",
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: "hidden"
      } : {}
    ).append(tmpTable).appendTo(tableContainer);
    if (scrollX && scrollXInner) {
      tmpTable.width(scrollXInner);
    } else if (scrollX) {
      tmpTable.css("width", "auto");
      tmpTable.removeAttr("width");
      if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
        tmpTable.width(tableContainer.clientWidth);
      }
    } else if (scrollY) {
      tmpTable.width(tableContainer.clientWidth);
    } else if (tableWidthAttr) {
      tmpTable.width(tableWidthAttr);
    }
    var total = 0;
    var bodyCells = tmpTable.find("tbody tr").eq(0).children();
    for (i = 0; i < visibleColumns.length; i++) {
      var bounding = bodyCells[i].getBoundingClientRect().width;
      total += bounding;
      columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding);
    }
    table.style.width = _fnStringToCss(total);
    holder.remove();
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !settings._reszEvt) {
      var bindResize = function() {
        $(window).on("resize.DT-" + settings.sInstance, DataTable.util.throttle(function() {
          if (!settings.bDestroying) {
            _fnAdjustColumnSizing(settings);
          }
        }));
      };
      bindResize();
      settings._reszEvt = true;
    }
  }
  function _fnGetMaxLenString(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    if (!column.maxLenString) {
      var s, max = "", maxLen = -1;
      for (var i = 0, ien = settings.aiDisplayMaster.length; i < ien; i++) {
        var rowIdx = settings.aiDisplayMaster[i];
        var data = _fnGetRowDisplay(settings, rowIdx)[colIdx];
        var cellString = data && typeof data === "object" && data.nodeType ? data.innerHTML : data + "";
        cellString = cellString.replace(/id=".*?"/g, "").replace(/name=".*?"/g, "");
        s = _stripHtml(cellString).replace(/&nbsp;/g, " ");
        if (s.length > maxLen) {
          max = cellString;
          maxLen = s.length;
        }
      }
      column.maxLenString = max;
    }
    return column.maxLenString;
  }
  function _fnStringToCss(s) {
    if (s === null) {
      return "0px";
    }
    if (typeof s == "number") {
      return s < 0 ? "0px" : s + "px";
    }
    return s.match(/\d$/) ? s + "px" : s;
  }
  function _colGroup(settings) {
    var cols = settings.aoColumns;
    settings.colgroup.empty();
    for (i = 0; i < cols.length; i++) {
      if (cols[i].bVisible) {
        settings.colgroup.append(cols[i].colEl);
      }
    }
  }
  function _fnSortInit(settings) {
    var target = settings.nTHead;
    var headerRows = target.querySelectorAll("tr");
    var legacyTop = settings.bSortCellsTop;
    var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
    if (legacyTop === true) {
      target = headerRows[0];
    } else if (legacyTop === false) {
      target = headerRows[headerRows.length - 1];
    }
    _fnSortAttachListener(
      settings,
      target,
      target === settings.nTHead ? "tr" + notSelector + " th" + notSelector + ", tr" + notSelector + " td" + notSelector : "th" + notSelector + ", td" + notSelector
    );
    var order = [];
    _fnSortResolve(settings, order, settings.aaSorting);
    settings.aaSorting = order;
  }
  function _fnSortAttachListener(settings, node, selector, column, callback) {
    _fnBindAction(node, selector, function(e) {
      var run = false;
      var columns = column === void 0 ? _fnColumnsFromHeader(e.target) : [column];
      if (columns.length) {
        for (var i = 0, ien = columns.length; i < ien; i++) {
          var ret = _fnSortAdd(settings, columns[i], i, e.shiftKey);
          if (ret !== false) {
            run = true;
          }
          if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === "") {
            break;
          }
        }
        if (run) {
          _fnProcessingRun(settings, true, function() {
            _fnSort(settings);
            _fnSortDisplay(settings, settings.aiDisplay);
            _fnReDraw(settings, false, false);
            if (callback) {
              callback();
            }
          });
        }
      }
    });
  }
  function _fnSortDisplay(settings, display) {
    if (display.length < 2) {
      return;
    }
    var master = settings.aiDisplayMaster;
    var masterMap = {};
    var map2 = {};
    var i;
    for (i = 0; i < master.length; i++) {
      masterMap[master[i]] = i;
    }
    for (i = 0; i < display.length; i++) {
      map2[display[i]] = masterMap[display[i]];
    }
    display.sort(function(a, b) {
      return map2[a] - map2[b];
    });
  }
  function _fnSortResolve(settings, nestedSort, sort) {
    var push = function(a) {
      if ($.isPlainObject(a)) {
        if (a.idx !== void 0) {
          nestedSort.push([a.idx, a.dir]);
        } else if (a.name) {
          var cols = _pluck(settings.aoColumns, "sName");
          var idx = cols.indexOf(a.name);
          if (idx !== -1) {
            nestedSort.push([idx, a.dir]);
          }
        }
      } else {
        nestedSort.push(a);
      }
    };
    if ($.isPlainObject(sort)) {
      push(sort);
    } else if (sort.length && typeof sort[0] === "number") {
      push(sort);
    } else if (sort.length) {
      for (var z = 0; z < sort.length; z++) {
        push(sort[z]);
      }
    }
  }
  function _fnSortFlatten(settings) {
    var i, k, kLen, aSort = [], extSort = DataTable.ext.type.order, aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $.isPlainObject(fixed), nestedSort = [];
    if (!settings.oFeatures.bSort) {
      return aSort;
    }
    if (Array.isArray(fixed)) {
      _fnSortResolve(settings, nestedSort, fixed);
    }
    if (fixedObj && fixed.pre) {
      _fnSortResolve(settings, nestedSort, fixed.pre);
    }
    _fnSortResolve(settings, nestedSort, settings.aaSorting);
    if (fixedObj && fixed.post) {
      _fnSortResolve(settings, nestedSort, fixed.post);
    }
    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      if (aoColumns[srcCol]) {
        aDataSort = aoColumns[srcCol].aDataSort;
        for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
          iCol = aDataSort[k];
          sType = aoColumns[iCol].sType || "string";
          if (nestedSort[i]._idx === void 0) {
            nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
          }
          if (nestedSort[i][1]) {
            aSort.push({
              src: srcCol,
              col: iCol,
              dir: nestedSort[i][1],
              index: nestedSort[i]._idx,
              type: sType,
              formatter: extSort[sType + "-pre"],
              sorter: extSort[sType + "-" + nestedSort[i][1]]
            });
          }
        }
      }
    }
    return aSort;
  }
  function _fnSort(oSettings, col, dir) {
    var i, ien, iLen, aiOrig = [], extSort = DataTable.ext.type.order, aoData = oSettings.aoData, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    if (col !== void 0) {
      var srcCol = oSettings.aoColumns[col];
      aSort = [{
        src: col,
        col,
        dir,
        index: 0,
        type: srcCol.sType,
        formatter: extSort[srcCol.sType + "-pre"],
        sorter: extSort[srcCol.sType + "-" + dir]
      }];
      displayMaster = displayMaster.slice();
    } else {
      aSort = _fnSortFlatten(oSettings);
    }
    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i];
      _fnSortData(oSettings, sortCol.col);
    }
    if (_fnDataSource(oSettings) != "ssp" && aSort.length !== 0) {
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[i] = i;
      }
      if (aSort.length && aSort[0].dir === "desc" && oSettings.orderDescReverse) {
        aiOrig.reverse();
      }
      displayMaster.sort(function(a, b) {
        var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
        for (k = 0; k < len; k++) {
          sort = aSort[k];
          x = dataA[sort.col];
          y = dataB[sort.col];
          if (sort.sorter) {
            test = sort.sorter(x, y);
            if (test !== 0) {
              return test;
            }
          } else {
            test = x < y ? -1 : x > y ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
        }
        x = aiOrig[a];
        y = aiOrig[b];
        return x < y ? -1 : x > y ? 1 : 0;
      });
    } else if (aSort.length === 0) {
      displayMaster.sort(function(x, y) {
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    if (col === void 0) {
      oSettings.bSorted = true;
      oSettings.sortDetails = aSort;
      _fnCallbackFire(oSettings, null, "order", [oSettings, aSort]);
    }
    return displayMaster;
  }
  function _fnSortAdd(settings, colIdx, addIndex, shift) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a, overflow) {
      var idx = a._idx;
      if (idx === void 0) {
        idx = asSorting.indexOf(a[1]);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (!col.bSortable) {
      return false;
    }
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if ((shift || addIndex) && settings.oFeatures.bSortMulti) {
      var sortIdx = _pluck(sorting, "0").indexOf(colIdx);
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else if (shift) {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      } else {
        sorting.push([colIdx, sorting[0][1], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    }
  }
  function _fnSortingClasses(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.order.position;
    var sort = _fnSortFlatten(settings);
    var features = settings.oFeatures;
    var i, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src;
        $(_pluck(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      }
      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $(_pluck(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    var customSort = DataTable.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(
        settings.oInstance,
        settings,
        colIdx,
        _fnColumnIndexToVisible(settings, colIdx)
      );
    }
    var row, cellData;
    var formatter = DataTable.ext.type.order[column.sType + "-pre"];
    var data = settings.aoData;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[colIdx] || customSort) {
        cellData = customSort ? customData[rowIdx] : (
          // If there was a custom sort function, use data from there
          _fnGetCellData(settings, rowIdx, colIdx, "sort")
        );
        row._aSortData[colIdx] = formatter ? formatter(cellData, settings) : cellData;
      }
    }
  }
  function _fnSaveState(settings) {
    if (settings._bLoadingState) {
      return;
    }
    var state = {
      time: +/* @__PURE__ */ new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $.extend(true, [], settings.aaSorting),
      search: $.extend({}, settings.oPreviousSearch),
      columns: settings.aoColumns.map(function(col, i) {
        return {
          visible: col.bVisible,
          search: $.extend({}, settings.aoPreSearchCols[i])
        };
      })
    };
    settings.oSavedState = state;
    _fnCallbackFire(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
  }
  function _fnLoadState(settings, init2, callback) {
    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }
    var loaded = function(state2) {
      _fnImplementState(settings, state2, callback);
    };
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
    if (state !== void 0) {
      _fnImplementState(settings, state, callback);
    }
    return true;
  }
  function _fnImplementState(settings, s, callback) {
    var i, ien;
    var columns = settings.aoColumns;
    settings._bLoadingState = true;
    var api = settings._bInitComplete ? new DataTable.Api(settings) : null;
    if (!s || !s.time) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && s.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var abStateLoad = _fnCallbackFire(settings, "aoStateLoadParams", "stateLoadParams", [settings, s]);
    if (abStateLoad.indexOf(false) !== -1) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    if (s.columns && columns.length !== s.columns.length) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    settings.oLoadedState = $.extend(true, {}, s);
    _fnCallbackFire(settings, null, "stateLoadInit", [settings, s], true);
    if (s.length !== void 0) {
      if (api) {
        api.page.len(s.length);
      } else {
        settings._iDisplayLength = s.length;
      }
    }
    if (s.start !== void 0) {
      if (api === null) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      } else {
        _fnPageChange(settings, s.start / settings._iDisplayLength);
      }
    }
    if (s.order !== void 0) {
      settings.aaSorting = [];
      $.each(s.order, function(i2, col2) {
        settings.aaSorting.push(
          col2[0] >= columns.length ? [0, col2[1]] : col2
        );
      });
    }
    if (s.search !== void 0) {
      $.extend(settings.oPreviousSearch, s.search);
    }
    if (s.columns) {
      for (i = 0, ien = s.columns.length; i < ien; i++) {
        var col = s.columns[i];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i).visible(col.visible, false);
          } else {
            columns[i].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $.extend(settings.aoPreSearchCols[i], col.search);
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
    settings._bLoadingState = false;
    _fnCallbackFire(settings, "aoStateLoaded", "stateLoaded", [settings, s]);
    callback();
  }
  function _fnLog(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire(settings, null, "dt-error", [settings, tn, msg], true);
      }
      if (type == "alert") {
        alert(msg);
      } else if (type == "throw") {
        throw new Error(msg);
      } else if (typeof type == "function") {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  function _fnMap(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $.each(name, function(i, val) {
        if (Array.isArray(val)) {
          _fnMap(ret, src, val[0], val[1]);
        } else {
          _fnMap(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === void 0) {
      mappedName = name;
    }
    if (src[name] !== void 0) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, prop)) {
        val = extender[prop];
        if ($.isPlainObject(val)) {
          if (!$.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $.extend(true, out[prop], val);
        } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }
    return out;
  }
  function _fnBindAction(n, selector, fn) {
    $(n).on("click.DT", selector, function(e) {
      fn(e);
    }).on("keypress.DT", selector, function(e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on("selectstart.DT", selector, function() {
      return false;
    });
  }
  function _fnCallbackReg(settings, store, fn) {
    if (fn) {
      settings[store].push(fn);
    }
  }
  function _fnCallbackFire(settings, callbackArr, eventName, args, bubbles) {
    var ret = [];
    if (callbackArr) {
      ret = settings[callbackArr].slice().reverse().map(function(val) {
        return val.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e = $.Event(eventName + ".dt");
      var table = $(settings.nTable);
      e.dt = settings.api;
      table[bubbles ? "trigger" : "triggerHandler"](e, args);
      if (bubbles && table.parents("body").length === 0) {
        $("body").trigger(e, args);
      }
      ret.push(e.result);
    }
    return ret;
  }
  function _fnLengthOverflow(settings) {
    var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start >= end) {
      start = end - len;
    }
    start -= start % len;
    if (len === -1 || start < 0) {
      start = 0;
    }
    settings._iDisplayStart = start;
  }
  function _fnRenderer(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable.ext.renderer[type];
    if ($.isPlainObject(renderer) && renderer[type]) {
      return host[renderer[type]] || host._;
    } else if (typeof renderer === "string") {
      return host[renderer] || host._;
    }
    return host._;
  }
  function _fnDataSource(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else if (settings.ajax) {
      return "ajax";
    }
    return "dom";
  }
  function _fnMacros(settings, str, entries) {
    var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), max = settings.fnRecordsTotal(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, max)).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len))).replace(/_ENTRIES_/g, settings.api.i18n("entries", "", entries)).replace(/_ENTRIES-MAX_/g, settings.api.i18n("entries", "", max)).replace(/_ENTRIES-TOTAL_/g, settings.api.i18n("entries", "", vis));
  }
  var __apiStruct = [];
  var __arrayProto = Array.prototype;
  var _toSettings = function(mixed) {
    var idx, jq;
    var settings = DataTable.settings;
    var tables = _pluck(settings, "nTable");
    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oFeatures) {
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
      idx = tables.indexOf(mixed);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === "function") {
      return mixed.settings().toArray();
    } else if (typeof mixed === "string") {
      jq = $(mixed).get();
    } else if (mixed instanceof $) {
      jq = mixed.get();
    }
    if (jq) {
      return settings.filter(function(v, idx2) {
        return jq.includes(tables[idx2]);
      });
    }
  };
  _Api = function(context, data) {
    if (!(this instanceof _Api)) {
      return new _Api(context, data);
    }
    var i;
    var settings = [];
    var ctxSettings = function(o) {
      var a = _toSettings(o);
      if (a) {
        settings.push.apply(settings, a);
      }
    };
    if (Array.isArray(context)) {
      for (i = 0; i < context.length; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = settings.length > 1 ? _unique(settings) : settings;
    if (data) {
      if (data.length < 1e4) {
        this.push.apply(this, data);
      } else {
        for (i = 0; i < data.length; i++) {
          this.push(data[i]);
        }
      }
    }
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
    _Api.extend(this, this, __apiStruct);
  };
  DataTable.Api = _Api;
  $.extend(_Api.prototype, {
    any: function() {
      return this.count() !== 0;
    },
    context: [],
    // array of table settings objects
    count: function() {
      return this.flatten().length;
    },
    each: function(fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }
      return this;
    },
    eq: function(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null;
    },
    filter: function(fn) {
      var a = __arrayProto.filter.call(this, fn, this);
      return new _Api(this.context, a);
    },
    flatten: function() {
      var a = [];
      return new _Api(this.context, a.concat.apply(a, this.toArray()));
    },
    get: function(idx) {
      return this[idx];
    },
    join: __arrayProto.join,
    includes: function(find) {
      return this.indexOf(find) === -1 ? false : true;
    },
    indexOf: __arrayProto.indexOf,
    iterator: function(flatten, type, fn, alwaysNew) {
      var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
      if (typeof flatten === "string") {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }
      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api(context[i]);
        if (type === "table") {
          ret = fn.call(apiInst, context[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "columns" || type === "rows") {
          ret = fn.call(apiInst, context[i], this[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "every" || type === "column" || type === "column-rows" || type === "row" || type === "cell") {
          items = this[i];
          if (type === "column-rows") {
            rows = _selector_row_indexes(context[i], selector.opts);
          }
          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];
            if (type === "cell") {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }
            if (ret !== void 0) {
              a.push(ret);
            }
          }
        }
      }
      if (a.length || alwaysNew) {
        var api = new _Api(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
    lastIndexOf: __arrayProto.lastIndexOf,
    length: 0,
    map: function(fn) {
      var a = __arrayProto.map.call(this, fn, this);
      return new _Api(this.context, a);
    },
    pluck: function(prop) {
      var fn = DataTable.util.get(prop);
      return this.map(function(el) {
        return fn(el);
      });
    },
    pop: __arrayProto.pop,
    push: __arrayProto.push,
    reduce: __arrayProto.reduce,
    reduceRight: __arrayProto.reduceRight,
    reverse: __arrayProto.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto.shift,
    slice: function() {
      return new _Api(this.context, this);
    },
    sort: __arrayProto.sort,
    splice: __arrayProto.splice,
    toArray: function() {
      return __arrayProto.slice.call(this);
    },
    to$: function() {
      return $(this);
    },
    toJQuery: function() {
      return $(this);
    },
    unique: function() {
      return new _Api(this.context, _unique(this.toArray()));
    },
    unshift: __arrayProto.unshift
  });
  function _api_scope(scope, fn, struc) {
    return function() {
      var ret = fn.apply(scope || this, arguments);
      _Api.extend(ret, ret, struc.methodExt);
      return ret;
    };
  }
  function _api_find(src, name) {
    for (var i = 0, ien = src.length; i < ien; i++) {
      if (src[i].name === name) {
        return src[i];
      }
    }
    return null;
  }
  window.__apiStruct = __apiStruct;
  _Api.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api) && !obj.__dt_wrapper) {
      return;
    }
    var i, ien, struct;
    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i];
      if (struct.name === "__proto__") {
        continue;
      }
      obj[struct.name] = struct.type === "function" ? _api_scope(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api.register = _api_register = function(name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api.register(name[j], val);
      }
      return;
    }
    var i, ien, heir = name.split("."), struct = __apiStruct, key, method;
    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf("()") !== -1;
      key = method ? heir[i].replace("()", "") : heir[i];
      var src = _api_find(struct, key);
      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: "object"
        };
        struct.push(src);
      }
      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === "function" ? "function" : $.isPlainObject(val) ? "object" : "other";
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api.registerPlural = _api_registerPlural = function(pluralName, singularName, val) {
    _Api.register(pluralName, val);
    _Api.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else if (ret instanceof _Api) {
        return ret.length ? Array.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : (
          // Array results are 'enhanced'
          ret[0]
        ) : void 0;
      }
      return ret;
    });
  };
  var __table_selector = function(selector, a) {
    if (Array.isArray(selector)) {
      var result = [];
      selector.forEach(function(sel) {
        var inner = __table_selector(sel, a);
        result.push.apply(result, inner);
      });
      return result.filter(function(item) {
        return item;
      });
    }
    if (typeof selector === "number") {
      return [a[selector]];
    }
    var nodes = a.map(function(el) {
      return el.nTable;
    });
    return $(nodes).filter(selector).map(function() {
      var idx = nodes.indexOf(this);
      return a[idx];
    }).toArray();
  };
  _api_register("tables()", function(selector) {
    return selector !== void 0 && selector !== null ? new _Api(__table_selector(selector, this.context)) : this;
  });
  _api_register("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api(ctx[0]) : tables;
  });
  [
    ["nodes", "node", "nTable"],
    ["body", "body", "nTBody"],
    ["header", "header", "nTHead"],
    ["footer", "footer", "nTFoot"]
  ].forEach(function(item) {
    _api_registerPlural(
      "tables()." + item[0] + "()",
      "table()." + item[1] + "()",
      function() {
        return this.iterator("table", function(ctx) {
          return ctx[item[2]];
        }, 1);
      }
    );
  });
  [
    ["header", "aoHeader"],
    ["footer", "aoFooter"]
  ].forEach(function(item) {
    _api_register("table()." + item[0] + ".structure()", function(selector) {
      var indexes = this.columns(selector).indexes().flatten();
      var ctx = this.context[0];
      return _fnHeaderLayout(ctx, ctx[item[1]], indexes);
    });
  });
  _api_registerPlural("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register("tables().every()", function(fn) {
    var that = this;
    return this.iterator("table", function(s, i) {
      fn.call(that.table(i), i);
    });
  });
  _api_register("caption()", function(value, side) {
    var context = this.context;
    if (value === void 0) {
      var caption = context[0].captionNode;
      return caption && context.length ? caption.innerHTML : null;
    }
    return this.iterator("table", function(ctx) {
      var table = $(ctx.nTable);
      var caption2 = $(ctx.captionNode);
      var container = $(ctx.nTableWrapper);
      if (!caption2.length) {
        caption2 = $("<caption/>").html(value);
        ctx.captionNode = caption2[0];
        if (!side) {
          table.prepend(caption2);
          side = caption2.css("caption-side");
        }
      }
      caption2.html(value);
      if (side) {
        caption2.css("caption-side", side);
        caption2[0]._captionSide = side;
      }
      if (container.find("div.dataTables_scroll").length) {
        var selector = side === "top" ? "Head" : "Foot";
        container.find("div.dataTables_scroll" + selector + " table").prepend(caption2);
      } else {
        table.prepend(caption2);
      }
    }, 1);
  });
  _api_register("caption.node()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].captionNode : null;
  });
  _api_register("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw(settings, paging === false);
      }
    });
  });
  _api_register("page()", function(action) {
    if (action === void 0) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange(settings, action);
    });
  });
  _api_register("page.info()", function() {
    if (this.context.length === 0) {
      return void 0;
    }
    var settings = this.context[0], start = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource(settings) === "ssp"
    };
  });
  _api_register("page.len()", function(len) {
    if (len === void 0) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange(settings, len);
    });
  });
  var __reload = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource(settings) == "ssp") {
      _fnReDraw(settings, holdPosition);
    } else {
      _fnProcessingDisplay(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax(settings, {}, function(json) {
        _fnClearTable(settings);
        var data = _fnAjaxDataSrc(settings, json);
        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData(settings, data[i]);
        }
        _fnReDraw(settings, holdPosition);
        _fnInitComplete(settings);
        _fnProcessingDisplay(settings, false);
      });
    }
  };
  _api_register("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload(settings, resetPaging === false, callback);
    });
  });
  _api_register("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === void 0) {
      if (ctx.length === 0) {
        return void 0;
      }
      ctx = ctx[0];
      return $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax;
    }
    return this.iterator("table", function(settings) {
      if ($.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
      selector = [selector];
    }
    for (i = 0, ien = selector.length; i < ien; i++) {
      a = selector[i] && selector[i].split && !selector[i].match(/[[(:]/) ? selector[i].split(",") : [selector[i]];
      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === "string" ? a[j].trim() : a[j]);
        res = res.filter(function(item) {
          return item !== null && item !== void 0;
        });
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext.selector[type];
    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }
    return _unique(out);
  };
  var _selector_opts = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === void 0) {
      opts.search = opts.filter;
    }
    return $.extend({
      search: "none",
      order: "current",
      page: "all"
    }, opts);
  };
  var _selector_first = function(old) {
    var inst = new _Api(old.context[0]);
    if (old.length) {
      inst.push(old[0]);
    }
    inst.selector = old.selector;
    if (inst.length && inst[0].length > 1) {
      inst[0].splice(1);
    }
    return inst;
  };
  var _selector_row_indexes = function(settings, opts) {
    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order = opts.order, page = opts.page;
    if (_fnDataSource(settings) == "ssp") {
      return search === "removed" ? [] : _range(0, displayMaster.length);
    }
    if (page == "current") {
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == "current" || order == "applied") {
      if (search == "none") {
        a = displayMaster.slice();
      } else if (search == "applied") {
        a = displayFiltered.slice();
      } else if (search == "removed") {
        var displayFilteredMap = {};
        for (i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }
        displayMaster.forEach(function(item) {
          if (!Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
            a.push(item);
          }
        });
      }
    } else if (order == "index" || order == "original") {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (!settings.aoData[i]) {
          continue;
        }
        if (search == "none") {
          a.push(i);
        } else {
          tmp = displayFiltered.indexOf(i);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(i);
          }
        }
      }
    } else if (typeof order === "number") {
      var ordered = _fnSort(settings, order, "asc");
      if (search === "none") {
        a = ordered;
      } else {
        for (i = 0; i < ordered.length; i++) {
          tmp = displayFiltered.indexOf(ordered[i]);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(ordered[i]);
          }
        }
      }
    }
    return a;
  };
  var __row_selector = function(settings, selector, opts) {
    var rows;
    var run = function(sel) {
      var selInt = _intVal(sel);
      var aoData = settings.aoData;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      if (!rows) {
        rows = _selector_row_indexes(settings, opts);
      }
      if (selInt !== null && rows.indexOf(selInt) !== -1) {
        return [selInt];
      } else if (sel === null || sel === void 0 || sel === "") {
        return rows;
      }
      if (typeof sel === "function") {
        return rows.map(function(idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex;
        var cellIdx = sel._DT_CellIndex;
        if (rowIdx !== void 0) {
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $(sel).closest("*[data-dt-row]");
          return host.length ? [host.data("dt-row")] : [];
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== void 0) {
          return [rowObj.idx];
        }
      }
      var nodes = _removeEmpty(
        _pluck_order(settings.aoData, rows, "nTr")
      );
      return $(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    var matched = _selector_run("row", selector, run, settings, opts);
    if (opts.order === "current" || opts.order === "applied") {
      _fnSortDisplay(settings, matched);
    }
    return matched;
  };
  _api_register("rows()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || void 0;
    }, 1);
  });
  _api_register("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r = settings.aoData[row];
      return type === "search" ? r._aFilterData : r._aSortData;
    }, 1);
  });
  _api_registerPlural("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate(settings, row, src);
    });
  });
  _api_registerPlural("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural("rows().ids()", "row().id()", function(hash) {
    var a = [];
    var context = this.context;
    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? "#" : "") + id);
      }
    }
    return new _Api(context, a);
  });
  _api_registerPlural("rows().remove()", "row().remove()", function() {
    this.iterator("row", function(settings, row) {
      var data = settings.aoData;
      var rowData = data[row];
      var idx = settings.aiDisplayMaster.indexOf(row);
      if (idx !== -1) {
        settings.aiDisplayMaster.splice(idx, 1);
      }
      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      }
      _fnLengthOverflow(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== void 0) {
        delete settings.aIds[id];
      }
      data[row] = null;
    });
    return this;
  });
  _api_register("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i, ien;
      var out = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr(settings, row)[0]);
        } else {
          out.push(_fnAddData(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    modRows.push.apply(modRows, newRows);
    return modRows;
  });
  _api_register("row()", function(selector, opts) {
    return _selector_first(this.rows(selector, opts));
  });
  _api_register("row().data()", function(data) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]]._aData : void 0;
    }
    var row = ctx[0].aoData[this[0]];
    row._aData = data;
    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id);
    }
    _fnInvalidate(ctx[0], this[0], "data");
    return this;
  });
  _api_register("row().node()", function() {
    var ctx = this.context;
    if (ctx.length && this.length && this[0].length) {
      var row = ctx[0].aoData[this[0]];
      if (row && row.nTr) {
        return row.nTr;
      }
    }
    return null;
  });
  _api_register("row.add()", function(row) {
    if (row instanceof $ && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr(settings, row)[0];
      }
      return _fnAddData(settings, row);
    });
    return this.row(rows[0]);
  });
  $(document).on("plugin-init.dt", function(e, context) {
    var api = new _Api(context);
    api.on("stateSaveParams.DT", function(e2, settings, d) {
      var idFn = settings.rowIdFn;
      var rows = settings.aiDisplayMaster;
      var ids = [];
      for (var i = 0; i < rows.length; i++) {
        var rowIdx = rows[i];
        var data = settings.aoData[rowIdx];
        if (data._detailsShow) {
          ids.push("#" + idFn(data._aData));
        }
      }
      d.childRows = ids;
    });
    api.on("stateLoaded.DT", function(e2, settings, state) {
      __details_state_load(api, state);
    });
    __details_state_load(api, api.state.loaded());
  });
  var __details_state_load = function(api, state) {
    if (state && state.childRows) {
      api.rows(state.childRows.map(function(id) {
        return id.replace(/([^:\\]*(?:\\.[^:\\]*)*):/g, "$1\\:");
      })).every(function() {
        _fnCallbackFire(api.settings()[0], null, "requestChild", [this]);
      });
    }
  };
  var __details_add = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r, k) {
      if (Array.isArray(r) || r instanceof $) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }
        return;
      }
      if (r.nodeName && r.nodeName.toLowerCase() === "tr") {
        r.setAttribute("data-dt-row", row.idx);
        rows.push(r);
      } else {
        var created = $("<tr><td></td></tr>").attr("data-dt-row", row.idx).addClass(k);
        $("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.detach();
    }
    row._details = $(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_state = DataTable.util.throttle(
    function(ctx) {
      _fnSaveState(ctx[0]);
    },
    500
  );
  var __details_remove = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = void 0;
        row._details = void 0;
        $(row.nTr).removeClass("dt-hasChild");
        __details_state(ctx);
      }
    }
  };
  var __details_display = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
          $(row.nTr).addClass("dt-hasChild");
        } else {
          row._details.detach();
          $(row.nTr).removeClass("dt-hasChild");
        }
        _fnCallbackFire(ctx[0], null, "childRow", [show, api.row(api[0])]);
        __details_events(ctx[0]);
        __details_state(ctx);
      }
    }
  };
  var __details_events = function(settings) {
    var api = new _Api(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-sizing" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck(data, "_details").length > 0) {
      api.on(drawEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({ page: "current" }).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns(ctx);
        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];
          if (row && row._details) {
            row._details.each(function() {
              var el = $(this).children("td");
              if (el.length == 1) {
                el.attr("colspan", visible);
              }
            });
          }
        }
      });
      api.on(destroyEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i] && data[i]._details) {
            __details_remove(api, i);
          }
        }
      });
    }
  };
  var _emp = "";
  var _child_obj = _emp + "row().child";
  var _child_mth = _child_obj + "()";
  _api_register(_child_mth, function(data, klass) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && ctx[0].aoData[this[0]] ? ctx[0].aoData[this[0]]._details : void 0;
    } else if (data === true) {
      this.child.show();
    } else if (data === false) {
      __details_remove(this);
    } else if (ctx.length && this.length) {
      __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }
    return this;
  });
  _api_register([
    _child_obj + ".show()",
    _child_mth + ".show()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display(this, true);
    return this;
  });
  _api_register([
    _child_obj + ".hide()",
    _child_mth + ".hide()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display(this, false);
    return this;
  });
  _api_register([
    _child_obj + ".remove()",
    _child_mth + ".remove()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_remove(this);
    return this;
  });
  _api_register(_child_obj + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length && ctx[0].aoData[this[0]]) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector = /^([^:]+)?:(name|title|visIdx|visible)$/;
  var __columnData = function(settings, column, r1, r2, rows, type) {
    var a = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData(settings, rows[row], column, type));
    }
    return a;
  };
  var __column_header = function(settings, column, row) {
    var header = settings.aoHeader;
    var target = row !== void 0 ? row : settings.bSortCellsTop ? 0 : header.length - 1;
    return header[target][column].cell;
  };
  var __column_selector = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck(columns, "sName"), titles = _pluck(columns, "sTitle"), cells = DataTable.util.get("[].[].cell")(settings.aoHeader), nodes = _unique(_flatten([], cells));
    var run = function(s) {
      var selInt = _intVal(s);
      if (s === "") {
        return _range(columns.length);
      }
      if (selInt !== null) {
        return [
          selInt >= 0 ? selInt : (
            // Count from left
            columns.length + selInt
          )
          // Count from right (+ because its a negative value)
        ];
      }
      if (typeof s === "function") {
        var rows = _selector_row_indexes(settings, opts);
        return columns.map(function(col, idx2) {
          return s(
            idx2,
            __columnData(settings, idx2, 0, 0, rows),
            __column_header(settings, idx2)
          ) ? idx2 : null;
        });
      }
      var match = typeof s === "string" ? s.match(__re_column_selector) : "";
      if (match) {
        switch (match[2]) {
          case "visIdx":
          case "visible":
            if (match[1] && match[1].match(/^\d+$/)) {
              var idx = parseInt(match[1], 10);
              if (idx < 0) {
                var visColumns = columns.map(function(col, i) {
                  return col.bVisible ? i : null;
                });
                return [visColumns[visColumns.length + idx]];
              }
              return [_fnVisibleToColumnIndex(settings, idx)];
            }
            return columns.map(function(col, idx2) {
              if (!col.bVisible) {
                return null;
              }
              if (match[1]) {
                return $(nodes[idx2]).filter(match[1]).length > 0 ? idx2 : null;
              }
              return idx2;
            });
          case "name":
            return names.map(function(name, i) {
              return name === match[1] ? i : null;
            });
          case "title":
            return titles.map(function(title, i) {
              return title === match[1] ? i : null;
            });
          default:
            return [];
        }
      }
      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      }
      var jqResult = $(nodes).filter(s).map(function() {
        return _fnColumnsFromHeader(this);
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      var host = $(s).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run("column", selector, run, settings, opts);
  };
  var __setColumnVis = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, cells, i, ien, tr;
    if (vis === void 0) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return false;
    }
    if (vis) {
      var insertBefore = _pluck(cols, "bVisible").indexOf(true, column + 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        if (data[i]) {
          tr = data[i].nTr;
          cells = data[i].anCells;
          if (tr) {
            tr.insertBefore(cells[column], cells[insertBefore] || null);
          }
        }
      }
    } else {
      $(_pluck(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
    _colGroup(settings);
    return true;
  };
  _api_register("columns()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural("columns().header()", "column().header()", function(row) {
    return this.iterator("column", function(settings, column) {
      return __column_header(settings, column, row);
    }, 1);
  });
  _api_registerPlural("columns().footer()", "column().footer()", function(row) {
    return this.iterator("column", function(settings, column) {
      var footer = settings.aoFooter;
      if (!footer.length) {
        return null;
      }
      return settings.aoFooter[row !== void 0 ? row : 0][column].cell;
    }, 1);
  });
  _api_registerPlural("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData, 1);
  });
  _api_registerPlural("columns().render()", "column().render()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return __columnData(settings, column, i, j, rows, type);
    }, 1);
  });
  _api_registerPlural("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order(
        settings.aoData,
        rows,
        type === "search" ? "_aFilterData" : "_aSortData",
        column
      );
    }, 1);
  });
  _api_registerPlural("columns().init()", "column().init()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column];
    }, 1);
  });
  _api_registerPlural("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural("columns().titles()", "column().title()", function(title, row) {
    return this.iterator("column", function(settings, column) {
      if (typeof title === "number") {
        row = title;
        title = void 0;
      }
      var span = $("span.dt-column-title", this.column(column).header(row));
      if (title !== void 0) {
        span.html(title);
        return this;
      }
      return span.html();
    }, 1);
  });
  _api_registerPlural("columns().types()", "column().type()", function() {
    return this.iterator("column", function(settings, column) {
      var type = settings.aoColumns[column].sType;
      if (!type) {
        _fnColumnTypes(settings);
      }
      return type;
    }, 1);
  });
  _api_registerPlural("columns().visible()", "column().visible()", function(vis, calc) {
    var that = this;
    var changed = [];
    var ret = this.iterator("column", function(settings, column) {
      if (vis === void 0) {
        return settings.aoColumns[column].bVisible;
      }
      if (__setColumnVis(settings, column, vis)) {
        changed.push(column);
      }
    });
    if (vis !== void 0) {
      this.iterator("table", function(settings) {
        _fnDrawHead(settings, settings.aoHeader);
        _fnDrawHead(settings, settings.aoFooter);
        if (!settings.aiDisplay.length) {
          $(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns(settings));
        }
        _fnSaveState(settings);
        that.iterator("column", function(settings2, column) {
          if (changed.includes(column)) {
            _fnCallbackFire(settings2, null, "column-visibility", [settings2, column, vis, calc]);
          }
        });
        if (changed.length && (calc === void 0 || calc)) {
          that.columns.adjust();
        }
      });
    }
    return ret;
  });
  _api_registerPlural("columns().widths()", "column().width()", function() {
    var columns = this.columns(":visible").count();
    var row = $("<tr>").html("<td>" + Array(columns).join("</td><td>") + "</td>");
    $(this.table().body()).append(row);
    var widths = row.children().map(function() {
      return $(this).outerWidth();
    });
    row.remove();
    return this.iterator("column", function(settings, column) {
      var visIdx = _fnColumnIndexToVisible(settings, column);
      return visIdx !== null ? widths[visIdx] : 0;
    }, 1);
  });
  _api_registerPlural("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible(settings, column) : column;
    }, 1);
  });
  _api_register("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing(settings);
    }, 1);
  });
  _api_register("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex(ctx, idx);
      } else if (type === "fromData" || type === "toVisible") {
        return _fnColumnIndexToVisible(ctx, idx);
      }
    }
  });
  _api_register("column()", function(selector, opts) {
    return _selector_first(this.columns(selector, opts));
  });
  var __cell_selector = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes(settings, opts);
    var cells = _removeEmpty(_pluck_order(data, rows, "anCells"));
    var allCells = $(_flatten([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;
    var run = function(s) {
      var fnSelector = typeof s === "function";
      if (s === null || s === void 0 || fnSelector) {
        a = [];
        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];
          for (j = 0; j < columns; j++) {
            o = {
              row,
              column: j
            };
            if (fnSelector) {
              host = data[row];
              if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              a.push(o);
            }
          }
        }
        return a;
      }
      if ($.isPlainObject(s)) {
        return s.column !== void 0 && s.row !== void 0 && rows.indexOf(s.row) !== -1 ? [s] : [];
      }
      var jqResult = allCells.filter(s).map(function(i2, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      host = $(s).closest("*[data-dt-row]");
      return host.length ? [{
        row: host.data("dt-row"),
        column: host.data("dt-column")
      }] : [];
    };
    return _selector_run("cell", selector, run, settings, opts);
  };
  _api_register("cells()", function(rowSelector, columnSelector, opts) {
    if ($.isPlainObject(rowSelector)) {
      if (rowSelector.row === void 0) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === void 0) {
      return this.iterator("table", function(settings) {
        return __cell_selector(settings, rowSelector, _selector_opts(opts));
      });
    }
    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {};
    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator("table", function(settings, idx) {
      var a = [];
      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }
      return a;
    }, 1);
    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts
    });
    return cells;
  });
  _api_registerPlural("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : void 0;
    }, 1);
  });
  _api_register("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData(settings, row, column);
    }, 1);
  });
  _api_registerPlural("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {
        row,
        column,
        columnVisible: _fnColumnIndexToVisible(settings, column)
      };
    }, 1);
  });
  _api_registerPlural("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate(settings, row, src, column);
    });
  });
  _api_register("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === void 0) {
      return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : void 0;
    }
    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register("order()", function(order, dir) {
    var ctx = this.context;
    var args = Array.prototype.slice.call(arguments);
    if (order === void 0) {
      return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
    }
    if (typeof order === "number") {
      order = [[order, dir]];
    } else if (args.length > 1) {
      order = args;
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = Array.isArray(order) ? order.slice() : order;
    });
  });
  _api_register("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener(settings, node, {}, column, callback);
    });
  });
  _api_register("order.fixed()", function(set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
      return Array.isArray(fixed) ? { pre: fixed } : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $.extend(true, {}, set);
    });
  });
  _api_register([
    "columns().order()",
    "column().order()"
  ], function(dir) {
    var that = this;
    if (!dir) {
      return this.iterator("column", function(settings, idx) {
        var sort = _fnSortFlatten(settings);
        for (var i = 0, ien = sort.length; i < ien; i++) {
          if (sort[i].col === idx) {
            return sort[i].dir;
          }
        }
        return null;
      }, 1);
    } else {
      return this.iterator("table", function(settings, i) {
        settings.aaSorting = that[i].map(function(col) {
          return [col, dir];
        });
      });
    }
  });
  _api_registerPlural("columns().orderable()", "column().orderable()", function(directions) {
    return this.iterator("column", function(settings, idx) {
      var col = settings.aoColumns[idx];
      return directions ? col.asSorting : col.bSortable;
    }, 1);
  });
  _api_register("processing()", function(show) {
    return this.iterator("table", function(ctx) {
      _fnProcessingDisplay(ctx, show);
    });
  });
  _api_register("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === void 0) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.search : void 0;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      if (typeof regex === "object") {
        _fnFilterComplete(settings, $.extend(settings.oPreviousSearch, regex, {
          search: input
        }));
      } else {
        _fnFilterComplete(settings, $.extend(settings.oPreviousSearch, {
          search: input,
          regex: regex === null ? false : regex,
          smart: smart === null ? true : smart,
          caseInsensitive: caseInsen === null ? true : caseInsen
        }));
      }
    });
  });
  _api_register("search.fixed()", function(name, search) {
    var ret = this.iterator(true, "table", function(settings) {
      var fixed = settings.searchFixed;
      if (!name) {
        return Object.keys(fixed);
      } else if (search === void 0) {
        return fixed[name];
      } else if (search === null) {
        delete fixed[name];
      } else {
        fixed[name] = search;
      }
      return this;
    });
    return name !== void 0 && search === void 0 ? ret[0] : ret;
  });
  _api_registerPlural(
    "columns().search()",
    "column().search()",
    function(input, regex, smart, caseInsen) {
      return this.iterator("column", function(settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === void 0) {
          return preSearch[column].search;
        }
        if (!settings.oFeatures.bFilter) {
          return;
        }
        if (typeof regex === "object") {
          $.extend(preSearch[column], regex, {
            search: input
          });
        } else {
          $.extend(preSearch[column], {
            search: input,
            regex: regex === null ? false : regex,
            smart: smart === null ? true : smart,
            caseInsensitive: caseInsen === null ? true : caseInsen
          });
        }
        _fnFilterComplete(settings, settings.oPreviousSearch);
      });
    }
  );
  _api_register(
    [
      "columns().search.fixed()",
      "column().search.fixed()"
    ],
    function(name, search) {
      var ret = this.iterator(true, "column", function(settings, colIdx) {
        var fixed = settings.aoColumns[colIdx].searchFixed;
        if (!name) {
          return Object.keys(fixed);
        } else if (search === void 0) {
          return fixed[name];
        } else if (search === null) {
          delete fixed[name];
        } else {
          fixed[name] = search;
        }
        return this;
      });
      return name !== void 0 && search === void 0 ? ret[0] : ret;
    }
  );
  _api_register("state()", function(set, ignoreTime) {
    if (!set) {
      return this.context.length ? this.context[0].oSavedState : null;
    }
    var setMutate = $.extend(true, {}, set);
    return this.iterator("table", function(settings) {
      if (ignoreTime !== false) {
        setMutate.time = +/* @__PURE__ */ new Date() + 100;
      }
      _fnImplementState(settings, setMutate, function() {
      });
    });
  });
  _api_register("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState(settings);
    });
  });
  DataTable.use = function(arg1, arg2) {
    var module = typeof arg1 === "string" ? arg2 : arg1;
    var type = typeof arg2 === "string" ? arg2 : arg1;
    if (module === void 0 && typeof type === "string") {
      switch (type) {
        case "lib":
        case "jq":
          return $;
        case "win":
          return window;
        case "datetime":
          return DataTable.DateTime;
        case "luxon":
          return __luxon;
        case "moment":
          return __moment;
        default:
          return null;
      }
    }
    if (type === "lib" || type === "jq" || module && module.fn && module.fn.jquery) {
      $ = module;
    } else if (type == "win" || module && module.document) {
      window = module;
      document = module.document;
    } else if (type === "datetime" || module && module.type === "DateTime") {
      DataTable.DateTime = module;
    } else if (type === "luxon" || module && module.FixedOffsetZone) {
      __luxon = module;
    } else if (type === "moment" || module && module.isMoment) {
      __moment = module;
    }
  };
  DataTable.factory = function(root, jq) {
    var is = false;
    if (root && root.document) {
      window = root;
      document = root.document;
    }
    if (jq && jq.fn && jq.fn.jquery) {
      $ = jq;
      is = true;
    }
    return is;
  };
  DataTable.versionCheck = function(version, version2) {
    var aThis = version2 ? version2.split(".") : DataTable.version.split(".");
    var aThat = version.split(".");
    var iThis, iThat;
    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable.isDataTable = function(table) {
    var t = $(table).get(0);
    var is = false;
    if (table instanceof DataTable.Api) {
      return true;
    }
    $.each(DataTable.settings, function(i, o) {
      var head = o.nScrollHead ? $("table", o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $("table", o.nScrollFoot)[0] : null;
      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  DataTable.tables = function(visible) {
    var api = false;
    if ($.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a = DataTable.settings.filter(function(o) {
      return !visible || visible && $(o.nTable).is(":visible") ? true : false;
    }).map(function(o) {
      return o.nTable;
    });
    return api ? new _Api(a) : a;
  };
  DataTable.camelToHungarian = _fnCamelToHungarian;
  _api_register("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $(rows);
    return $([].concat(
      jqRows.filter(selector).toArray(),
      jqRows.find(selector).toArray()
    ));
  });
  $.each(["on", "one", "off"], function(i, key) {
    _api_register(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      args[0] = args[0].split(/\s/).map(function(e) {
        return !e.match(/\.dt\b/) ? e + ".dt" : e;
      }).join(" ");
      var inst = $(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable(settings);
    });
  });
  _api_register("error()", function(msg) {
    return this.iterator("table", function(settings) {
      _fnLog(settings, 0, msg);
    });
  });
  _api_register("settings()", function() {
    return new _Api(this.context, this.context);
  });
  _api_register("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register("trigger()", function(name, args, bubbles) {
    return this.iterator("table", function(settings) {
      return _fnCallbackFire(settings, null, name, args, bubbles);
    }).flatten();
  });
  _api_register("ready()", function(fn) {
    var ctx = this.context;
    if (!fn) {
      return ctx.length ? ctx[0]._bInitComplete || false : null;
    }
    return this.tables().every(function() {
      if (this.context[0]._bInitComplete) {
        fn.call(this);
      } else {
        this.on("init.dt.DT", function() {
          fn.call(this);
        });
      }
    });
  });
  _api_register("destroy()", function(remove) {
    remove = remove || false;
    return this.iterator("table", function(settings) {
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $(table);
      var jqTbody = $(tbody);
      var jqWrapper = $(settings.nTableWrapper);
      var rows = settings.aoData.map(function(r) {
        return r ? r.nTr : null;
      });
      var orderClasses = classes.order;
      settings.bDestroying = true;
      _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings], true);
      if (!remove) {
        new _Api(settings).columns().visible(true);
      }
      jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
      $(window).off(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.colgroup.remove();
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses(settings);
      $("th, td", thead).removeClass(
        orderClasses.canAsc + " " + orderClasses.canDesc + " " + orderClasses.isAsc + " " + orderClasses.isDesc
      ).css("width", "");
      jqTbody.children().detach();
      jqTbody.append(rows);
      var orig = settings.nTableWrapper.parentNode;
      var insertBefore = settings.nTableWrapper.nextSibling;
      var removedMethod = remove ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove && orig) {
        orig.insertBefore(table, insertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.table);
      }
      var idx = DataTable.settings.indexOf(settings);
      if (idx !== -1) {
        DataTable.settings.splice(idx, 1);
      }
    });
  });
  $.each(["column", "row", "cell"], function(i, type) {
    _api_register(type + "s().every()", function(fn) {
      var opts = this.selector.opts;
      var api = this;
      var inst;
      var counter = 0;
      return this.iterator("every", function(settings, selectedIdx, tableIdx) {
        inst = api[type](selectedIdx, opts);
        if (type === "cell") {
          fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
        } else {
          fn.call(inst, selectedIdx, tableIdx, counter);
        }
        counter++;
      });
    });
  });
  _api_register("i18n()", function(token, def, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);
    if (resolved === void 0) {
      resolved = def;
    }
    if ($.isPlainObject(resolved)) {
      resolved = plural !== void 0 && resolved[plural] !== void 0 ? resolved[plural] : resolved._;
    }
    return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
  });
  DataTable.version = "2.1.7";
  DataTable.settings = [];
  DataTable.models = {};
  DataTable.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     */
    "caseInsensitive": true,
    /**
     * Applied search term
     */
    "search": "",
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     */
    "regex": false,
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     */
    "smart": true,
    /**
     * Flag to indicate if DataTables should only trigger a search when
     * the return key is pressed.
     */
    "return": false
  };
  DataTable.models.oRow = {
    /**
     * TR element for the row
     */
    "nTr": null,
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     */
    "anCells": null,
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     */
    "_aData": [],
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     */
    "_aSortData": null,
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     */
    "_aFilterData": null,
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     */
    "_sFilterRow": null,
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     */
    "src": null,
    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     */
    "idx": -1,
    /**
     * Cached display value
     */
    displayData: null
  };
  DataTable.models.oColumn = {
    /**
     * Column index.
     */
    "idx": null,
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     */
    "aDataSort": null,
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     */
    "asSorting": null,
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     */
    "bSearchable": null,
    /**
     * Flag to indicate if the column is sortable or not.
     */
    "bSortable": null,
    /**
     * Flag to indicate if the column is currently visible in the table or not
     */
    "bVisible": null,
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     */
    "_sManualType": null,
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     */
    "_bAttrSrc": false,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     */
    "fnGetData": null,
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     */
    "fnSetData": null,
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     */
    "mData": null,
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     */
    "mRender": null,
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     */
    "sClass": null,
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     */
    "sContentPadding": null,
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     */
    "sName": null,
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     */
    "sSortDataType": "std",
    /**
     * Class to be applied to the header element when sorting on this column
     */
    "sSortingClass": null,
    /**
     * Title of the column - what is seen in the TH element (nTh).
     */
    "sTitle": null,
    /**
     * Column sorting and filtering type
     */
    "sType": null,
    /**
     * Width of the column
     */
    "sWidth": null,
    /**
     * Width of the column when it was first "encountered"
     */
    "sWidthOrig": null,
    /** Cached string which is the longest in the column */
    maxLenString: null,
    /**
     * Store for named searches
     */
    searchFixed: null
  };
  DataTable.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     */
    "aaData": null,
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     */
    "aaSorting": [[0, "asc"]],
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     */
    "aaSortingFixed": [],
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     */
    "ajax": null,
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     */
    "aLengthMenu": [10, 25, 50, 100],
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     */
    "aoColumns": null,
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     */
    "aoColumnDefs": null,
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     */
    "aoSearchCols": [],
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     */
    "bAutoWidth": true,
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     */
    "bDeferRender": true,
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     */
    "bDestroy": false,
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     */
    "bFilter": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bInfo": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bLengthChange": true,
    /**
     * Enable or disable pagination.
     */
    "bPaginate": true,
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     */
    "bProcessing": false,
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     */
    "bRetrieve": false,
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     */
    "bScrollCollapse": false,
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     */
    "bServerSide": false,
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     */
    "bSort": true,
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     */
    "bSortMulti": true,
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     */
    "bSortCellsTop": null,
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     */
    "bSortClasses": true,
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     */
    "bStateSave": false,
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     */
    "fnCreatedRow": null,
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     */
    "fnDrawCallback": null,
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     */
    "fnFooterCallback": null,
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     */
    "fnFormatNumber": function(toFormat) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     */
    "fnHeaderCallback": null,
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     */
    "fnInfoCallback": null,
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     */
    "fnInitComplete": null,
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     */
    "fnPreDrawCallback": null,
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     */
    "fnRowCallback": null,
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateLoadCallback": function(settings) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            "DataTables_" + settings.sInstance + "_" + location.pathname
          )
        );
      } catch (e) {
        return {};
      }
    },
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     */
    "fnStateLoadParams": null,
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     */
    "fnStateLoaded": null,
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateSaveCallback": function(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname,
          JSON.stringify(data)
        );
      } catch (e) {
      }
    },
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     */
    "fnStateSaveParams": null,
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     */
    "iStateDuration": 7200,
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     */
    "iDisplayLength": 10,
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     */
    "iDisplayStart": 0,
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     */
    "iTabIndex": 0,
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     */
    "oClasses": {},
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be sorted
         */
        "orderable": ": Activate to sort",
        /**
         * ARIA label that is added to the table headers when the column is currently being sorted
         */
        "orderableReverse": ": Activate to invert sorting",
        /**
         * ARIA label that is added to the table headers when the column is currently being 
         * sorted and next step is to remove sorting
         */
        "orderableRemove": ": Activate to remove sorting",
        paginate: {
          first: "First",
          last: "Last",
          next: "Next",
          previous: "Previous",
          number: ""
        }
      },
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       */
      "oPaginate": {
        /**
         * Label and character for first page button ()
         */
        "sFirst": "\xAB",
        /**
         * Last page button ()
         */
        "sLast": "\xBB",
        /**
         * Next page button ()
         */
        "sNext": "\u203A",
        /**
         * Previous page button ()
         */
        "sPrevious": "\u2039"
      },
      /**
       * Plural object for the data type the table is showing
       */
      entries: {
        _: "entries",
        1: "entry"
      },
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       */
      "sEmptyTable": "No data available in table",
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       */
      "sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       */
      "sInfoPostFix": "",
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       */
      "sDecimal": "",
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       */
      "sThousands": ",",
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       */
      "sLengthMenu": "_MENU_ _ENTRIES_ per page",
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       */
      "sLoadingRecords": "Loading...",
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       */
      "sProcessing": "",
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       */
      "sSearch": "Search:",
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       */
      "sUrl": "",
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       */
      "sZeroRecords": "No matching records found"
    },
    /** The initial data order is reversed when `desc` ordering */
    orderDescReverse: true,
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     */
    "oSearch": $.extend({}, DataTable.models.oSearch),
    /**
     * Table and control layout. This replaces the legacy `dom` option.
     */
    layout: {
      topStart: "pageLength",
      topEnd: "search",
      bottomStart: "info",
      bottomEnd: "paging"
    },
    /**
     * Legacy DOM layout option
     */
    "sDom": null,
    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     */
    "searchDelay": null,
    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     */
    "sPaginationType": "",
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     */
    "sScrollX": "",
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     */
    "sScrollXInner": "",
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     */
    "sScrollY": "",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     */
    "sServerMethod": "GET",
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     */
    "renderer": null,
    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     */
    "rowId": "DT_RowId",
    /**
     * Caption value
     */
    "caption": null,
    /**
     * For server-side processing - use the data from the DOM for the first draw
     */
    iDeferLoading: null
  };
  _fnHungarianMap(DataTable.defaults);
  DataTable.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     */
    "aDataSort": null,
    "iDataSort": -1,
    ariaTitle: "",
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     */
    "asSorting": ["asc", "desc", ""],
    /**
     * Enable or disable filtering on the data in this column.
     */
    "bSearchable": true,
    /**
     * Enable or disable ordering on this column.
     */
    "bSortable": true,
    /**
     * Enable or disable the display of this column.
     */
    "bVisible": true,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     */
    "mData": null,
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     */
    "mRender": null,
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     */
    "sCellType": "td",
    /**
     * Class to give to each cell in this column.
     */
    "sClass": "",
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     */
    "sContentPadding": "",
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     */
    "sName": "",
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     */
    "sSortDataType": "std",
    /**
     * The title of this column.
     */
    "sTitle": null,
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     */
    "sType": null,
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     */
    "sWidth": null
  };
  _fnHungarianMap(DataTable.defaults.column);
  DataTable.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bAutoWidth": null,
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all for DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bDeferRender": null,
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bFilter": null,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bInfo": true,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bLengthChange": true,
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bPaginate": null,
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bProcessing": null,
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bServerSide": null,
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSort": null,
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortMulti": null,
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortClasses": null,
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bStateSave": null
    },
    /**
     * Scrolling settings for a table.
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bCollapse": null,
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       */
      "iBarWidth": 0,
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sX": null,
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @deprecated
       */
      "sXInner": null,
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sY": null
    },
    /**
     * Language information for the table.
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       */
      "fnInfoCallback": null
    },
    /**
     * Browser support parameters
     */
    "oBrowser": {
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       */
      "bScrollbarLeft": false,
      /**
       * Browser scrollbar width
       */
      "barWidth": 0
    },
    "ajax": null,
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     */
    "aanFeatures": [],
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     */
    "aoData": [],
    /**
     * Array of indexes which are in the current display (after filtering etc)
     */
    "aiDisplay": [],
    /**
     * Array of indexes for display - no filtering
     */
    "aiDisplayMaster": [],
    /**
     * Map of row ids to data indexes
     */
    "aIds": {},
    /**
     * Store information about each column that is in use
     */
    "aoColumns": [],
    /**
     * Store information about the table's header
     */
    "aoHeader": [],
    /**
     * Store information about the table's footer
     */
    "aoFooter": [],
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "oPreviousSearch": {},
    /**
     * Store for named searches
     */
    searchFixed: {},
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     */
    "aoPreSearchCols": [],
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSorting": null,
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSortingFixed": [],
    /**
     * If restoring a table - we should restore its width
     */
    "sDestroyWidth": 0,
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     */
    "aoRowCallback": [],
    /**
     * Callback functions for the header on each draw.
     */
    "aoHeaderCallback": [],
    /**
     * Callback function for the footer on each draw.
     */
    "aoFooterCallback": [],
    /**
     * Array of callback functions for draw callback functions
     */
    "aoDrawCallback": [],
    /**
     * Array of callback functions for row created function
     */
    "aoRowCreatedCallback": [],
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     */
    "aoPreDrawCallback": [],
    /**
     * Callback functions for when the table has been initialised.
     */
    "aoInitComplete": [],
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     */
    "aoStateSaveParams": [],
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     */
    "aoStateLoadParams": [],
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     */
    "aoStateLoaded": [],
    /**
     * Cache the table ID for quick access
     */
    "sTableId": "",
    /**
     * The TABLE node for the main table
     */
    "nTable": null,
    /**
     * Permanent ref to the thead element
     */
    "nTHead": null,
    /**
     * Permanent ref to the tfoot element - if it exists
     */
    "nTFoot": null,
    /**
     * Permanent ref to the tbody element
     */
    "nTBody": null,
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     */
    "nTableWrapper": null,
    /**
     * Indicate if all required information has been read in
     */
    "bInitialised": false,
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     */
    "aoOpenRows": [],
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sDom": null,
    /**
     * Search delay (in mS)
     */
    "searchDelay": null,
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sPaginationType": "two_button",
    /**
     * Number of paging controls on the page. Only used for backwards compatibility
     */
    pagingControls: 0,
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "iStateDuration": 0,
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateSave": [],
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateLoad": [],
    /**
     * State that was saved. Useful for back reference
     */
    "oSavedState": null,
    /**
     * State that was loaded. Useful for back reference
     */
    "oLoadedState": null,
    /**
     * Note if draw should be blocked while getting data
     */
    "bAjaxDataGet": true,
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     */
    "jqXHR": null,
    /**
     * JSON returned from the server in the last Ajax request
     */
    "json": void 0,
    /**
     * Data submitted as part of the last Ajax request
     */
    "oAjaxData": void 0,
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sServerMethod": null,
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "fnFormatNumber": null,
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aLengthMenu": null,
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     */
    "iDraw": 0,
    /**
     * Indicate if a redraw is being done - useful for Ajax
     */
    "bDrawing": false,
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     */
    "iDrawError": -1,
    /**
     * Paging display length
     */
    "_iDisplayLength": 10,
    /**
     * Paging start point - aiDisplay index
     */
    "_iDisplayStart": 0,
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsTotal": 0,
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsDisplay": 0,
    /**
     * The classes to use for the table
     */
    "oClasses": {},
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bFiltered": false,
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bSorted": false,
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSortCellsTop": null,
    /**
     * Initialisation object that is used for the table
     */
    "oInit": null,
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     */
    "aoDestroyCallback": [],
    /**
     * Get the number of records in the current record set, before filtering
     */
    "fnRecordsTotal": function() {
      return _fnDataSource(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },
    /**
     * Get the number of records in the current record set, after filtering
     */
    "fnRecordsDisplay": function() {
      return _fnDataSource(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },
    /**
     * Get the display end point - aiDisplay index
     */
    "fnDisplayEnd": function() {
      var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },
    /**
     * The DataTables object for this table
     */
    "oInstance": null,
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     */
    "sInstance": null,
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
    /**
     * Last applied sort
     */
    "aLastSort": [],
    /**
     * Stored plug-in instances
     */
    "oPlugins": {},
    /**
     * Function used to get a row's id from the row's data
     */
    "rowIdFn": null,
    /**
     * Data location where to store a row's id
     */
    "rowId": null,
    caption: "",
    captionNode: null,
    colgroup: null,
    /** Delay loading of data */
    deferLoading: null,
    /** Allow auto type detection */
    typeDetect: true
  };
  var extPagination = DataTable.ext.pager;
  $.extend(extPagination, {
    simple: function() {
      return ["previous", "next"];
    },
    full: function() {
      return ["first", "previous", "next", "last"];
    },
    numbers: function() {
      return ["numbers"];
    },
    simple_numbers: function() {
      return ["previous", "numbers", "next"];
    },
    full_numbers: function() {
      return ["first", "previous", "numbers", "next", "last"];
    },
    first_last: function() {
      return ["first", "last"];
    },
    first_last_numbers: function() {
      return ["first", "numbers", "last"];
    },
    // For testing and plug-ins to use
    _numbers: _pagingNumbers,
    // Number of number buttons - legacy, use `numbers` option for paging feature
    numbers_length: 7
  });
  $.extend(true, DataTable.ext.renderer, {
    pagingButton: {
      _: function(settings, buttonType, content, active, disabled) {
        var classes = settings.oClasses.paging;
        var btnClasses = [classes.button];
        var btn;
        if (active) {
          btnClasses.push(classes.active);
        }
        if (disabled) {
          btnClasses.push(classes.disabled);
        }
        if (buttonType === "ellipsis") {
          btn = $('<span class="ellipsis"></span>').html(content)[0];
        } else {
          btn = $("<button>", {
            class: btnClasses.join(" "),
            role: "link",
            type: "button"
          }).html(content);
        }
        return {
          display: btn,
          clicker: btn
        };
      }
    },
    pagingContainer: {
      _: function(settings, buttons) {
        return buttons;
      }
    }
  });
  var _filterString = function(stripHtml, normalize) {
    return function(str) {
      if (_empty(str) || typeof str !== "string") {
        return str;
      }
      str = str.replace(_re_new_lines, " ");
      if (stripHtml) {
        str = _stripHtml(str);
      }
      if (normalize) {
        str = _normalize(str, false);
      }
      return str;
    };
  };
  function __mld(dtLib, momentFn, luxonFn, dateFn, arg1) {
    if (__moment) {
      return dtLib[momentFn](arg1);
    } else if (__luxon) {
      return dtLib[luxonFn](arg1);
    }
    return dateFn ? dtLib[dateFn](arg1) : dtLib;
  }
  var __mlWarning = false;
  var __luxon;
  var __moment;
  function resolveWindowLibs() {
    if (window.luxon && !__luxon) {
      __luxon = window.luxon;
    }
    if (window.moment && !__moment) {
      __moment = window.moment;
    }
  }
  function __mldObj(d, format, locale) {
    var dt;
    resolveWindowLibs();
    if (__moment) {
      dt = __moment.utc(d, format, locale, true);
      if (!dt.isValid()) {
        return null;
      }
    } else if (__luxon) {
      dt = format && typeof d === "string" ? __luxon.DateTime.fromFormat(d, format) : __luxon.DateTime.fromISO(d);
      if (!dt.isValid) {
        return null;
      }
      dt.setLocale(locale);
    } else if (!format) {
      dt = new Date(d);
    } else {
      if (!__mlWarning) {
        alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
      }
      __mlWarning = true;
    }
    return dt;
  }
  function __mlHelper(localeString) {
    return function(from, to, locale, def) {
      if (arguments.length === 0) {
        locale = "en";
        to = null;
        from = null;
      } else if (arguments.length === 1) {
        locale = "en";
        to = from;
        from = null;
      } else if (arguments.length === 2) {
        locale = to;
        to = from;
        from = null;
      }
      var typeName = "datetime" + (to ? "-" + to : "");
      if (!DataTable.ext.type.order[typeName]) {
        DataTable.type(typeName, {
          detect: function(d) {
            return d === typeName ? typeName : false;
          },
          order: {
            pre: function(d) {
              return d.valueOf();
            }
          },
          className: "dt-right"
        });
      }
      return function(d, type) {
        if (d === null || d === void 0) {
          if (def === "--now") {
            var local = /* @__PURE__ */ new Date();
            d = new Date(Date.UTC(
              local.getFullYear(),
              local.getMonth(),
              local.getDate(),
              local.getHours(),
              local.getMinutes(),
              local.getSeconds()
            ));
          } else {
            d = "";
          }
        }
        if (type === "type") {
          return typeName;
        }
        if (d === "") {
          return type !== "sort" ? "" : __mldObj("0000-01-01 00:00:00", null, locale);
        }
        if (to !== null && from === to && type !== "sort" && type !== "type" && !(d instanceof Date)) {
          return d;
        }
        var dt = __mldObj(d, from, locale);
        if (dt === null) {
          return d;
        }
        if (type === "sort") {
          return dt;
        }
        var formatted = to === null ? __mld(dt, "toDate", "toJSDate", "")[localeString]() : __mld(dt, "format", "toFormat", "toISOString", to);
        return type === "display" ? _escapeHtml(formatted) : formatted;
      };
    };
  }
  var __thousands = ",";
  var __decimal = ".";
  if (window.Intl !== void 0) {
    try {
      num = new Intl.NumberFormat().formatToParts(100000.1);
      for (i = 0; i < num.length; i++) {
        if (num[i].type === "group") {
          __thousands = num[i].value;
        } else if (num[i].type === "decimal") {
          __decimal = num[i].value;
        }
      }
    } catch (e) {
    }
  }
  var num;
  var i;
  DataTable.datetime = function(format, locale) {
    var typeName = "datetime-" + format;
    if (!locale) {
      locale = "en";
    }
    if (!DataTable.ext.type.order[typeName]) {
      DataTable.type(typeName, {
        detect: function(d) {
          var dt = __mldObj(d, format, locale);
          return d === "" || dt ? typeName : false;
        },
        order: {
          pre: function(d) {
            return __mldObj(d, format, locale) || 0;
          }
        },
        className: "dt-right"
      });
    }
  };
  DataTable.render = {
    date: __mlHelper("toLocaleDateString"),
    datetime: __mlHelper("toLocaleString"),
    time: __mlHelper("toLocaleTimeString"),
    number: function(thousands, decimal, precision, prefix, postfix) {
      if (thousands === null || thousands === void 0) {
        thousands = __thousands;
      }
      if (decimal === null || decimal === void 0) {
        decimal = __decimal;
      }
      return {
        display: function(d) {
          if (typeof d !== "number" && typeof d !== "string") {
            return d;
          }
          if (d === "" || d === null) {
            return d;
          }
          var negative = d < 0 ? "-" : "";
          var flo = parseFloat(d);
          var abs = Math.abs(flo);
          if (abs >= 1e11 || abs < 1e-4 && abs !== 0) {
            var exp = flo.toExponential(precision).split(/e\+?/);
            return exp[0] + " x 10<sup>" + exp[1] + "</sup>";
          }
          if (isNaN(flo)) {
            return _escapeHtml(d);
          }
          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
          if (intPart === 0 && parseFloat(floatPart) === 0) {
            negative = "";
          }
          return negative + (prefix || "") + intPart.toString().replace(
            /\B(?=(\d{3})+(?!\d))/g,
            thousands
          ) + floatPart + (postfix || "");
        }
      };
    },
    text: function() {
      return {
        display: _escapeHtml,
        filter: _escapeHtml
      };
    }
  };
  var _extTypes = DataTable.ext.type;
  DataTable.type = function(name, prop, val) {
    if (!prop) {
      return {
        className: _extTypes.className[name],
        detect: _extTypes.detect.find(function(fn) {
          return fn._name === name;
        }),
        order: {
          pre: _extTypes.order[name + "-pre"],
          asc: _extTypes.order[name + "-asc"],
          desc: _extTypes.order[name + "-desc"]
        },
        render: _extTypes.render[name],
        search: _extTypes.search[name]
      };
    }
    var setProp = function(prop2, propVal) {
      _extTypes[prop2][name] = propVal;
    };
    var setDetect = function(detect) {
      Object.defineProperty(detect, "_name", { value: name });
      var idx = _extTypes.detect.findIndex(function(item) {
        return item._name === name;
      });
      if (idx === -1) {
        _extTypes.detect.unshift(detect);
      } else {
        _extTypes.detect.splice(idx, 1, detect);
      }
    };
    var setOrder = function(obj) {
      _extTypes.order[name + "-pre"] = obj.pre;
      _extTypes.order[name + "-asc"] = obj.asc;
      _extTypes.order[name + "-desc"] = obj.desc;
    };
    if (val === void 0) {
      val = prop;
      prop = null;
    }
    if (prop === "className") {
      setProp("className", val);
    } else if (prop === "detect") {
      setDetect(val);
    } else if (prop === "order") {
      setOrder(val);
    } else if (prop === "render") {
      setProp("render", val);
    } else if (prop === "search") {
      setProp("search", val);
    } else if (!prop) {
      if (val.className) {
        setProp("className", val.className);
      }
      if (val.detect !== void 0) {
        setDetect(val.detect);
      }
      if (val.order) {
        setOrder(val.order);
      }
      if (val.render !== void 0) {
        setProp("render", val.render);
      }
      if (val.search !== void 0) {
        setProp("search", val.search);
      }
    }
  };
  DataTable.types = function() {
    return _extTypes.detect.map(function(fn) {
      return fn._name;
    });
  };
  var __diacriticSort = function(a, b) {
    a = a !== null && a !== void 0 ? a.toString().toLowerCase() : "";
    b = b !== null && b !== void 0 ? b.toString().toLowerCase() : "";
    return a.localeCompare(b, navigator.languages[0] || navigator.language, {
      numeric: true,
      ignorePunctuation: true
    });
  };
  DataTable.type("string", {
    detect: function() {
      return "string";
    },
    order: {
      pre: function(a) {
        return _empty(a) && typeof a !== "boolean" ? "" : typeof a === "string" ? a.toLowerCase() : !a.toString ? "" : a.toString();
      }
    },
    search: _filterString(false, true)
  });
  DataTable.type("string-utf8", {
    detect: {
      allOf: function(d) {
        return true;
      },
      oneOf: function(d) {
        return !_empty(d) && navigator.languages && typeof d === "string" && d.match(/[^\x00-\x7F]/);
      }
    },
    order: {
      asc: __diacriticSort,
      desc: function(a, b) {
        return __diacriticSort(a, b) * -1;
      }
    },
    search: _filterString(false, true)
  });
  DataTable.type("html", {
    detect: {
      allOf: function(d) {
        return _empty(d) || typeof d === "string" && d.indexOf("<") !== -1;
      },
      oneOf: function(d) {
        return !_empty(d) && typeof d === "string" && d.indexOf("<") !== -1;
      }
    },
    order: {
      pre: function(a) {
        return _empty(a) ? "" : a.replace ? _stripHtml(a).trim().toLowerCase() : a + "";
      }
    },
    search: _filterString(true, true)
  });
  DataTable.type("date", {
    className: "dt-type-date",
    detect: {
      allOf: function(d) {
        if (d && !(d instanceof Date) && !_re_date.test(d)) {
          return null;
        }
        var parsed = Date.parse(d);
        return parsed !== null && !isNaN(parsed) || _empty(d);
      },
      oneOf: function(d) {
        return d instanceof Date || typeof d === "string" && _re_date.test(d);
      }
    },
    order: {
      pre: function(d) {
        var ts = Date.parse(d);
        return isNaN(ts) ? -Infinity : ts;
      }
    }
  });
  DataTable.type("html-num-fmt", {
    className: "dt-type-numeric",
    detect: {
      allOf: function(d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _htmlNumeric(d, decimal, true, false);
      },
      oneOf: function(d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _htmlNumeric(d, decimal, true, false);
      }
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace(d, dp, _re_html, _re_formatted_numeric);
      }
    },
    search: _filterString(true, true)
  });
  DataTable.type("html-num", {
    className: "dt-type-numeric",
    detect: {
      allOf: function(d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _htmlNumeric(d, decimal, false, true);
      },
      oneOf: function(d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _htmlNumeric(d, decimal, false, false);
      }
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace(d, dp, _re_html);
      }
    },
    search: _filterString(true, true)
  });
  DataTable.type("num-fmt", {
    className: "dt-type-numeric",
    detect: {
      allOf: function(d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _isNumber(d, decimal, true, true);
      },
      oneOf: function(d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _isNumber(d, decimal, true, false);
      }
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace(d, dp, _re_formatted_numeric);
      }
    }
  });
  DataTable.type("num", {
    className: "dt-type-numeric",
    detect: {
      allOf: function(d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _isNumber(d, decimal, false, true);
      },
      oneOf: function(d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _isNumber(d, decimal, false, false);
      }
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace(d, dp);
      }
    }
  });
  var __numericReplace = function(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === "-")) {
      return -Infinity;
    }
    var type = typeof d;
    if (type === "number" || type === "bigint") {
      return d;
    }
    if (decimalPlace) {
      d = _numToDecimal(d, decimalPlace);
    }
    if (d.replace) {
      if (re1) {
        d = d.replace(re1, "");
      }
      if (re2) {
        d = d.replace(re2, "");
      }
    }
    return d * 1;
  };
  $.extend(true, DataTable.ext.renderer, {
    footer: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.tfoot.cell);
      }
    },
    header: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.thead.cell);
        if (!settings.oFeatures.bSort) {
          cell.addClass(classes.order.none);
        }
        var legacyTop = settings.bSortCellsTop;
        var headerRows = cell.closest("thead").find("tr");
        var rowIdx = cell.parent().index();
        if (
          // Cells and rows which have the attribute to disable the icons
          cell.attr("data-dt-order") === "disable" || cell.parent().attr("data-dt-order") === "disable" || // Legacy support for `orderCellsTop`. If it is set, then cells
          // which are not in the top or bottom row of the header (depending
          // on the value) do not get the sorting classes applied to them
          legacyTop === true && rowIdx !== 0 || legacyTop === false && rowIdx !== headerRows.length - 1
        ) {
          return;
        }
        $(settings.nTable).on("order.dt.DT column-visibility.dt.DT", function(e, ctx) {
          if (settings !== ctx) {
            return;
          }
          var sorting = ctx.sortDetails;
          if (!sorting) {
            return;
          }
          var i;
          var orderClasses = classes.order;
          var columns = ctx.api.columns(cell);
          var col = settings.aoColumns[columns.flatten()[0]];
          var orderable = columns.orderable().includes(true);
          var ariaType = "";
          var indexes = columns.indexes();
          var sortDirs = columns.orderable(true).flatten();
          var orderedColumns = _pluck(sorting, "col");
          cell.removeClass(
            orderClasses.isAsc + " " + orderClasses.isDesc
          ).toggleClass(orderClasses.none, !orderable).toggleClass(orderClasses.canAsc, orderable && sortDirs.includes("asc")).toggleClass(orderClasses.canDesc, orderable && sortDirs.includes("desc"));
          var isOrdering = true;
          for (i = 0; i < indexes.length; i++) {
            if (!orderedColumns.includes(indexes[i])) {
              isOrdering = false;
            }
          }
          if (isOrdering) {
            var orderDirs = columns.order();
            cell.addClass(
              orderDirs.includes("asc") ? orderClasses.isAsc : "" + orderDirs.includes("desc") ? orderClasses.isDesc : ""
            );
          }
          var firstVis = -1;
          for (i = 0; i < orderedColumns.length; i++) {
            if (settings.aoColumns[orderedColumns[i]].bVisible) {
              firstVis = orderedColumns[i];
              break;
            }
          }
          if (indexes[0] == firstVis) {
            var firstSort = sorting[0];
            var sortOrder = col.asSorting;
            cell.attr("aria-sort", firstSort.dir === "asc" ? "ascending" : "descending");
            ariaType = !sortOrder[firstSort.index + 1] ? "Remove" : "Reverse";
          } else {
            cell.removeAttr("aria-sort");
          }
          cell.attr(
            "aria-label",
            orderable ? col.ariaTitle + ctx.api.i18n("oAria.orderable" + ariaType) : col.ariaTitle
          );
          if (orderable) {
            cell.find(".dt-column-title").attr("role", "button");
            cell.attr("tabindex", 0);
          }
        });
      }
    },
    layout: {
      _: function(settings, container, items) {
        var classes = settings.oClasses.layout;
        var row = $("<div/>").attr("id", items.id || null).addClass(items.className || classes.row).appendTo(container);
        $.each(items, function(key, val) {
          if (key === "id" || key === "className") {
            return;
          }
          var klass = "";
          if (val.table) {
            row.addClass(classes.tableRow);
            klass += classes.tableCell + " ";
          }
          if (key === "start") {
            klass += classes.start;
          } else if (key === "end") {
            klass += classes.end;
          } else {
            klass += classes.full;
          }
          $("<div/>").attr({
            id: val.id || null,
            "class": val.className ? val.className : classes.cell + " " + klass
          }).append(val.contents).appendTo(row);
        });
      }
    }
  });
  DataTable.feature = {};
  DataTable.feature.register = function(name, cb, legacy) {
    DataTable.ext.features[name] = cb;
    if (legacy) {
      _ext.feature.push({
        cFeature: legacy,
        fnInit: cb
      });
    }
  };
  function _divProp(el, prop, val) {
    if (val) {
      el[prop] = val;
    }
  }
  DataTable.feature.register("div", function(settings, opts) {
    var n = $("<div>")[0];
    if (opts) {
      _divProp(n, "className", opts.className);
      _divProp(n, "id", opts.id);
      _divProp(n, "innerHTML", opts.html);
      _divProp(n, "textContent", opts.text);
    }
    return n;
  });
  DataTable.feature.register("info", function(settings, opts) {
    if (!settings.oFeatures.bInfo) {
      return null;
    }
    var lang = settings.oLanguage, tid = settings.sTableId, n = $("<div/>", {
      "class": settings.oClasses.info.container
    });
    opts = $.extend({
      callback: lang.fnInfoCallback,
      empty: lang.sInfoEmpty,
      postfix: lang.sInfoPostFix,
      search: lang.sInfoFiltered,
      text: lang.sInfo
    }, opts);
    settings.aoDrawCallback.push(function(s) {
      _fnUpdateInfo(s, opts, n);
    });
    if (!settings._infoEl) {
      n.attr({
        "aria-live": "polite",
        id: tid + "_info",
        role: "status"
      });
      $(settings.nTable).attr("aria-describedby", tid + "_info");
      settings._infoEl = n;
    }
    return n;
  }, "i");
  function _fnUpdateInfo(settings, opts, node) {
    var start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? opts.text : opts.empty;
    if (total !== max) {
      out += " " + opts.search;
    }
    out += opts.postfix;
    out = _fnMacros(settings, out);
    if (opts.callback) {
      out = opts.callback.call(
        settings.oInstance,
        settings,
        start,
        end,
        max,
        total,
        out
      );
    }
    node.html(out);
    _fnCallbackFire(settings, null, "info", [settings, node[0], out]);
  }
  var __searchCounter = 0;
  DataTable.feature.register("search", function(settings, opts) {
    if (!settings.oFeatures.bFilter) {
      return null;
    }
    var classes = settings.oClasses.search;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var input = '<input type="search" class="' + classes.input + '"/>';
    opts = $.extend({
      placeholder: language.sSearchPlaceholder,
      processing: false,
      text: language.sSearch
    }, opts);
    if (opts.text.indexOf("_INPUT_") === -1) {
      opts.text += "_INPUT_";
    }
    opts.text = _fnMacros(settings, opts.text);
    var end = opts.text.match(/_INPUT_$/);
    var start = opts.text.match(/^_INPUT_/);
    var removed = opts.text.replace(/_INPUT_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_INPUT_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_INPUT_";
    }
    var filter = $("<div>").addClass(classes.container).append(str.replace(/_INPUT_/, input));
    filter.find("label").attr("for", "dt-search-" + __searchCounter);
    filter.find("input").attr("id", "dt-search-" + __searchCounter);
    __searchCounter++;
    var searchFn = function(event) {
      var val = this.value;
      if (previousSearch.return && event.key !== "Enter") {
        return;
      }
      if (val != previousSearch.search) {
        _fnProcessingRun(settings, opts.processing, function() {
          previousSearch.search = val;
          _fnFilterComplete(settings, previousSearch);
          settings._iDisplayStart = 0;
          _fnDraw(settings);
        });
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : 0;
    var jqFilter = $("input", filter).val(previousSearch.search).attr("placeholder", opts.placeholder).on(
      "keyup.DT search.DT input.DT paste.DT cut.DT",
      searchDelay ? DataTable.util.debounce(searchFn, searchDelay) : searchFn
    ).on("mouseup.DT", function(e) {
      setTimeout(function() {
        searchFn.call(jqFilter[0], e);
      }, 10);
    }).on("keypress.DT", function(e) {
      if (e.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $(settings.nTable).on("search.dt.DT", function(ev, s) {
      if (settings === s && jqFilter[0] !== document.activeElement) {
        jqFilter.val(
          typeof previousSearch.search !== "function" ? previousSearch.search : ""
        );
      }
    });
    return filter;
  }, "f");
  DataTable.feature.register("paging", function(settings, opts) {
    if (!settings.oFeatures.bPaginate) {
      return null;
    }
    opts = $.extend({
      buttons: DataTable.ext.pager.numbers_length,
      type: settings.sPaginationType,
      boundaryNumbers: true,
      firstLast: true,
      previousNext: true,
      numbers: true
    }, opts);
    var host = $("<div/>").addClass(settings.oClasses.paging.container + (opts.type ? " paging_" + opts.type : "")).append(
      $("<nav>").attr("aria-label", "pagination").addClass(settings.oClasses.paging.nav)
    );
    var draw = function() {
      _pagingDraw(settings, host.children(), opts);
    };
    settings.aoDrawCallback.push(draw);
    $(settings.nTable).on("column-sizing.dt.DT", draw);
    return host;
  }, "p");
  function _pagingDynamic(opts) {
    var out = [];
    if (opts.numbers) {
      out.push("numbers");
    }
    if (opts.previousNext) {
      out.unshift("previous");
      out.push("next");
    }
    if (opts.firstLast) {
      out.unshift("first");
      out.push("last");
    }
    return out;
  }
  function _pagingDraw(settings, host, opts) {
    if (!settings._bInitComplete) {
      return;
    }
    var plugin = opts.type ? DataTable.ext.pager[opts.type] : _pagingDynamic, aria = settings.oLanguage.oAria.paginate || {}, start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = [], buttonEls = [], buttonsNested = plugin(opts).map(function(val) {
      return val === "numbers" ? _pagingNumbers(page, pages, opts.buttons, opts.boundaryNumbers) : val;
    });
    buttons = buttons.concat.apply(buttons, buttonsNested);
    for (var i = 0; i < buttons.length; i++) {
      var button = buttons[i];
      var btnInfo = _pagingButtonInfo(settings, button, page, pages);
      var btn = _fnRenderer(settings, "pagingButton")(
        settings,
        button,
        btnInfo.display,
        btnInfo.active,
        btnInfo.disabled
      );
      var ariaLabel = typeof button === "string" ? aria[button] : aria.number ? aria.number + (button + 1) : null;
      $(btn.clicker).attr({
        "aria-controls": settings.sTableId,
        "aria-disabled": btnInfo.disabled ? "true" : null,
        "aria-current": btnInfo.active ? "page" : null,
        "aria-label": ariaLabel,
        "data-dt-idx": button,
        "tabIndex": btnInfo.disabled ? -1 : settings.iTabIndex ? settings.iTabIndex : null
        // `0` doesn't need a tabIndex since it is the default
      });
      if (typeof button !== "number") {
        $(btn.clicker).addClass(button);
      }
      _fnBindAction(
        btn.clicker,
        { action: button },
        function(e) {
          e.preventDefault();
          _fnPageChange(settings, e.data.action, true);
        }
      );
      buttonEls.push(btn.display);
    }
    var wrapped = _fnRenderer(settings, "pagingContainer")(
      settings,
      buttonEls
    );
    var activeEl = host.find(document.activeElement).data("dt-idx");
    host.empty().append(wrapped);
    if (activeEl !== void 0) {
      host.find("[data-dt-idx=" + activeEl + "]").trigger("focus");
    }
    if (buttonEls.length && // any buttons
    opts.buttons > 1 && // prevent infinite
    $(host).height() >= $(buttonEls[0]).outerHeight() * 2 - 10) {
      _pagingDraw(settings, host, $.extend({}, opts, { buttons: opts.buttons - 2 }));
    }
  }
  function _pagingButtonInfo(settings, button, page, pages) {
    var lang = settings.oLanguage.oPaginate;
    var o = {
      display: "",
      active: false,
      disabled: false
    };
    switch (button) {
      case "ellipsis":
        o.display = "&#x2026;";
        o.disabled = true;
        break;
      case "first":
        o.display = lang.sFirst;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "previous":
        o.display = lang.sPrevious;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "next":
        o.display = lang.sNext;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      case "last":
        o.display = lang.sLast;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      default:
        if (typeof button === "number") {
          o.display = settings.fnFormatNumber(button + 1);
          if (page === button) {
            o.active = true;
          }
        }
        break;
    }
    return o;
  }
  function _pagingNumbers(page, pages, buttons, addFirstLast) {
    var numbers = [], half = Math.floor(buttons / 2), before = addFirstLast ? 2 : 1, after = addFirstLast ? 1 : 0;
    if (pages <= buttons) {
      numbers = _range(0, pages);
    } else if (buttons === 1) {
      numbers = [page];
    } else if (buttons === 3) {
      if (page <= 1) {
        numbers = [0, 1, "ellipsis"];
      } else if (page >= pages - 2) {
        numbers = _range(pages - 2, pages);
        numbers.unshift("ellipsis");
      } else {
        numbers = ["ellipsis", page, "ellipsis"];
      }
    } else if (page <= half) {
      numbers = _range(0, buttons - before);
      numbers.push("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
      }
    } else if (page >= pages - 1 - half) {
      numbers = _range(pages - (buttons - before), pages);
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.unshift(0);
      }
    } else {
      numbers = _range(page - half + before, page + half - after);
      numbers.push("ellipsis");
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
        numbers.unshift(0);
      }
    }
    return numbers;
  }
  var __lengthCounter = 0;
  DataTable.feature.register("pageLength", function(settings, opts) {
    var features = settings.oFeatures;
    if (!features.bPaginate || !features.bLengthChange) {
      return null;
    }
    opts = $.extend({
      menu: settings.aLengthMenu,
      text: settings.oLanguage.sLengthMenu
    }, opts);
    var classes = settings.oClasses.length, tableId = settings.sTableId, menu = opts.menu, lengths = [], language = [], i;
    if (Array.isArray(menu[0])) {
      lengths = menu[0];
      language = menu[1];
    } else {
      for (i = 0; i < menu.length; i++) {
        if ($.isPlainObject(menu[i])) {
          lengths.push(menu[i].value);
          language.push(menu[i].label);
        } else {
          lengths.push(menu[i]);
          language.push(menu[i]);
        }
      }
    }
    var end = opts.text.match(/_MENU_$/);
    var start = opts.text.match(/^_MENU_/);
    var removed = opts.text.replace(/_MENU_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_MENU_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_MENU_";
    }
    var tmpId = "tmp-" + +/* @__PURE__ */ new Date();
    var div = $("<div/>").addClass(classes.container).append(
      str.replace("_MENU_", '<span id="' + tmpId + '"></span>')
    );
    var textNodes = [];
    Array.from(div.find("label")[0].childNodes).forEach(function(el) {
      if (el.nodeType === Node.TEXT_NODE) {
        textNodes.push({
          el,
          text: el.textContent
        });
      }
    });
    var updateEntries = function(len) {
      textNodes.forEach(function(node) {
        node.el.textContent = _fnMacros(settings, node.text, len);
      });
    };
    var select = $("<select/>", {
      "name": tableId + "_length",
      "aria-controls": tableId,
      "class": classes.select
    });
    for (i = 0; i < lengths.length; i++) {
      select[0][i] = new Option(
        typeof language[i] === "number" ? settings.fnFormatNumber(language[i]) : language[i],
        lengths[i]
      );
    }
    div.find("label").attr("for", "dt-length-" + __lengthCounter);
    select.attr("id", "dt-length-" + __lengthCounter);
    __lengthCounter++;
    div.find("#" + tmpId).replaceWith(select);
    $("select", div).val(settings._iDisplayLength).on("change.DT", function() {
      _fnLengthChange(settings, $(this).val());
      _fnDraw(settings);
    });
    $(settings.nTable).on("length.dt.DT", function(e, s, len) {
      if (settings === s) {
        $("select", div).val(len);
        updateEntries(len);
      }
    });
    updateEntries(settings._iDisplayLength);
    return div;
  }, "l");
  $.fn.dataTable = DataTable;
  DataTable.$ = $;
  $.fn.dataTableSettings = DataTable.settings;
  $.fn.dataTableExt = DataTable.ext;
  $.fn.DataTable = function(opts) {
    return $(this).dataTable(opts).api();
  };
  $.each(DataTable, function(prop, val) {
    $.fn.DataTable[prop] = val;
  });
  var dataTables_default = DataTable;

  // node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs
  var $2 = import_jquery2.default;
  $2.extend(true, dataTables_default.defaults, {
    renderer: "bootstrap"
  });
  $2.extend(true, dataTables_default.ext.classes, {
    container: "dt-container dt-bootstrap5",
    search: {
      input: "form-control form-control-sm"
    },
    length: {
      select: "form-select form-select-sm"
    },
    processing: {
      container: "dt-processing card"
    },
    layout: {
      row: "row mt-2 justify-content-between",
      cell: "d-md-flex justify-content-between align-items-center",
      tableCell: "col-12",
      start: "dt-layout-start col-md-auto me-auto",
      end: "dt-layout-end col-md-auto ms-auto",
      full: "dt-layout-full col-md"
    }
  });
  dataTables_default.ext.renderer.pagingButton.bootstrap = function(settings, buttonType, content, active, disabled) {
    var btnClasses = ["dt-paging-button", "page-item"];
    if (active) {
      btnClasses.push("active");
    }
    if (disabled) {
      btnClasses.push("disabled");
    }
    var li = $2("<li>").addClass(btnClasses.join(" "));
    var a = $2("<button>", {
      "class": "page-link",
      role: "link",
      type: "button"
    }).html(content).appendTo(li);
    return {
      display: li,
      clicker: a
    };
  };
  dataTables_default.ext.renderer.pagingContainer.bootstrap = function(settings, buttonEls) {
    return $2("<ul/>").addClass("pagination").append(buttonEls);
  };
  var dataTables_bootstrap5_default = dataTables_default;

  // node_modules/datatables.net-fixedcolumns-bs5/js/fixedColumns.bootstrap5.mjs
  var import_jquery7 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-fixedcolumns-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs
  var import_jquery4 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-fixedcolumns-bs5/node_modules/datatables.net-bs5/node_modules/datatables.net/js/dataTables.mjs
  var import_jquery3 = __toESM(require_jquery(), 1);
  var $3 = import_jquery3.default;
  var DataTable2 = function(selector, options) {
    if (DataTable2.factory(selector, options)) {
      return DataTable2;
    }
    if (this instanceof DataTable2) {
      return $3(selector).DataTable(options);
    } else {
      options = selector;
    }
    var _that = this;
    var emptyInit = options === void 0;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.api = function() {
      return new _Api2(this);
    };
    this.each(function() {
      var o = {};
      var oInit = len > 1 ? (
        // optimisation for single table case
        _fnExtend2(o, options, true)
      ) : options;
      var i = 0, iLen;
      var sId = this.getAttribute("id");
      var bInitHandedOff = false;
      var defaults = DataTable2.defaults;
      var $this = $3(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog2(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      $3(this).trigger("options.dt", oInit);
      _fnCompatOpts2(defaults);
      _fnCompatCols2(defaults.column);
      _fnCamelToHungarian2(defaults, defaults, true);
      _fnCamelToHungarian2(defaults.column, defaults.column, true);
      _fnCamelToHungarian2(defaults, $3.extend(oInit, $this.data()), true);
      var allSettings = DataTable2.settings;
      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            new DataTable2.Api(s).destroy();
            break;
          } else {
            _fnLog2(s, 0, "Cannot reinitialise DataTable", 3);
            return;
          }
        }
        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable2.ext._unique++;
        this.id = sId;
      }
      var oSettings = $3.extend(true, {}, DataTable2.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId,
        colgroup: $3("<colgroup>").prependTo(this),
        fastData: function(row, column, type) {
          return _fnGetCellData2(oSettings, row, column, type);
        }
      });
      oSettings.nTable = this;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.api = new _Api2(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts2(oInit);
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : $3.isPlainObject(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0].value : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend2($3.extend(true, {}, defaults), oInit);
      _fnMap2(oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ]);
      _fnMap2(oSettings, oInit, [
        "ajax",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "iStateDuration",
        "bSortCellsTop",
        "iTabIndex",
        "sDom",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        "caption",
        "layout",
        ["iCookieDuration", "iStateDuration"],
        // backwards compat
        ["oSearch", "oPreviousSearch"],
        ["aoSearchCols", "aoPreSearchCols"],
        ["iDisplayLength", "_iDisplayLength"]
      ]);
      _fnMap2(oSettings.oScroll, oInit, [
        ["sScrollX", "sX"],
        ["sScrollXInner", "sXInner"],
        ["sScrollY", "sY"],
        ["bScrollCollapse", "bCollapse"]
      ]);
      _fnMap2(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg2(oSettings, "aoDrawCallback", oInit.fnDrawCallback);
      _fnCallbackReg2(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams);
      _fnCallbackReg2(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams);
      _fnCallbackReg2(oSettings, "aoStateLoaded", oInit.fnStateLoaded);
      _fnCallbackReg2(oSettings, "aoRowCallback", oInit.fnRowCallback);
      _fnCallbackReg2(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow);
      _fnCallbackReg2(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback);
      _fnCallbackReg2(oSettings, "aoFooterCallback", oInit.fnFooterCallback);
      _fnCallbackReg2(oSettings, "aoInitComplete", oInit.fnInitComplete);
      _fnCallbackReg2(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback);
      oSettings.rowIdFn = _fnGetObjectDataFn2(oInit.rowId);
      _fnBrowserDetect2(oSettings);
      var oClasses = oSettings.oClasses;
      $3.extend(oClasses, DataTable2.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.table);
      if (!oSettings.oFeatures.bPaginate) {
        oInit.iDisplayStart = 0;
      }
      if (oSettings.iInitDisplayStart === void 0) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      var oLanguage = oSettings.oLanguage;
      $3.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl) {
        $3.ajax({
          dataType: "json",
          url: oLanguage.sUrl,
          success: function(json) {
            _fnCamelToHungarian2(defaults.oLanguage, json);
            $3.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
            _fnCallbackFire2(oSettings, null, "i18n", [oSettings], true);
            _fnInitialise2(oSettings);
          },
          error: function() {
            _fnLog2(oSettings, 0, "i18n file loading error", 21);
            _fnInitialise2(oSettings);
          }
        });
        bInitHandedOff = true;
      } else {
        _fnCallbackFire2(oSettings, null, "i18n", [oSettings]);
      }
      var columnsInit = [];
      var thead = this.getElementsByTagName("thead");
      var initHeaderLayout = _fnDetectHeader2(oSettings, thead[0]);
      if (oInit.aoColumns) {
        columnsInit = oInit.aoColumns;
      } else if (initHeaderLayout.length) {
        for (i = 0, iLen = initHeaderLayout[0].length; i < iLen; i++) {
          columnsInit.push(null);
        }
      }
      for (i = 0, iLen = columnsInit.length; i < iLen; i++) {
        _fnAddColumn2(oSettings);
      }
      _fnApplyColumnDefs2(oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function(iCol, oDef) {
        _fnColumnOptions2(oSettings, iCol, oDef);
      });
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if (rowOne.length) {
        var a = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $3(rowOne[0]).children("th, td").each(function(i2, cell) {
          var col = oSettings.aoColumns[i2];
          if (!col) {
            _fnLog2(oSettings, 0, "Incorrect column count", 18);
          }
          if (col.mData === i2) {
            var sort = a(cell, "sort") || a(cell, "order");
            var filter = a(cell, "filter") || a(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {
                _: i2 + ".display",
                sort: sort !== null ? i2 + ".@data-" + sort : void 0,
                type: sort !== null ? i2 + ".@data-" + sort : void 0,
                filter: filter !== null ? i2 + ".@data-" + filter : void 0
              };
              col._isArrayHost = true;
              _fnColumnOptions2(oSettings, i2);
            }
          }
        });
      }
      var features = oSettings.oFeatures;
      var loadedInit = function() {
        if (oInit.aaSorting === void 0) {
          var sorting = oSettings.aaSorting;
          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        _fnSortingClasses2(oSettings);
        _fnCallbackReg2(oSettings, "aoDrawCallback", function() {
          if (oSettings.bSorted || _fnDataSource2(oSettings) === "ssp" || features.bDeferRender) {
            _fnSortingClasses2(oSettings);
          }
        });
        var caption = $this.children("caption");
        if (oSettings.caption) {
          if (caption.length === 0) {
            caption = $3("<caption/>").appendTo($this);
          }
          caption.html(oSettings.caption);
        }
        if (caption.length) {
          caption[0]._captionSide = caption.css("caption-side");
          oSettings.captionNode = caption[0];
        }
        if (thead.length === 0) {
          thead = $3("<thead/>").appendTo($this);
        }
        oSettings.nTHead = thead[0];
        $3("tr", thead).addClass(oClasses.thead.row);
        var tbody = $this.children("tbody");
        if (tbody.length === 0) {
          tbody = $3("<tbody/>").insertAfter(thead);
        }
        oSettings.nTBody = tbody[0];
        var tfoot = $this.children("tfoot");
        if (tfoot.length === 0) {
          tfoot = $3("<tfoot/>").appendTo($this);
        }
        oSettings.nTFoot = tfoot[0];
        $3("tr", tfoot).addClass(oClasses.tfoot.row);
        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData2(oSettings, oInit.aaData[i]);
          }
        } else if (_fnDataSource2(oSettings) == "dom") {
          _fnAddTr2(oSettings, $3(oSettings.nTBody).children("tr"));
        }
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        oSettings.bInitialised = true;
        if (bInitHandedOff === false) {
          _fnInitialise2(oSettings);
        }
      };
      _fnCallbackReg2(oSettings, "aoDrawCallback", _fnSaveState2);
      if (oInit.bStateSave) {
        features.bStateSave = true;
        _fnLoadState2(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  DataTable2.ext = _ext2 = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",
    /**
     * Legacy so v1 plug-ins don't throw js errors on load
     */
    feature: [],
    /**
     * Feature plug-ins.
     * 
     * This is an object of callbacks which provide the features for DataTables
     * to be initialised via the `layout` option.
     */
    features: {},
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Automatic column class assignment
       */
      className: {},
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
      /**
       * Automatic renderer assignment
       */
      render: {},
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatibility only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable2.fnVersionCheck,
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable2.version
  };
  $3.extend(_ext2, {
    afnFiltering: _ext2.search,
    aTypes: _ext2.type.detect,
    ofnSearch: _ext2.type.search,
    oSort: _ext2.type.order,
    afnSortData: _ext2.order,
    aoFeatures: _ext2.feature,
    oStdClasses: _ext2.classes,
    oPagination: _ext2.pager
  });
  $3.extend(DataTable2.ext.classes, {
    container: "dt-container",
    empty: {
      row: "dt-empty"
    },
    info: {
      container: "dt-info"
    },
    length: {
      container: "dt-length",
      select: "dt-input"
    },
    order: {
      canAsc: "dt-orderable-asc",
      canDesc: "dt-orderable-desc",
      isAsc: "dt-ordering-asc",
      isDesc: "dt-ordering-desc",
      none: "dt-orderable-none",
      position: "sorting_"
    },
    processing: {
      container: "dt-processing"
    },
    scrolling: {
      body: "dt-scroll-body",
      container: "dt-scroll",
      footer: {
        self: "dt-scroll-foot",
        inner: "dt-scroll-footInner"
      },
      header: {
        self: "dt-scroll-head",
        inner: "dt-scroll-headInner"
      }
    },
    search: {
      container: "dt-search",
      input: "dt-input"
    },
    table: "dataTable",
    tbody: {
      cell: "",
      row: ""
    },
    thead: {
      cell: "",
      row: ""
    },
    tfoot: {
      cell: "",
      row: ""
    },
    paging: {
      active: "current",
      button: "dt-paging-button",
      container: "dt-paging",
      disabled: "disabled"
    }
  });
  var _ext2;
  var _Api2;
  var _api_register2;
  var _api_registerPlural2;
  var _re_dic2 = {};
  var _re_new_lines2 = /[\r\n\u2028]/g;
  var _re_html2 = /<([^>]*>)/g;
  var _max_str_len2 = Math.pow(2, 28);
  var _re_date2 = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;
  var _re_escape_regex2 = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric2 = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty2 = function(d) {
    return !d || d === true || d === "-" ? true : false;
  };
  var _intVal2 = function(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  var _numToDecimal2 = function(num, decimalPoint) {
    if (!_re_dic2[decimalPoint]) {
      _re_dic2[decimalPoint] = new RegExp(_fnEscapeRegex2(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic2[decimalPoint], ".") : num;
  };
  var _isNumber2 = function(d, decimalPoint, formatted) {
    var type = typeof d;
    var strType = type === "string";
    if (type === "number" || type === "bigint") {
      return true;
    }
    if (_empty2(d)) {
      return true;
    }
    if (decimalPoint && strType) {
      d = _numToDecimal2(d, decimalPoint);
    }
    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric2, "");
    }
    return !isNaN(parseFloat(d)) && isFinite(d);
  };
  var _isHtml2 = function(d) {
    return _empty2(d) || typeof d === "string";
  };
  var _htmlNumeric2 = function(d, decimalPoint, formatted) {
    if (_empty2(d)) {
      return true;
    }
    if (typeof d === "string" && d.match(/<(input|select)/i)) {
      return null;
    }
    var html = _isHtml2(d);
    return !html ? null : _isNumber2(_stripHtml2(d), decimalPoint, formatted) ? true : null;
  };
  var _pluck2 = function(a, prop, prop2) {
    var out = [];
    var i = 0, ien = a.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order2 = function(a, order, prop, prop2) {
    var out = [];
    var i = 0, ien = order.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[order[i]]) {
          out.push(a[order[i]][prop]);
        }
      }
    }
    return out;
  };
  var _range2 = function(len, start) {
    var out = [];
    var end;
    if (start === void 0) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }
    for (var i = start; i < end; i++) {
      out.push(i);
    }
    return out;
  };
  var _removeEmpty2 = function(a) {
    var out = [];
    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        out.push(a[i]);
      }
    }
    return out;
  };
  var _stripHtml2 = function(input) {
    if (input.length > _max_str_len2) {
      throw new Error("Exceeded max str len");
    }
    var previous;
    input = input.replace(_re_html2, "");
    do {
      previous = input;
      input = input.replace(/<script/i, "");
    } while (input !== previous);
    return previous;
  };
  var _escapeHtml2 = function(d) {
    if (Array.isArray(d)) {
      d = d.join(",");
    }
    return typeof d === "string" ? d.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d;
  };
  var _normalize2 = function(str, both) {
    if (typeof str !== "string") {
      return str;
    }
    var res = str.normalize("NFD");
    return res.length !== str.length ? (both === true ? str + " " : "") + res.replace(/[\u0300-\u036f]/g, "") : res;
  };
  var _areAllUnique2 = function(src) {
    if (src.length < 2) {
      return true;
    }
    var sorted = src.slice().sort();
    var last = sorted[0];
    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }
      last = sorted[i];
    }
    return true;
  };
  var _unique2 = function(src) {
    if (Array.from && Set) {
      return Array.from(new Set(src));
    }
    if (_areAllUnique2(src)) {
      return src.slice();
    }
    var out = [], val, i, ien = src.length, j, k = 0;
    again: for (i = 0; i < ien; i++) {
      val = src[i];
      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }
      out.push(val);
      k++;
    }
    return out;
  };
  var _flatten2 = function(out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten2(out, val[i]);
      }
    } else {
      out.push(val);
    }
    return out;
  };
  function _addClass2(el, name) {
    if (name) {
      name.split(" ").forEach(function(n) {
        if (n) {
          el.classList.add(n);
        }
      });
    }
  }
  DataTable2.util = {
    /**
     * Return a string with diacritic characters decomposed
     * @param {*} mixed Function or string to normalize
     * @param {*} both Return original string and the normalized string
     * @returns String or undefined
     */
    diacritics: function(mixed, both) {
      var type = typeof mixed;
      if (type !== "function") {
        return _normalize2(mixed, both);
      }
      _normalize2 = mixed;
    },
    /**
     * Debounce a function
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    debounce: function(fn, timeout) {
      var timer;
      return function() {
        var that = this;
        var args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(that, args);
        }, timeout || 250);
      };
    },
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function(fn, freq) {
      var frequency = freq !== void 0 ? freq : 200, last, timer;
      return function() {
        var that = this, now = +/* @__PURE__ */ new Date(), args = arguments;
        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            last = void 0;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },
    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function(val) {
      return val.replace(_re_escape_regex2, "\\$1");
    },
    /**
     * Create a function that will write to a nested object or array
     * @param {*} source JSON notation string
     * @returns Write function
     */
    set: function(source) {
      if ($3.isPlainObject(source)) {
        return DataTable2.util.set(source._);
      } else if (source === null) {
        return function() {
        };
      } else if (typeof source === "function") {
        return function(data, val, meta) {
          source(data, "set", val, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var setData = function(data, val, src) {
          var a = _fnSplitObjNotation2(src), b;
          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;
          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            if (a[i] === "__proto__" || a[i] === "constructor") {
              throw new Error("Cannot set prototype values");
            }
            arrayNotation = a[i].match(__reArray2);
            funcNotation = a[i].match(__reFn2);
            if (arrayNotation) {
              a[i] = a[i].replace(__reArray2, "");
              data[a[i]] = [];
              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join(".");
              if (Array.isArray(val)) {
                for (var j = 0, jLen = val.length; j < jLen; j++) {
                  o = {};
                  setData(o, val[j], innerSrc);
                  data[a[i]].push(o);
                }
              } else {
                data[a[i]] = val;
              }
              return;
            } else if (funcNotation) {
              a[i] = a[i].replace(__reFn2, "");
              data = data[a[i]](val);
            }
            if (data[a[i]] === null || data[a[i]] === void 0) {
              data[a[i]] = {};
            }
            data = data[a[i]];
          }
          if (aLast.match(__reFn2)) {
            data = data[aLast.replace(__reFn2, "")](val);
          } else {
            data[aLast.replace(__reArray2, "")] = val;
          }
        };
        return function(data, val) {
          return setData(data, val, source);
        };
      } else {
        return function(data, val) {
          data[source] = val;
        };
      }
    },
    /**
     * Create a function that will read nested objects from arrays, based on JSON notation
     * @param {*} source JSON notation string
     * @returns Value read
     */
    get: function(source) {
      if ($3.isPlainObject(source)) {
        var o = {};
        $3.each(source, function(key, val) {
          if (val) {
            o[key] = DataTable2.util.get(val);
          }
        });
        return function(data, type, row, meta) {
          var t = o[type] || o._;
          return t !== void 0 ? t(data, type, row, meta) : data;
        };
      } else if (source === null) {
        return function(data) {
          return data;
        };
      } else if (typeof source === "function") {
        return function(data, type, row, meta) {
          return source(data, type, row, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var fetchData = function(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== "") {
            var a = _fnSplitObjNotation2(src);
            for (var i = 0, iLen = a.length; i < iLen; i++) {
              arrayNotation = a[i].match(__reArray2);
              funcNotation = a[i].match(__reFn2);
              if (arrayNotation) {
                a[i] = a[i].replace(__reArray2, "");
                if (a[i] !== "") {
                  data = data[a[i]];
                }
                out = [];
                a.splice(0, i + 1);
                innerSrc = a.join(".");
                if (Array.isArray(data)) {
                  for (var j = 0, jLen = data.length; j < jLen; j++) {
                    out.push(fetchData(data[j], type, innerSrc));
                  }
                }
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join);
                break;
              } else if (funcNotation) {
                a[i] = a[i].replace(__reFn2, "");
                data = data[a[i]]();
                continue;
              }
              if (data === null || data[a[i]] === null) {
                return null;
              } else if (data === void 0 || data[a[i]] === void 0) {
                return void 0;
              }
              data = data[a[i]];
            }
          }
          return data;
        };
        return function(data, type) {
          return fetchData(data, type, source);
        };
      } else {
        return function(data) {
          return data[source];
        };
      }
    },
    stripHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _stripHtml2 = mixed;
        return;
      } else if (type === "string") {
        return _stripHtml2(mixed);
      }
      return mixed;
    },
    escapeHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _escapeHtml2 = mixed;
        return;
      } else if (type === "string" || Array.isArray(mixed)) {
        return _escapeHtml2(mixed);
      }
      return mixed;
    },
    unique: _unique2
  };
  function _fnHungarianMap2(o) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map2 = {};
    $3.each(o, function(key) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map2[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap2(o[key]);
        }
      }
    });
    o._hungarianMap = map2;
  }
  function _fnCamelToHungarian2(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap2(src);
    }
    var hungarianKey;
    $3.each(user, function(key) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $3.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian2(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  var _fnCompatMap2 = function(o, knew, old) {
    if (o[knew] !== void 0) {
      o[old] = o[knew];
    }
  };
  function _fnCompatOpts2(init2) {
    _fnCompatMap2(init2, "ordering", "bSort");
    _fnCompatMap2(init2, "orderMulti", "bSortMulti");
    _fnCompatMap2(init2, "orderClasses", "bSortClasses");
    _fnCompatMap2(init2, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap2(init2, "order", "aaSorting");
    _fnCompatMap2(init2, "orderFixed", "aaSortingFixed");
    _fnCompatMap2(init2, "paging", "bPaginate");
    _fnCompatMap2(init2, "pagingType", "sPaginationType");
    _fnCompatMap2(init2, "pageLength", "iDisplayLength");
    _fnCompatMap2(init2, "searching", "bFilter");
    if (typeof init2.sScrollX === "boolean") {
      init2.sScrollX = init2.sScrollX ? "100%" : "";
    }
    if (typeof init2.scrollX === "boolean") {
      init2.scrollX = init2.scrollX ? "100%" : "";
    }
    var searchCols = init2.aoSearchCols;
    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian2(DataTable2.models.oSearch, searchCols[i]);
        }
      }
    }
    if (init2.serverSide && !init2.searchDelay) {
      init2.searchDelay = 400;
    }
  }
  function _fnCompatCols2(init2) {
    _fnCompatMap2(init2, "orderable", "bSortable");
    _fnCompatMap2(init2, "orderData", "aDataSort");
    _fnCompatMap2(init2, "orderSequence", "asSorting");
    _fnCompatMap2(init2, "orderDataType", "sortDataType");
    var dataSort = init2.aDataSort;
    if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
      init2.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect2(settings) {
    if (!DataTable2.__browser) {
      var browser = {};
      DataTable2.__browser = browser;
      var n = $3("<div/>").css({
        position: "fixed",
        top: 0,
        left: -1 * window.pageXOffset,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(
        $3("<div/>").css({
          position: "absolute",
          top: 1,
          left: 1,
          width: 100,
          overflow: "scroll"
        }).append(
          $3("<div/>").css({
            width: "100%",
            height: 10
          })
        )
      ).appendTo("body");
      var outer = n.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      n.remove();
    }
    $3.extend(settings.oBrowser, DataTable2.__browser);
    settings.oScroll.iBarWidth = DataTable2.__browser.barWidth;
  }
  function _fnAddColumn2(oSettings) {
    var oDefaults = DataTable2.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $3.extend({}, DataTable2.models.oColumn, oDefaults, {
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol,
      searchFixed: {},
      colEl: $3("<col>").attr("data-dt-column", iCol)
    });
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $3.extend({}, DataTable2.models.oSearch, searchCols[iCol]);
  }
  function _fnColumnOptions2(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    if (oOptions !== void 0 && oOptions !== null) {
      _fnCompatCols2(oOptions);
      _fnCamelToHungarian2(DataTable2.defaults.column, oOptions, true);
      if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      var origClass = oCol.sClass;
      $3.extend(oCol, oOptions);
      _fnMap2(oCol, oOptions, "sWidth", "sWidthOrig");
      if (origClass !== oCol.sClass) {
        oCol.sClass = origClass + " " + oCol.sClass;
      }
      if (oOptions.iDataSort !== void 0) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap2(oCol, oOptions, "aDataSort");
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn2(mDataSrc);
    if (oCol.mRender && Array.isArray(oCol.mRender)) {
      var copy = oCol.mRender.slice();
      var name = copy.shift();
      oCol.mRender = DataTable2.render[name].apply(window, copy);
    }
    oCol._render = oCol.mRender ? _fnGetObjectDataFn2(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $3.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, void 0, meta);
      return oCol._render && type ? oCol._render(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn2(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
    }
  }
  function _fnAdjustColumnSizing2(settings) {
    _fnCalculateColumnWidths2(settings);
    _fnColumnSizes2(settings);
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw2(settings);
    }
    _fnCallbackFire2(settings, null, "column-sizing", [settings]);
  }
  function _fnColumnSizes2(settings) {
    var cols = settings.aoColumns;
    for (var i = 0; i < cols.length; i++) {
      var width = _fnColumnsSumWidth2(settings, [i], false, false);
      cols[i].colEl.css("width", width);
    }
  }
  function _fnVisibleToColumnIndex2(oSettings, iMatch) {
    var aiVis = _fnGetColumns2(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible2(oSettings, iMatch) {
    var aiVis = _fnGetColumns2(oSettings, "bVisible");
    var iPos = aiVis.indexOf(iMatch);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns2(settings) {
    var layout = settings.aoHeader;
    var columns = settings.aoColumns;
    var vis = 0;
    if (layout.length) {
      for (var i = 0, ien = layout[0].length; i < ien; i++) {
        if (columns[i].bVisible && $3(layout[0][i].cell).css("display") !== "none") {
          vis++;
        }
      }
    }
    return vis;
  }
  function _fnGetColumns2(oSettings, sParam) {
    var a = [];
    oSettings.aoColumns.map(function(val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  function _fnColumnTypes2(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable2.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, detectedType, cache;
    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            if (!data[k]) {
              continue;
            }
            if (cache[k] === void 0) {
              cache[k] = _fnGetCellData2(settings, k, i, "type");
            }
            detectedType = types[j](cache[k], settings);
            if (!detectedType && j !== types.length - 2) {
              break;
            }
            if (detectedType === "html" && !_empty2(cache[k])) {
              break;
            }
          }
          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        if (!col.sType) {
          col.sType = "string";
        }
      }
      var autoClass = _ext2.type.className[col.sType];
      if (autoClass) {
        _columnAutoClass2(settings.aoHeader, i, autoClass);
        _columnAutoClass2(settings.aoFooter, i, autoClass);
      }
      var renderer = _ext2.type.render[col.sType];
      if (renderer && !col._render) {
        col._render = DataTable2.util.get(renderer);
        _columnAutoRender2(settings, i);
      }
    }
  }
  function _columnAutoRender2(settings, colIdx) {
    var data = settings.aoData;
    for (var i = 0; i < data.length; i++) {
      if (data[i].nTr) {
        var display = _fnGetCellData2(settings, i, colIdx, "display");
        data[i].displayData[colIdx] = display;
        _fnWriteCell2(data[i].anCells[colIdx], display);
      }
    }
  }
  function _columnAutoClass2(container, colIdx, className) {
    container.forEach(function(row) {
      if (row[colIdx] && row[colIdx].unique) {
        _addClass2(row[colIdx].cell, className);
      }
    });
  }
  function _fnApplyColumnDefs2(oSettings, aoColDefs, aoCols, headerLayout, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        if (aoCols[i] && aoCols[i].name) {
          columns[i].sName = aoCols[i].name;
        }
      }
    }
    if (aoColDefs) {
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        var aTargets = def.target !== void 0 ? def.target : def.targets !== void 0 ? def.targets : def.aTargets;
        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          var target = aTargets[j];
          if (typeof target === "number" && target >= 0) {
            while (columns.length <= target) {
              _fnAddColumn2(oSettings);
            }
            fn(target, def);
          } else if (typeof target === "number" && target < 0) {
            fn(columns.length + target, def);
          } else if (typeof target === "string") {
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (target === "_all") {
                fn(k, def);
              } else if (target.indexOf(":name") !== -1) {
                if (columns[k].sName === target.replace(":name", "")) {
                  fn(k, def);
                }
              } else {
                headerLayout.forEach(function(row) {
                  if (row[k]) {
                    var cell = $3(row[k].cell);
                    if (target.match(/^[a-z][\w-]*$/i)) {
                      target = "." + target;
                    }
                    if (cell.is(target)) {
                      fn(k, def);
                    }
                  }
                });
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  function _fnColumnsSumWidth2(settings, targets, original, incVisible) {
    if (!Array.isArray(targets)) {
      targets = _fnColumnsFromHeader2(targets);
    }
    var sum = 0;
    var unit;
    var columns = settings.aoColumns;
    for (var i = 0, ien = targets.length; i < ien; i++) {
      var column = columns[targets[i]];
      var definedWidth = original ? column.sWidthOrig : column.sWidth;
      if (!incVisible && column.bVisible === false) {
        continue;
      }
      if (definedWidth === null || definedWidth === void 0) {
        return null;
      } else if (typeof definedWidth === "number") {
        unit = "px";
        sum += definedWidth;
      } else {
        var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);
        if (matched) {
          sum += matched[1] * 1;
          unit = matched.length === 3 ? matched[2] : "px";
        }
      }
    }
    return sum + unit;
  }
  function _fnColumnsFromHeader2(cell) {
    var attr = $3(cell).closest("[data-dt-column]").attr("data-dt-column");
    if (!attr) {
      return [];
    }
    return attr.split(",").map(function(val) {
      return val * 1;
    });
  }
  function _fnAddData2(settings, dataIn, tr, tds) {
    var rowIdx = settings.aoData.length;
    var rowModel = $3.extend(true, {}, DataTable2.models.oRow, {
      src: tr ? "dom" : "data",
      idx: rowIdx
    });
    rowModel._aData = dataIn;
    settings.aoData.push(rowModel);
    var columns = settings.aoColumns;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    settings.aiDisplayMaster.push(rowIdx);
    var id = settings.rowIdFn(dataIn);
    if (id !== void 0) {
      settings.aIds[id] = rowModel;
    }
    if (tr || !settings.oFeatures.bDeferRender) {
      _fnCreateTr2(settings, rowIdx, tr, tds);
    }
    return rowIdx;
  }
  function _fnAddTr2(settings, trs) {
    var row;
    if (!(trs instanceof $3)) {
      trs = $3(trs);
    }
    return trs.map(function(i, el) {
      row = _fnGetRowElements2(settings, el);
      return _fnAddData2(settings, row.data, el, row.cells);
    });
  }
  function _fnGetCellData2(settings, rowIdx, colIdx, type) {
    if (type === "search") {
      type = "filter";
    } else if (type === "order") {
      type = "sort";
    }
    var row = settings.aoData[rowIdx];
    if (!row) {
      return void 0;
    }
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = row._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings,
      row: rowIdx,
      col: colIdx
    });
    if (type !== "display" && cellData && typeof cellData === "object" && cellData.nodeName) {
      cellData = cellData.innerHTML;
    }
    if (cellData === void 0) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog2(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
      cellData = defaultContent;
    } else if (typeof cellData === "function") {
      return cellData.call(rowData);
    }
    if (cellData === null && type === "display") {
      return "";
    }
    if (type === "filter") {
      var fomatters = DataTable2.ext.type.search;
      if (fomatters[col.sType]) {
        cellData = fomatters[col.sType](cellData);
      }
    }
    return cellData;
  }
  function _fnSetCellData2(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings,
      row: rowIdx,
      col: colIdx
    });
  }
  function _fnWriteCell2(td, val) {
    if (val && typeof val === "object" && val.nodeName) {
      $3(td).empty().append(val);
    } else {
      td.innerHTML = val;
    }
  }
  var __reArray2 = /\[.*?\]$/;
  var __reFn2 = /\(\)$/;
  function _fnSplitObjNotation2(str) {
    var parts = str.match(/(\\.|[^.])+/g) || [""];
    return parts.map(function(s) {
      return s.replace(/\\\./g, ".");
    });
  }
  var _fnGetObjectDataFn2 = DataTable2.util.get;
  var _fnSetObjectDataFn2 = DataTable2.util.set;
  function _fnGetDataMaster2(settings) {
    return _pluck2(settings.aoData, "_aData");
  }
  function _fnClearTable2(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnInvalidate2(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;
    row._aSortData = null;
    row._aFilterData = null;
    row.displayData = null;
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements2(
        settings,
        row,
        colIdx,
        colIdx === void 0 ? void 0 : row._aData
      ).data;
    } else {
      var cells = row.anCells;
      var display = _fnGetRowDisplay2(settings, rowIdx);
      if (cells) {
        if (colIdx !== void 0) {
          _fnWriteCell2(cells[colIdx], display[colIdx]);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            _fnWriteCell2(cells[i], display[i]);
          }
        }
      }
    }
    var cols = settings.aoColumns;
    if (colIdx !== void 0) {
      cols[colIdx].sType = null;
      cols[colIdx].maxLenString = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
        cols[i].maxLenString = null;
      }
      _fnRowAttributes2(settings, row);
    }
  }
  function _fnGetRowElements2(settings, row, colIdx, d) {
    var tds = [], td = row.firstChild, name, col, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d = d !== void 0 ? d : objectRead ? {} : [];
    var attr = function(str, td2) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr2 = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn2(str);
          setter(d, td2.getAttribute(attr2));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === void 0 || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn2(col.mData._);
          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn2(col.mData);
            }
            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }
      i++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn2(settings.rowId)(d, id);
      }
    }
    return {
      data: d,
      cells: tds
    };
  }
  function _fnGetRowDisplay2(settings, rowIdx) {
    let rowModal = settings.aoData[rowIdx];
    let columns = settings.aoColumns;
    if (!rowModal.displayData) {
      rowModal.displayData = [];
      for (var colIdx = 0, len = columns.length; colIdx < len; colIdx++) {
        rowModal.displayData.push(
          _fnGetCellData2(settings, rowIdx, colIdx, "display")
        );
      }
    }
    return rowModal.displayData;
  }
  function _fnCreateTr2(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create, trClass = oSettings.oClasses.tbody.row;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      _addClass2(nTr, trClass);
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes2(oSettings, row);
      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn && anTds[i] ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        if (!nTd) {
          _fnLog2(oSettings, 0, "Incorrect column count", 18);
        }
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd);
        var display = _fnGetRowDisplay2(oSettings, iRow);
        if (create || (oCol.mRender || oCol.mData !== i) && (!$3.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
          _fnWriteCell2(nTd, display[i]);
        }
        if (oCol.bVisible && create) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && !create) {
          nTd.parentNode.removeChild(nTd);
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(
            oSettings.oInstance,
            nTd,
            _fnGetCellData2(oSettings, iRow, i),
            rowData,
            iRow,
            i
          );
        }
      }
      _fnCallbackFire2(oSettings, "aoRowCreatedCallback", "row-created", [nTr, rowData, iRow, cells]);
    } else {
      _addClass2(row.nTr, trClass);
    }
  }
  function _fnRowAttributes2(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique2(row.__rowc.concat(a)) : a;
        $3(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $3(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $3(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead2(settings, side) {
    var classes = settings.oClasses;
    var columns = settings.aoColumns;
    var i, ien, row;
    var target = side === "header" ? settings.nTHead : settings.nTFoot;
    var titleProp = side === "header" ? "sTitle" : side;
    if (!target) {
      return;
    }
    if (side === "header" || _pluck2(settings.aoColumns, titleProp).join("")) {
      row = $3("tr", target);
      if (!row.length) {
        row = $3("<tr/>").appendTo(target);
      }
      if (row.length === 1) {
        var cells = $3("td, th", row);
        for (i = cells.length, ien = columns.length; i < ien; i++) {
          $3("<th/>").html(columns[i][titleProp] || "").appendTo(row);
        }
      }
    }
    var detected = _fnDetectHeader2(settings, target, true);
    if (side === "header") {
      settings.aoHeader = detected;
    } else {
      settings.aoFooter = detected;
    }
    $3(target).children("tr").attr("role", "row");
    $3(target).children("tr").children("th, td").each(function() {
      _fnRenderer2(settings, side)(
        settings,
        $3(this),
        classes
      );
    });
  }
  function _fnHeaderLayout2(settings, source, incColumns) {
    var row, column, cell;
    var local = [];
    var structure = [];
    var columns = settings.aoColumns;
    var columnCount = columns.length;
    var rowspan, colspan;
    if (!source) {
      return;
    }
    if (!incColumns) {
      incColumns = _range2(columnCount).filter(function(idx) {
        return columns[idx].bVisible;
      });
    }
    for (row = 0; row < source.length; row++) {
      local[row] = source[row].slice().filter(function(cell2, i) {
        return incColumns.includes(i);
      });
      structure.push([]);
    }
    for (row = 0; row < local.length; row++) {
      for (column = 0; column < local[row].length; column++) {
        rowspan = 1;
        colspan = 1;
        if (structure[row][column] === void 0) {
          cell = local[row][column].cell;
          while (local[row + rowspan] !== void 0 && local[row][column].cell == local[row + rowspan][column].cell) {
            structure[row + rowspan][column] = null;
            rowspan++;
          }
          while (local[row][column + colspan] !== void 0 && local[row][column].cell == local[row][column + colspan].cell) {
            for (var k = 0; k < rowspan; k++) {
              structure[row + k][column + colspan] = null;
            }
            colspan++;
          }
          var titleSpan = $3("span.dt-column-title", cell);
          structure[row][column] = {
            cell,
            colspan,
            rowspan,
            title: titleSpan.length ? titleSpan.html() : $3(cell).html()
          };
        }
      }
    }
    return structure;
  }
  function _fnDrawHead2(settings, source) {
    var layout = _fnHeaderLayout2(settings, source);
    var tr, n;
    for (var row = 0; row < source.length; row++) {
      tr = source[row].row;
      if (tr) {
        while (n = tr.firstChild) {
          tr.removeChild(n);
        }
      }
      for (var column = 0; column < layout[row].length; column++) {
        var point = layout[row][column];
        if (point) {
          $3(point.cell).appendTo(tr).attr("rowspan", point.rowspan).attr("colspan", point.colspan);
        }
      }
    }
  }
  function _fnDraw2(oSettings, ajaxComplete) {
    _fnStart2(oSettings);
    var aPreDraw = _fnCallbackFire2(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if (aPreDraw.indexOf(false) !== -1) {
      _fnProcessingDisplay2(oSettings, false);
      return;
    }
    var anRows = [];
    var iRowCount = 0;
    var bServerSide = _fnDataSource2(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    var columns = oSettings.aoColumns;
    var body = $3(oSettings.nTBody);
    oSettings.bDrawing = true;
    if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !ajaxComplete) {
      if (oSettings.iDraw === 0) {
        body.empty().append(_emptyRow2(oSettings));
      }
      _fnAjaxUpdate2(oSettings);
      return;
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr2(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        for (var i = 0; i < columns.length; i++) {
          var col = columns[i];
          var td = aoData.anCells[i];
          _addClass2(td, _ext2.type.className[col.sType]);
          _addClass2(td, col.sClass);
          _addClass2(td, oSettings.oClasses.tbody.cell);
        }
        _fnCallbackFire2(
          oSettings,
          "aoRowCallback",
          null,
          [nRow, aoData._aData, iRowCount, j, iDataIndex]
        );
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      anRows[0] = _emptyRow2(oSettings);
    }
    _fnCallbackFire2(oSettings, "aoHeaderCallback", "header", [
      $3(oSettings.nTHead).children("tr")[0],
      _fnGetDataMaster2(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    _fnCallbackFire2(oSettings, "aoFooterCallback", "footer", [
      $3(oSettings.nTFoot).children("tr")[0],
      _fnGetDataMaster2(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    if (body[0].replaceChildren) {
      body[0].replaceChildren.apply(body[0], anRows);
    } else {
      body.children().detach();
      body.append($3(anRows));
    }
    $3(oSettings.nTableWrapper).toggleClass("dt-empty-footer", $3("tr", oSettings.nTFoot).length === 0);
    _fnCallbackFire2(oSettings, "aoDrawCallback", "draw", [oSettings], true);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw2(settings, holdPosition, recompute) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (recompute === void 0 || recompute === true) {
      if (sort) {
        _fnSort2(settings);
      }
      if (filter) {
        _fnFilterComplete2(settings, settings.oPreviousSearch);
      } else {
        settings.aiDisplay = settings.aiDisplayMaster.slice();
      }
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw2(settings);
    settings._drawHold = false;
  }
  function _emptyRow2(settings) {
    var oLang = settings.oLanguage;
    var zero = oLang.sZeroRecords;
    var dataSrc = _fnDataSource2(settings);
    if (settings.iDraw < 1 && dataSrc === "ssp" || settings.iDraw <= 1 && dataSrc === "ajax") {
      zero = oLang.sLoadingRecords;
    } else if (oLang.sEmptyTable && settings.fnRecordsTotal() === 0) {
      zero = oLang.sEmptyTable;
    }
    return $3("<tr/>").append($3("<td />", {
      "colSpan": _fnVisbleColumns2(settings),
      "class": settings.oClasses.empty.row
    }).html(zero))[0];
  }
  function _layoutArray2(settings, layout, side) {
    var groups = {};
    $3.each(layout, function(pos, val) {
      if (val === null) {
        return;
      }
      var splitPos = pos.replace(/([A-Z])/g, " $1").split(" ");
      if (!groups[splitPos[0]]) {
        groups[splitPos[0]] = {};
      }
      var align = splitPos.length === 1 ? "full" : splitPos[1].toLowerCase();
      var group = groups[splitPos[0]];
      var groupRun = function(contents, innerVal) {
        if ($3.isPlainObject(innerVal)) {
          Object.keys(innerVal).map(function(key) {
            contents.push({
              feature: key,
              opts: innerVal[key]
            });
          });
        } else {
          contents.push(innerVal);
        }
      };
      if (!group[align] || !group[align].contents) {
        group[align] = { contents: [] };
      }
      if (Array.isArray(val)) {
        for (var i2 = 0; i2 < val.length; i2++) {
          groupRun(group[align].contents, val[i2]);
        }
      } else {
        groupRun(group[align].contents, val);
      }
      if (!Array.isArray(group[align].contents)) {
        group[align].contents = [group[align].contents];
      }
    });
    var filtered = Object.keys(groups).map(function(pos) {
      if (pos.indexOf(side) !== 0) {
        return null;
      }
      return {
        name: pos,
        val: groups[pos]
      };
    }).filter(function(item) {
      return item !== null;
    });
    filtered.sort(function(a, b) {
      var order1 = a.name.replace(/[^0-9]/g, "") * 1;
      var order2 = b.name.replace(/[^0-9]/g, "") * 1;
      return order2 - order1;
    });
    if (side === "bottom") {
      filtered.reverse();
    }
    var rows = [];
    for (var i = 0, ien = filtered.length; i < ien; i++) {
      if (filtered[i].val.full) {
        rows.push({ full: filtered[i].val.full });
        _layoutResolve2(settings, rows[rows.length - 1]);
        delete filtered[i].val.full;
      }
      if (Object.keys(filtered[i].val).length) {
        rows.push(filtered[i].val);
        _layoutResolve2(settings, rows[rows.length - 1]);
      }
    }
    return rows;
  }
  function _layoutResolve2(settings, row) {
    var getFeature = function(feature, opts) {
      if (!_ext2.features[feature]) {
        _fnLog2(settings, 0, "Unknown feature: " + feature);
      }
      return _ext2.features[feature].apply(this, [settings, opts]);
    };
    var resolve = function(item) {
      var line = row[item].contents;
      for (var i = 0, ien = line.length; i < ien; i++) {
        if (!line[i]) {
          continue;
        } else if (typeof line[i] === "string") {
          line[i] = getFeature(line[i], null);
        } else if ($3.isPlainObject(line[i])) {
          line[i] = getFeature(line[i].feature, line[i].opts);
        } else if (typeof line[i].node === "function") {
          line[i] = line[i].node(settings);
        } else if (typeof line[i] === "function") {
          var inst = line[i](settings);
          line[i] = typeof inst.node === "function" ? inst.node() : inst;
        }
      }
    };
    $3.each(row, function(key) {
      resolve(key);
    });
  }
  function _fnAddOptionsHtml2(settings) {
    var classes = settings.oClasses;
    var table = $3(settings.nTable);
    var insert = $3("<div/>").attr({
      id: settings.sTableId + "_wrapper",
      "class": classes.container
    }).insertBefore(table);
    settings.nTableWrapper = insert[0];
    if (settings.sDom) {
      _fnLayoutDom2(settings, settings.sDom, insert);
    } else {
      var top = _layoutArray2(settings, settings.layout, "top");
      var bottom = _layoutArray2(settings, settings.layout, "bottom");
      var renderer = _fnRenderer2(settings, "layout");
      top.forEach(function(item) {
        renderer(settings, insert, item);
      });
      renderer(settings, insert, {
        full: {
          table: true,
          contents: [_fnFeatureHtmlTable2(settings)]
        }
      });
      bottom.forEach(function(item) {
        renderer(settings, insert, item);
      });
    }
    _processingHtml2(settings);
  }
  function _fnLayoutDom2(settings, dom, insert) {
    var parts = dom.match(/(".*?")|('.*?')|./g);
    var featureNode, option, newNode, next, attr;
    for (var i = 0; i < parts.length; i++) {
      featureNode = null;
      option = parts[i];
      if (option == "<") {
        newNode = $3("<div/>");
        next = parts[i + 1];
        if (next[0] == "'" || next[0] == '"') {
          attr = next.replace(/['"]/g, "");
          var id = "", className;
          if (attr.indexOf(".") != -1) {
            var split = attr.split(".");
            id = split[0];
            className = split[1];
          } else if (attr[0] == "#") {
            id = attr;
          } else {
            className = attr;
          }
          newNode.attr("id", id.substring(1)).addClass(className);
          i++;
        }
        insert.append(newNode);
        insert = newNode;
      } else if (option == ">") {
        insert = insert.parent();
      } else if (option == "t") {
        featureNode = _fnFeatureHtmlTable2(settings);
      } else {
        DataTable2.ext.feature.forEach(function(feature) {
          if (option == feature.cFeature) {
            featureNode = feature.fnInit(settings);
          }
        });
      }
      if (featureNode) {
        insert.append(featureNode);
      }
    }
  }
  function _fnDetectHeader2(settings, thead, write) {
    var columns = settings.aoColumns;
    var rows = $3(thead).children("tr");
    var row, cell;
    var i, k, l, iLen, shifted, column, colspan, rowspan;
    var isHeader = thead && thead.nodeName.toLowerCase() === "thead";
    var layout = [];
    var unique;
    var shift = function(a, i2, j) {
      var k2 = a[i2];
      while (k2[j]) {
        j++;
      }
      return j;
    };
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      layout.push([]);
    }
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      row = rows[i];
      column = 0;
      cell = row.firstChild;
      while (cell) {
        if (cell.nodeName.toUpperCase() == "TD" || cell.nodeName.toUpperCase() == "TH") {
          var cols = [];
          colspan = cell.getAttribute("colspan") * 1;
          rowspan = cell.getAttribute("rowspan") * 1;
          colspan = !colspan || colspan === 0 || colspan === 1 ? 1 : colspan;
          rowspan = !rowspan || rowspan === 0 || rowspan === 1 ? 1 : rowspan;
          shifted = shift(layout, i, column);
          unique = colspan === 1 ? true : false;
          if (write) {
            if (unique) {
              _fnColumnOptions2(settings, shifted, $3(cell).data());
              var columnDef = columns[shifted];
              var width = cell.getAttribute("width") || null;
              var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
              if (t) {
                width = t[1];
              }
              columnDef.sWidthOrig = columnDef.sWidth || width;
              if (isHeader) {
                if (columnDef.sTitle !== null && !columnDef.autoTitle) {
                  cell.innerHTML = columnDef.sTitle;
                }
                if (!columnDef.sTitle && unique) {
                  columnDef.sTitle = _stripHtml2(cell.innerHTML);
                  columnDef.autoTitle = true;
                }
              } else {
                if (columnDef.footer) {
                  cell.innerHTML = columnDef.footer;
                }
              }
              if (!columnDef.ariaTitle) {
                columnDef.ariaTitle = $3(cell).attr("aria-label") || columnDef.sTitle;
              }
              if (columnDef.className) {
                $3(cell).addClass(columnDef.className);
              }
            }
            if ($3("span.dt-column-title", cell).length === 0) {
              $3("<span>").addClass("dt-column-title").append(cell.childNodes).appendTo(cell);
            }
            if (isHeader && $3("span.dt-column-order", cell).length === 0) {
              $3("<span>").addClass("dt-column-order").appendTo(cell);
            }
          }
          for (l = 0; l < colspan; l++) {
            for (k = 0; k < rowspan; k++) {
              layout[i + k][shifted + l] = {
                cell,
                unique
              };
              layout[i + k].row = row;
            }
            cols.push(shifted + l);
          }
          cell.setAttribute("data-dt-column", _unique2(cols).join(","));
        }
        cell = cell.nextSibling;
      }
    }
    return layout;
  }
  function _fnStart2(oSettings) {
    var bServerSide = _fnDataSource2(oSettings) == "ssp";
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
  }
  function _fnBuildAjax2(oSettings, data, fn) {
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
      if (json === null || typeof status === "number" && status == 204) {
        json = {};
        _fnAjaxDataSrc2(oSettings, json, []);
      }
      var error = json.error || json.sError;
      if (error) {
        _fnLog2(oSettings, 0, error);
      }
      oSettings.json = json;
      _fnCallbackFire2(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR], true);
      fn(json);
    };
    if ($3.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === "function" ? ajaxData(data, oSettings) : (
        // fn can manipulate data or return
        ajaxData
      );
      data = typeof ajaxData === "function" && newData ? newData : $3.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {
      "url": typeof ajax === "string" ? ajax : "",
      "data": data,
      "success": callback,
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function(xhr, error) {
        var ret = _fnCallbackFire2(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR], true);
        if (ret.indexOf(true) === -1) {
          if (error == "parsererror") {
            _fnLog2(oSettings, 0, "Invalid JSON response", 1);
          } else if (xhr.readyState === 4) {
            _fnLog2(oSettings, 0, "Ajax error", 7);
          }
        }
        _fnProcessingDisplay2(oSettings, false);
      }
    };
    if ($3.isPlainObject(ajax)) {
      $3.extend(baseAjax, ajax);
    }
    oSettings.oAjaxData = data;
    _fnCallbackFire2(oSettings, null, "preXhr", [oSettings, data, baseAjax], true);
    if (typeof ajax === "function") {
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else if (ajax.url === "") {
      var empty = {};
      DataTable2.util.set(ajax.dataSrc)(empty, []);
      callback(empty);
    } else {
      oSettings.jqXHR = $3.ajax(baseAjax);
      if (ajaxData) {
        ajax.data = ajaxData;
      }
    }
  }
  function _fnAjaxUpdate2(settings) {
    settings.iDraw++;
    _fnProcessingDisplay2(settings, true);
    _fnBuildAjax2(
      settings,
      _fnAjaxParameters2(settings),
      function(json) {
        _fnAjaxUpdateDraw2(settings, json);
      }
    );
  }
  function _fnAjaxParameters2(settings) {
    var columns = settings.aoColumns, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, colData = function(idx, prop) {
      return typeof columns[idx][prop] === "function" ? "function" : columns[idx][prop];
    };
    return {
      draw: settings.iDraw,
      columns: columns.map(function(column, i) {
        return {
          data: colData(i, "mData"),
          name: column.sName,
          searchable: column.bSearchable,
          orderable: column.bSortable,
          search: {
            value: preColSearch[i].search,
            regex: preColSearch[i].regex,
            fixed: Object.keys(column.searchFixed).map(function(name) {
              return {
                name,
                term: column.searchFixed[name].toString()
              };
            })
          }
        };
      }),
      order: _fnSortFlatten2(settings).map(function(val) {
        return {
          column: val.col,
          dir: val.dir,
          name: colData(val.col, "sName")
        };
      }),
      start: settings._iDisplayStart,
      length: features.bPaginate ? settings._iDisplayLength : -1,
      search: {
        value: preSearch.search,
        regex: preSearch.regex,
        fixed: Object.keys(settings.searchFixed).map(function(name) {
          return {
            name,
            term: settings.searchFixed[name].toString()
          };
        })
      }
    };
  }
  function _fnAjaxUpdateDraw2(settings, json) {
    var data = _fnAjaxDataSrc2(settings, json);
    var draw = _fnAjaxDataSrcParam2(settings, "draw", json);
    var recordsTotal = _fnAjaxDataSrcParam2(settings, "recordsTotal", json);
    var recordsFiltered = _fnAjaxDataSrcParam2(settings, "recordsFiltered", json);
    if (draw !== void 0) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    if (!data) {
      data = [];
    }
    _fnClearTable2(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData2(settings, data[i]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnDraw2(settings, true);
    _fnInitComplete2(settings);
    _fnProcessingDisplay2(settings, false);
  }
  function _fnAjaxDataSrc2(settings, json, write) {
    var dataProp = "data";
    if ($3.isPlainObject(settings.ajax) && settings.ajax.dataSrc !== void 0) {
      var dataSrc = settings.ajax.dataSrc;
      if (typeof dataSrc === "string" || typeof dataSrc === "function") {
        dataProp = dataSrc;
      } else if (dataSrc.data !== void 0) {
        dataProp = dataSrc.data;
      }
    }
    if (!write) {
      if (dataProp === "data") {
        return json.aaData || json[dataProp];
      }
      return dataProp !== "" ? _fnGetObjectDataFn2(dataProp)(json) : json;
    }
    _fnSetObjectDataFn2(dataProp)(json, write);
  }
  function _fnAjaxDataSrcParam2(settings, param, json) {
    var dataSrc = $3.isPlainObject(settings.ajax) ? settings.ajax.dataSrc : null;
    if (dataSrc && dataSrc[param]) {
      return _fnGetObjectDataFn2(dataSrc[param])(json);
    }
    var old = "";
    if (param === "draw") {
      old = "sEcho";
    } else if (param === "recordsTotal") {
      old = "iTotalRecords";
    } else if (param === "recordsFiltered") {
      old = "iTotalDisplayRecords";
    }
    return json[old] !== void 0 ? json[old] : json[param];
  }
  function _fnFilterComplete2(settings, input) {
    var columnsSearch = settings.aoPreSearchCols;
    _fnColumnTypes2(settings);
    if (_fnDataSource2(settings) != "ssp") {
      _fnFilterData2(settings);
      settings.aiDisplay = settings.aiDisplayMaster.slice();
      _fnFilter2(settings.aiDisplay, settings, input.search, input);
      $3.each(settings.searchFixed, function(name, term) {
        _fnFilter2(settings.aiDisplay, settings, term, {});
      });
      for (var i = 0; i < columnsSearch.length; i++) {
        var col = columnsSearch[i];
        _fnFilter2(
          settings.aiDisplay,
          settings,
          col.search,
          col,
          i
        );
        $3.each(settings.aoColumns[i].searchFixed, function(name, term) {
          _fnFilter2(settings.aiDisplay, settings, term, {}, i);
        });
      }
      _fnFilterCustom2(settings);
    }
    settings.bFiltered = true;
    _fnCallbackFire2(settings, null, "search", [settings]);
  }
  function _fnFilterCustom2(settings) {
    var filters = DataTable2.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = [];
      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];
        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      displayRows.push.apply(displayRows, rows);
    }
  }
  function _fnFilter2(searchRows, settings, input, options, column) {
    if (input === "") {
      return;
    }
    var i = 0;
    var searchFunc = typeof input === "function" ? input : null;
    var rpSearch = input instanceof RegExp ? input : searchFunc ? null : _fnFilterCreateSearch2(input, options);
    while (i < searchRows.length) {
      var row = settings.aoData[searchRows[i]];
      var data = column === void 0 ? row._sFilterRow : row._aFilterData[column];
      if (searchFunc && !searchFunc(data, row._aData, searchRows[i], column) || rpSearch && !rpSearch.test(data)) {
        searchRows.splice(i, 1);
        i--;
      }
      i++;
    }
  }
  function _fnFilterCreateSearch2(search, inOpts) {
    var not = [];
    var options = $3.extend({}, {
      boundary: false,
      caseInsensitive: true,
      exact: false,
      regex: false,
      smart: true
    }, inOpts);
    if (typeof search !== "string") {
      search = search.toString();
    }
    search = _normalize2(search);
    if (options.exact) {
      return new RegExp(
        "^" + _fnEscapeRegex2(search) + "$",
        options.caseInsensitive ? "i" : ""
      );
    }
    search = options.regex ? search : _fnEscapeRegex2(search);
    if (options.smart) {
      var parts = search.match(/!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""];
      var a = parts.map(function(word) {
        var negative = false;
        var m2;
        if (word.charAt(0) === "!") {
          negative = true;
          word = word.substring(1);
        }
        if (word.charAt(0) === '"') {
          m2 = word.match(/^"(.*)"$/);
          word = m2 ? m2[1] : word;
        } else if (word.charAt(0) === "\u201C") {
          m2 = word.match(/^\u201C(.*)\u201D$/);
          word = m2 ? m2[1] : word;
        }
        if (negative) {
          if (word.length > 1) {
            not.push("(?!" + word + ")");
          }
          word = "";
        }
        return word.replace(/"/g, "");
      });
      var match = not.length ? not.join("") : "";
      var boundary = options.boundary ? "\\b" : "";
      search = "^(?=.*?" + boundary + a.join(")(?=.*?" + boundary) + ")(" + match + ".)*$";
    }
    return new RegExp(search, options.caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex2 = DataTable2.util.escapeRegex;
  var __filter_div2 = $3("<div>")[0];
  var __filter_div_textContent2 = __filter_div2.textContent !== void 0;
  function _fnFilterData2(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var column;
    var j, jen, filterData, cellData, row;
    var wasInvalidated = false;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aFilterData) {
        filterData = [];
        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];
          if (column.bSearchable) {
            cellData = _fnGetCellData2(settings, rowIdx, j, "filter");
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div2.innerHTML = cellData;
            cellData = __filter_div_textContent2 ? __filter_div2.textContent : __filter_div2.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnInitialise2(settings) {
    var i, iAjaxStart = settings.iInitDisplayStart;
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise2(settings);
      }, 200);
      return;
    }
    _fnBuildHead2(settings, "header");
    _fnBuildHead2(settings, "footer");
    _fnDrawHead2(settings, settings.aoHeader);
    _fnDrawHead2(settings, settings.aoFooter);
    _fnAddOptionsHtml2(settings);
    _fnSortInit2(settings);
    _colGroup2(settings);
    _fnProcessingDisplay2(settings, true);
    _fnCallbackFire2(settings, null, "preInit", [settings], true);
    _fnReDraw2(settings);
    var dataSrc = _fnDataSource2(settings);
    if (dataSrc != "ssp") {
      if (dataSrc == "ajax") {
        _fnBuildAjax2(settings, {}, function(json) {
          var aData = _fnAjaxDataSrc2(settings, json);
          for (i = 0; i < aData.length; i++) {
            _fnAddData2(settings, aData[i]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw2(settings);
          _fnProcessingDisplay2(settings, false);
          _fnInitComplete2(settings);
        }, settings);
      } else {
        _fnInitComplete2(settings);
        _fnProcessingDisplay2(settings, false);
      }
    }
  }
  function _fnInitComplete2(settings) {
    if (settings._bInitComplete) {
      return;
    }
    var args = [settings, settings.json];
    settings._bInitComplete = true;
    _fnAdjustColumnSizing2(settings);
    _fnCallbackFire2(settings, null, "plugin-init", args, true);
    _fnCallbackFire2(settings, "aoInitComplete", "init", args, true);
  }
  function _fnLengthChange2(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow2(settings);
    _fnCallbackFire2(settings, null, "length", [settings, len]);
  }
  function _fnPageChange2(settings, action, redraw) {
    var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;
      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;
      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else if (action === "ellipsis") {
      return;
    } else {
      _fnLog2(settings, 0, "Unknown paging action: " + action, 5);
    }
    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;
    _fnCallbackFire2(settings, null, changed ? "page" : "page-nc", [settings]);
    if (changed && redraw) {
      _fnDraw2(settings);
    }
    return changed;
  }
  function _processingHtml2(settings) {
    var table = settings.nTable;
    if (settings.oFeatures.bProcessing) {
      var n = $3("<div/>", {
        "id": settings.sTableId + "_processing",
        "class": settings.oClasses.processing.container,
        "role": "status"
      }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>").insertBefore(table);
      $3(table).on("processing.dt.DT", function(e, s, show) {
        n.css("display", show ? "block" : "none");
      });
    }
  }
  function _fnProcessingDisplay2(settings, show) {
    _fnCallbackFire2(settings, null, "processing", [settings, show]);
  }
  function _fnFeatureHtmlTable2(settings) {
    var table = $3(settings.nTable);
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses.scrolling;
    var caption = settings.captionNode;
    var captionSide = caption ? caption._captionSide : null;
    var headerClone = $3(table[0].cloneNode(false));
    var footerClone = $3(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size = function(s) {
      return !s ? null : _fnStringToCss2(s);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $3(_div, { "class": classes.container }).append(
      $3(_div, { "class": classes.header.self }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: scrollX ? size(scrollX) : "100%"
      }).append(
        $3(_div, { "class": classes.header.inner }).css({
          "box-sizing": "content-box",
          width: scroll.sXInner || "100%"
        }).append(
          headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
            table.children("thead")
          )
        )
      )
    ).append(
      $3(_div, { "class": classes.body }).css({
        position: "relative",
        overflow: "auto",
        width: size(scrollX)
      }).append(table)
    );
    if (footer) {
      scroller.append(
        $3(_div, { "class": classes.footer.self }).css({
          overflow: "hidden",
          border: 0,
          width: scrollX ? size(scrollX) : "100%"
        }).append(
          $3(_div, { "class": classes.footer.inner }).append(
            footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
              table.children("tfoot")
            )
          )
        )
      );
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    $3(scrollBody).on("scroll.DT", function() {
      var scrollLeft = this.scrollLeft;
      scrollHead.scrollLeft = scrollLeft;
      if (footer) {
        scrollFoot.scrollLeft = scrollLeft;
      }
    });
    $3("th, td", scrollHead).on("focus", function() {
      var scrollLeft = scrollHead.scrollLeft;
      scrollBody.scrollLeft = scrollLeft;
      if (footer) {
        scrollBody.scrollLeft = scrollLeft;
      }
    });
    $3(scrollBody).css("max-height", scrollY);
    if (!scroll.bCollapse) {
      $3(scrollBody).css("height", scrollY);
    }
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push(_fnScrollDraw2);
    return scroller[0];
  }
  function _fnScrollDraw2(settings) {
    var scroll = settings.oScroll, barWidth = scroll.iBarWidth, divHeader = $3(settings.nScrollHead), divHeaderInner = divHeader.children("div"), divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $3(divBodyEl), divFooter = $3(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $3(settings.nTHead), table = $3(settings.nTable), footer = settings.nTFoot && $3("th, td", settings.nTFoot).length ? $3(settings.nTFoot) : null, browser = settings.oBrowser, headerCopy, footerCopy;
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing2(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    headerCopy = header.clone().prependTo(table);
    headerCopy.find("th, td").removeAttr("tabindex");
    headerCopy.find("[id]").removeAttr("id");
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerCopy.find("[id]").removeAttr("id");
    }
    if (settings.aiDisplay.length) {
      var colSizes = table.find("tbody tr").eq(0).find("th, td").map(function(vis) {
        return {
          idx: _fnVisibleToColumnIndex2(settings, vis),
          width: $3(this).outerWidth()
        };
      });
      for (var i = 0; i < colSizes.length; i++) {
        var colEl = settings.aoColumns[colSizes[i].idx].colEl[0];
        var colWidth = colEl.style.width.replace("px", "");
        if (colWidth !== colSizes[i].width) {
          colEl.style.width = colSizes[i].width + "px";
        }
      }
    }
    divHeaderTable.find("colgroup").remove();
    divHeaderTable.append(settings.colgroup.clone());
    if (footer) {
      divFooterTable.find("colgroup").remove();
      divFooterTable.append(settings.colgroup.clone());
    }
    $3("th, td", headerCopy).each(function() {
      $3(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
    });
    if (footer) {
      $3("th, td", footerCopy).each(function() {
        $3(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
      });
    }
    var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var paddingSide = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    var outerWidth = table.outerWidth();
    divHeaderTable.css("width", _fnStringToCss2(outerWidth));
    divHeaderInner.css("width", _fnStringToCss2(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    if (footer) {
      divFooterTable.css("width", _fnStringToCss2(outerWidth));
      divFooterInner.css("width", _fnStringToCss2(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    }
    table.children("colgroup").prependTo(table);
    divBody.trigger("scroll");
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnCalculateColumnWidths2(settings) {
    if (!settings.oFeatures.bAutoWidth) {
      return;
    }
    var table = settings.nTable, columns = settings.aoColumns, scroll = settings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, visibleColumns = _fnGetColumns2(settings, "bVisible"), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, i, column, columnIdx;
    var styleWidth = table.style.width;
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    _fnCallbackFire2(
      settings,
      null,
      "column-calc",
      { visible: visibleColumns },
      false
    );
    var tmpTable = $3(table.cloneNode()).css("visibility", "hidden").removeAttr("id");
    tmpTable.append("<tbody>");
    var tr = $3("<tr/>").appendTo(tmpTable.find("tbody"));
    tmpTable.append($3(settings.nTHead).clone()).append($3(settings.nTFoot).clone());
    tmpTable.find("tfoot th, tfoot td").css("width", "");
    tmpTable.find("thead th, thead td").each(function() {
      var width = _fnColumnsSumWidth2(settings, this, true, false);
      if (width) {
        this.style.width = width;
        if (scrollX) {
          $3(this).append($3("<div/>").css({
            width,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } else {
        this.style.width = "";
      }
    });
    for (i = 0; i < visibleColumns.length; i++) {
      columnIdx = visibleColumns[i];
      column = columns[columnIdx];
      var longest = _fnGetMaxLenString2(settings, columnIdx);
      var autoClass = _ext2.type.className[column.sType];
      var text = longest + column.sContentPadding;
      var insert = longest.indexOf("<") === -1 ? document.createTextNode(text) : text;
      $3("<td/>").addClass(autoClass).addClass(column.sClass).append(insert).appendTo(tr);
    }
    $3("[name]", tmpTable).removeAttr("name");
    var holder = $3("<div/>").css(
      scrollX || scrollY ? {
        position: "absolute",
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: "hidden"
      } : {}
    ).append(tmpTable).appendTo(tableContainer);
    if (scrollX && scrollXInner) {
      tmpTable.width(scrollXInner);
    } else if (scrollX) {
      tmpTable.css("width", "auto");
      tmpTable.removeAttr("width");
      if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
        tmpTable.width(tableContainer.clientWidth);
      }
    } else if (scrollY) {
      tmpTable.width(tableContainer.clientWidth);
    } else if (tableWidthAttr) {
      tmpTable.width(tableWidthAttr);
    }
    var total = 0;
    var bodyCells = tmpTable.find("tbody tr").eq(0).children();
    for (i = 0; i < visibleColumns.length; i++) {
      var bounding = bodyCells[i].getBoundingClientRect().width;
      total += bounding;
      columns[visibleColumns[i]].sWidth = _fnStringToCss2(bounding);
    }
    table.style.width = _fnStringToCss2(total);
    holder.remove();
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss2(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !settings._reszEvt) {
      var bindResize = function() {
        $3(window).on("resize.DT-" + settings.sInstance, DataTable2.util.throttle(function() {
          if (!settings.bDestroying) {
            _fnAdjustColumnSizing2(settings);
          }
        }));
      };
      bindResize();
      settings._reszEvt = true;
    }
  }
  function _fnGetMaxLenString2(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    if (!column.maxLenString) {
      var s, max = "", maxLen = -1;
      for (var i = 0, ien = settings.aiDisplayMaster.length; i < ien; i++) {
        var rowIdx = settings.aiDisplayMaster[i];
        var data = _fnGetRowDisplay2(settings, rowIdx)[colIdx];
        var cellString = data && typeof data === "object" && data.nodeType ? data.innerHTML : data + "";
        cellString = cellString.replace(/id=".*?"/g, "").replace(/name=".*?"/g, "");
        s = _stripHtml2(cellString).replace(/&nbsp;/g, " ");
        if (s.length > maxLen) {
          max = cellString;
          maxLen = s.length;
        }
      }
      column.maxLenString = max;
    }
    return column.maxLenString;
  }
  function _fnStringToCss2(s) {
    if (s === null) {
      return "0px";
    }
    if (typeof s == "number") {
      return s < 0 ? "0px" : s + "px";
    }
    return s.match(/\d$/) ? s + "px" : s;
  }
  function _colGroup2(settings) {
    var cols = settings.aoColumns;
    settings.colgroup.empty();
    for (i = 0; i < cols.length; i++) {
      if (cols[i].bVisible) {
        settings.colgroup.append(cols[i].colEl);
      }
    }
  }
  function _fnSortInit2(settings) {
    var target = settings.nTHead;
    var headerRows = target.querySelectorAll("tr");
    var legacyTop = settings.bSortCellsTop;
    var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
    if (legacyTop === true) {
      target = headerRows[0];
    } else if (legacyTop === false) {
      target = headerRows[headerRows.length - 1];
    }
    _fnSortAttachListener2(
      settings,
      target,
      target === settings.nTHead ? "tr" + notSelector + " th" + notSelector + ", tr" + notSelector + " td" + notSelector : "th" + notSelector + ", td" + notSelector
    );
    var order = [];
    _fnSortResolve2(settings, order, settings.aaSorting);
    settings.aaSorting = order;
  }
  function _fnSortAttachListener2(settings, node, selector, column, callback) {
    _fnBindAction2(node, selector, function(e) {
      var run = false;
      var columns = column === void 0 ? _fnColumnsFromHeader2(e.target) : [column];
      if (columns.length) {
        for (var i = 0, ien = columns.length; i < ien; i++) {
          var ret = _fnSortAdd2(settings, columns[i], i, e.shiftKey);
          if (ret !== false) {
            run = true;
          }
          if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === "") {
            break;
          }
        }
        if (run) {
          _fnProcessingDisplay2(settings, true);
          setTimeout(function() {
            _fnSort2(settings);
            _fnSortDisplay2(settings, settings.aiDisplay);
            _fnProcessingDisplay2(settings, false);
            _fnReDraw2(settings, false, false);
            if (callback) {
              callback();
            }
          }, 0);
        }
      }
    });
  }
  function _fnSortDisplay2(settings, display) {
    var master = settings.aiDisplayMaster;
    var masterMap = {};
    var map2 = {};
    var i;
    for (i = 0; i < master.length; i++) {
      masterMap[master[i]] = i;
    }
    for (i = 0; i < display.length; i++) {
      map2[display[i]] = masterMap[display[i]];
    }
    display.sort(function(a, b) {
      return map2[a] - map2[b];
    });
  }
  function _fnSortResolve2(settings, nestedSort, sort) {
    var push = function(a) {
      if ($3.isPlainObject(a)) {
        if (a.idx !== void 0) {
          nestedSort.push([a.idx, a.dir]);
        } else if (a.name) {
          var cols = _pluck2(settings.aoColumns, "sName");
          var idx = cols.indexOf(a.name);
          if (idx !== -1) {
            nestedSort.push([idx, a.dir]);
          }
        }
      } else {
        nestedSort.push(a);
      }
    };
    if ($3.isPlainObject(sort)) {
      push(sort);
    } else if (sort.length && typeof sort[0] === "number") {
      push(sort);
    } else if (sort.length) {
      for (var z = 0; z < sort.length; z++) {
        push(sort[z]);
      }
    }
  }
  function _fnSortFlatten2(settings) {
    var i, k, kLen, aSort = [], extSort = DataTable2.ext.type.order, aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $3.isPlainObject(fixed), nestedSort = [];
    if (!settings.oFeatures.bSort) {
      return aSort;
    }
    if (Array.isArray(fixed)) {
      _fnSortResolve2(settings, nestedSort, fixed);
    }
    if (fixedObj && fixed.pre) {
      _fnSortResolve2(settings, nestedSort, fixed.pre);
    }
    _fnSortResolve2(settings, nestedSort, settings.aaSorting);
    if (fixedObj && fixed.post) {
      _fnSortResolve2(settings, nestedSort, fixed.post);
    }
    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      if (aoColumns[srcCol]) {
        aDataSort = aoColumns[srcCol].aDataSort;
        for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
          iCol = aDataSort[k];
          sType = aoColumns[iCol].sType || "string";
          if (nestedSort[i]._idx === void 0) {
            nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
          }
          if (nestedSort[i][1]) {
            aSort.push({
              src: srcCol,
              col: iCol,
              dir: nestedSort[i][1],
              index: nestedSort[i]._idx,
              type: sType,
              formatter: extSort[sType + "-pre"],
              sorter: extSort[sType + "-" + nestedSort[i][1]]
            });
          }
        }
      }
    }
    return aSort;
  }
  function _fnSort2(oSettings, col, dir) {
    var i, ien, iLen, aiOrig = [], extSort = DataTable2.ext.type.order, aoData = oSettings.aoData, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    _fnColumnTypes2(oSettings);
    if (col !== void 0) {
      var srcCol = oSettings.aoColumns[col];
      aSort = [{
        src: col,
        col,
        dir,
        index: 0,
        type: srcCol.sType,
        formatter: extSort[srcCol.sType + "-pre"],
        sorter: extSort[srcCol.sType + "-" + dir]
      }];
      displayMaster = displayMaster.slice();
    } else {
      aSort = _fnSortFlatten2(oSettings);
    }
    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i];
      _fnSortData2(oSettings, sortCol.col);
    }
    if (_fnDataSource2(oSettings) != "ssp" && aSort.length !== 0) {
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[i] = i;
      }
      if (aSort.length && aSort[0].dir === "desc") {
        aiOrig.reverse();
      }
      displayMaster.sort(function(a, b) {
        var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
        for (k = 0; k < len; k++) {
          sort = aSort[k];
          x = dataA[sort.col];
          y = dataB[sort.col];
          if (sort.sorter) {
            test = sort.sorter(x, y);
            if (test !== 0) {
              return test;
            }
          } else {
            test = x < y ? -1 : x > y ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
        }
        x = aiOrig[a];
        y = aiOrig[b];
        return x < y ? -1 : x > y ? 1 : 0;
      });
    } else if (aSort.length === 0) {
      displayMaster.sort(function(x, y) {
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    if (col === void 0) {
      oSettings.bSorted = true;
      _fnCallbackFire2(oSettings, null, "order", [oSettings, aSort]);
    }
    return displayMaster;
  }
  function _fnSortAdd2(settings, colIdx, addIndex, shift) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a, overflow) {
      var idx = a._idx;
      if (idx === void 0) {
        idx = asSorting.indexOf(a[1]);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (!col.bSortable) {
      return false;
    }
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if ((shift || addIndex) && settings.oFeatures.bSortMulti) {
      var sortIdx = _pluck2(sorting, "0").indexOf(colIdx);
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else if (shift) {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      } else {
        sorting.push([colIdx, sorting[0][1], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    }
  }
  function _fnSortingClasses2(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.order.position;
    var sort = _fnSortFlatten2(settings);
    var features = settings.oFeatures;
    var i, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src;
        $3(_pluck2(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      }
      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $3(_pluck2(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData2(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    var customSort = DataTable2.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(
        settings.oInstance,
        settings,
        colIdx,
        _fnColumnIndexToVisible2(settings, colIdx)
      );
    }
    var row, cellData;
    var formatter = DataTable2.ext.type.order[column.sType + "-pre"];
    var data = settings.aoData;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[colIdx] || customSort) {
        cellData = customSort ? customData[rowIdx] : (
          // If there was a custom sort function, use data from there
          _fnGetCellData2(settings, rowIdx, colIdx, "sort")
        );
        row._aSortData[colIdx] = formatter ? formatter(cellData, settings) : cellData;
      }
    }
  }
  function _fnSaveState2(settings) {
    if (settings._bLoadingState) {
      return;
    }
    var state = {
      time: +/* @__PURE__ */ new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $3.extend(true, [], settings.aaSorting),
      search: $3.extend({}, settings.oPreviousSearch),
      columns: settings.aoColumns.map(function(col, i) {
        return {
          visible: col.bVisible,
          search: $3.extend({}, settings.aoPreSearchCols[i])
        };
      })
    };
    settings.oSavedState = state;
    _fnCallbackFire2(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
  }
  function _fnLoadState2(settings, init2, callback) {
    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }
    var loaded = function(state2) {
      _fnImplementState2(settings, state2, callback);
    };
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
    if (state !== void 0) {
      _fnImplementState2(settings, state, callback);
    }
    return true;
  }
  function _fnImplementState2(settings, s, callback) {
    var i, ien;
    var columns = settings.aoColumns;
    settings._bLoadingState = true;
    var api = settings._bInitComplete ? new DataTable2.Api(settings) : null;
    if (!s || !s.time) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && s.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var abStateLoad = _fnCallbackFire2(settings, "aoStateLoadParams", "stateLoadParams", [settings, s]);
    if (abStateLoad.indexOf(false) !== -1) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    if (s.columns && columns.length !== s.columns.length) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    settings.oLoadedState = $3.extend(true, {}, s);
    _fnCallbackFire2(settings, null, "stateLoadInit", [settings, s], true);
    if (s.length !== void 0) {
      if (api) {
        api.page.len(s.length);
      } else {
        settings._iDisplayLength = s.length;
      }
    }
    if (s.start !== void 0) {
      if (api === null) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      } else {
        _fnPageChange2(settings, s.start / settings._iDisplayLength);
      }
    }
    if (s.order !== void 0) {
      settings.aaSorting = [];
      $3.each(s.order, function(i2, col2) {
        settings.aaSorting.push(
          col2[0] >= columns.length ? [0, col2[1]] : col2
        );
      });
    }
    if (s.search !== void 0) {
      $3.extend(settings.oPreviousSearch, s.search);
    }
    if (s.columns) {
      for (i = 0, ien = s.columns.length; i < ien; i++) {
        var col = s.columns[i];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i).visible(col.visible, false);
          } else {
            columns[i].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $3.extend(settings.aoPreSearchCols[i], col.search);
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
    settings._bLoadingState = false;
    _fnCallbackFire2(settings, "aoStateLoaded", "stateLoaded", [settings, s]);
    callback();
  }
  function _fnLog2(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable2.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire2(settings, null, "dt-error", [settings, tn, msg], true);
      }
      if (type == "alert") {
        alert(msg);
      } else if (type == "throw") {
        throw new Error(msg);
      } else if (typeof type == "function") {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  function _fnMap2(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $3.each(name, function(i, val) {
        if (Array.isArray(val)) {
          _fnMap2(ret, src, val[0], val[1]);
        } else {
          _fnMap2(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === void 0) {
      mappedName = name;
    }
    if (src[name] !== void 0) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend2(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, prop)) {
        val = extender[prop];
        if ($3.isPlainObject(val)) {
          if (!$3.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $3.extend(true, out[prop], val);
        } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }
    return out;
  }
  function _fnBindAction2(n, selector, fn) {
    $3(n).on("click.DT", selector, function(e) {
      fn(e);
    }).on("keypress.DT", selector, function(e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on("selectstart.DT", selector, function() {
      return false;
    });
  }
  function _fnCallbackReg2(settings, store, fn) {
    if (fn) {
      settings[store].push(fn);
    }
  }
  function _fnCallbackFire2(settings, callbackArr, eventName, args, bubbles) {
    var ret = [];
    if (callbackArr) {
      ret = settings[callbackArr].slice().reverse().map(function(val) {
        return val.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e = $3.Event(eventName + ".dt");
      var table = $3(settings.nTable);
      e.dt = settings.api;
      table[bubbles ? "trigger" : "triggerHandler"](e, args);
      if (bubbles && table.parents("body").length === 0) {
        $3("body").trigger(e, args);
      }
      ret.push(e.result);
    }
    return ret;
  }
  function _fnLengthOverflow2(settings) {
    var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start >= end) {
      start = end - len;
    }
    start -= start % len;
    if (len === -1 || start < 0) {
      start = 0;
    }
    settings._iDisplayStart = start;
  }
  function _fnRenderer2(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable2.ext.renderer[type];
    if ($3.isPlainObject(renderer) && renderer[type]) {
      return host[renderer[type]] || host._;
    } else if (typeof renderer === "string") {
      return host[renderer] || host._;
    }
    return host._;
  }
  function _fnDataSource2(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else if (settings.ajax) {
      return "ajax";
    }
    return "dom";
  }
  function _fnMacros2(settings, str, entries) {
    var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), max = settings.fnRecordsTotal(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, max)).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len))).replace(/_ENTRIES_/g, settings.api.i18n("entries", "", entries)).replace(/_ENTRIES-MAX_/g, settings.api.i18n("entries", "", max)).replace(/_ENTRIES-TOTAL_/g, settings.api.i18n("entries", "", vis));
  }
  var __apiStruct2 = [];
  var __arrayProto2 = Array.prototype;
  var _toSettings2 = function(mixed) {
    var idx, jq;
    var settings = DataTable2.settings;
    var tables = _pluck2(settings, "nTable");
    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oFeatures) {
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
      idx = tables.indexOf(mixed);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === "function") {
      return mixed.settings().toArray();
    } else if (typeof mixed === "string") {
      jq = $3(mixed).get();
    } else if (mixed instanceof $3) {
      jq = mixed.get();
    }
    if (jq) {
      return settings.filter(function(v, idx2) {
        return jq.includes(tables[idx2]);
      });
    }
  };
  _Api2 = function(context, data) {
    if (!(this instanceof _Api2)) {
      return new _Api2(context, data);
    }
    var settings = [];
    var ctxSettings = function(o) {
      var a = _toSettings2(o);
      if (a) {
        settings.push.apply(settings, a);
      }
    };
    if (Array.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = settings.length > 1 ? _unique2(settings) : settings;
    if (data) {
      this.push.apply(this, data);
    }
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
    _Api2.extend(this, this, __apiStruct2);
  };
  DataTable2.Api = _Api2;
  $3.extend(_Api2.prototype, {
    any: function() {
      return this.count() !== 0;
    },
    context: [],
    // array of table settings objects
    count: function() {
      return this.flatten().length;
    },
    each: function(fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }
      return this;
    },
    eq: function(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api2(ctx[idx], this[idx]) : null;
    },
    filter: function(fn) {
      var a = __arrayProto2.filter.call(this, fn, this);
      return new _Api2(this.context, a);
    },
    flatten: function() {
      var a = [];
      return new _Api2(this.context, a.concat.apply(a, this.toArray()));
    },
    get: function(idx) {
      return this[idx];
    },
    join: __arrayProto2.join,
    includes: function(find) {
      return this.indexOf(find) === -1 ? false : true;
    },
    indexOf: __arrayProto2.indexOf,
    iterator: function(flatten, type, fn, alwaysNew) {
      var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
      if (typeof flatten === "string") {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }
      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api2(context[i]);
        if (type === "table") {
          ret = fn.call(apiInst, context[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "columns" || type === "rows") {
          ret = fn.call(apiInst, context[i], this[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "every" || type === "column" || type === "column-rows" || type === "row" || type === "cell") {
          items = this[i];
          if (type === "column-rows") {
            rows = _selector_row_indexes2(context[i], selector.opts);
          }
          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];
            if (type === "cell") {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }
            if (ret !== void 0) {
              a.push(ret);
            }
          }
        }
      }
      if (a.length || alwaysNew) {
        var api = new _Api2(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
    lastIndexOf: __arrayProto2.lastIndexOf,
    length: 0,
    map: function(fn) {
      var a = __arrayProto2.map.call(this, fn, this);
      return new _Api2(this.context, a);
    },
    pluck: function(prop) {
      var fn = DataTable2.util.get(prop);
      return this.map(function(el) {
        return fn(el);
      });
    },
    pop: __arrayProto2.pop,
    push: __arrayProto2.push,
    reduce: __arrayProto2.reduce,
    reduceRight: __arrayProto2.reduceRight,
    reverse: __arrayProto2.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto2.shift,
    slice: function() {
      return new _Api2(this.context, this);
    },
    sort: __arrayProto2.sort,
    splice: __arrayProto2.splice,
    toArray: function() {
      return __arrayProto2.slice.call(this);
    },
    to$: function() {
      return $3(this);
    },
    toJQuery: function() {
      return $3(this);
    },
    unique: function() {
      return new _Api2(this.context, _unique2(this.toArray()));
    },
    unshift: __arrayProto2.unshift
  });
  function _api_scope2(scope, fn, struc) {
    return function() {
      var ret = fn.apply(scope || this, arguments);
      _Api2.extend(ret, ret, struc.methodExt);
      return ret;
    };
  }
  function _api_find2(src, name) {
    for (var i = 0, ien = src.length; i < ien; i++) {
      if (src[i].name === name) {
        return src[i];
      }
    }
    return null;
  }
  window.__apiStruct = __apiStruct2;
  _Api2.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api2) && !obj.__dt_wrapper) {
      return;
    }
    var i, ien, struct;
    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i];
      if (struct.name === "__proto__") {
        continue;
      }
      obj[struct.name] = struct.type === "function" ? _api_scope2(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api2.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api2.register = _api_register2 = function(name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api2.register(name[j], val);
      }
      return;
    }
    var i, ien, heir = name.split("."), struct = __apiStruct2, key, method;
    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf("()") !== -1;
      key = method ? heir[i].replace("()", "") : heir[i];
      var src = _api_find2(struct, key);
      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: "object"
        };
        struct.push(src);
      }
      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === "function" ? "function" : $3.isPlainObject(val) ? "object" : "other";
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api2.registerPlural = _api_registerPlural2 = function(pluralName, singularName, val) {
    _Api2.register(pluralName, val);
    _Api2.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else if (ret instanceof _Api2) {
        return ret.length ? Array.isArray(ret[0]) ? new _Api2(ret.context, ret[0]) : (
          // Array results are 'enhanced'
          ret[0]
        ) : void 0;
      }
      return ret;
    });
  };
  var __table_selector2 = function(selector, a) {
    if (Array.isArray(selector)) {
      var result = [];
      selector.forEach(function(sel) {
        var inner = __table_selector2(sel, a);
        result.push.apply(result, inner);
      });
      return result.filter(function(item) {
        return item;
      });
    }
    if (typeof selector === "number") {
      return [a[selector]];
    }
    var nodes = a.map(function(el) {
      return el.nTable;
    });
    return $3(nodes).filter(selector).map(function() {
      var idx = nodes.indexOf(this);
      return a[idx];
    }).toArray();
  };
  _api_register2("tables()", function(selector) {
    return selector !== void 0 && selector !== null ? new _Api2(__table_selector2(selector, this.context)) : this;
  });
  _api_register2("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api2(ctx[0]) : tables;
  });
  [
    ["nodes", "node", "nTable"],
    ["body", "body", "nTBody"],
    ["header", "header", "nTHead"],
    ["footer", "footer", "nTFoot"]
  ].forEach(function(item) {
    _api_registerPlural2(
      "tables()." + item[0] + "()",
      "table()." + item[1] + "()",
      function() {
        return this.iterator("table", function(ctx) {
          return ctx[item[2]];
        }, 1);
      }
    );
  });
  [
    ["header", "aoHeader"],
    ["footer", "aoFooter"]
  ].forEach(function(item) {
    _api_register2("table()." + item[0] + ".structure()", function(selector) {
      var indexes = this.columns(selector).indexes().flatten();
      var ctx = this.context[0];
      return _fnHeaderLayout2(ctx, ctx[item[1]], indexes);
    });
  });
  _api_registerPlural2("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register2("tables().every()", function(fn) {
    var that = this;
    return this.iterator("table", function(s, i) {
      fn.call(that.table(i), i);
    });
  });
  _api_register2("caption()", function(value, side) {
    var context = this.context;
    if (value === void 0) {
      var caption = context[0].captionNode;
      return caption && context.length ? caption.innerHTML : null;
    }
    return this.iterator("table", function(ctx) {
      var table = $3(ctx.nTable);
      var caption2 = $3(ctx.captionNode);
      var container = $3(ctx.nTableWrapper);
      if (!caption2.length) {
        caption2 = $3("<caption/>").html(value);
        ctx.captionNode = caption2[0];
        if (!side) {
          table.prepend(caption2);
          side = caption2.css("caption-side");
        }
      }
      caption2.html(value);
      if (side) {
        caption2.css("caption-side", side);
        caption2[0]._captionSide = side;
      }
      if (container.find("div.dataTables_scroll").length) {
        var selector = side === "top" ? "Head" : "Foot";
        container.find("div.dataTables_scroll" + selector + " table").prepend(caption2);
      } else {
        table.prepend(caption2);
      }
    }, 1);
  });
  _api_register2("caption.node()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].captionNode : null;
  });
  _api_register2("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw2(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw2(settings, paging === false);
      }
    });
  });
  _api_register2("page()", function(action) {
    if (action === void 0) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange2(settings, action);
    });
  });
  _api_register2("page.info()", function() {
    if (this.context.length === 0) {
      return void 0;
    }
    var settings = this.context[0], start = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource2(settings) === "ssp"
    };
  });
  _api_register2("page.len()", function(len) {
    if (len === void 0) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange2(settings, len);
    });
  });
  var __reload2 = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api2(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource2(settings) == "ssp") {
      _fnReDraw2(settings, holdPosition);
    } else {
      _fnProcessingDisplay2(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax2(settings, {}, function(json) {
        _fnClearTable2(settings);
        var data = _fnAjaxDataSrc2(settings, json);
        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData2(settings, data[i]);
        }
        _fnReDraw2(settings, holdPosition);
        _fnInitComplete2(settings);
        _fnProcessingDisplay2(settings, false);
      });
    }
  };
  _api_register2("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register2("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register2("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload2(settings, resetPaging === false, callback);
    });
  });
  _api_register2("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === void 0) {
      if (ctx.length === 0) {
        return void 0;
      }
      ctx = ctx[0];
      return $3.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax;
    }
    return this.iterator("table", function(settings) {
      if ($3.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register2("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload2(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run2 = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
      selector = [selector];
    }
    for (i = 0, ien = selector.length; i < ien; i++) {
      a = selector[i] && selector[i].split && !selector[i].match(/[[(:]/) ? selector[i].split(",") : [selector[i]];
      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === "string" ? a[j].trim() : a[j]);
        res = res.filter(function(item) {
          return item !== null && item !== void 0;
        });
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext2.selector[type];
    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }
    return _unique2(out);
  };
  var _selector_opts2 = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === void 0) {
      opts.search = opts.filter;
    }
    return $3.extend({
      search: "none",
      order: "current",
      page: "all"
    }, opts);
  };
  var _selector_first2 = function(old) {
    let inst = new _Api2(old.context[0]);
    if (old.length) {
      inst.push(old[0]);
    }
    inst.selector = old.selector;
    if (inst.length && inst[0].length > 1) {
      inst[0].splice(1);
    }
    return inst;
  };
  var _selector_row_indexes2 = function(settings, opts) {
    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order = opts.order, page = opts.page;
    if (page == "current") {
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == "current" || order == "applied") {
      if (search == "none") {
        a = displayMaster.slice();
      } else if (search == "applied") {
        a = displayFiltered.slice();
      } else if (search == "removed") {
        var displayFilteredMap = {};
        for (i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }
        displayMaster.forEach(function(item) {
          if (!Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
            a.push(item);
          }
        });
      }
    } else if (order == "index" || order == "original") {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (!settings.aoData[i]) {
          continue;
        }
        if (search == "none") {
          a.push(i);
        } else {
          tmp = displayFiltered.indexOf(i);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(i);
          }
        }
      }
    } else if (typeof order === "number") {
      var ordered = _fnSort2(settings, order, "asc");
      if (search === "none") {
        a = ordered;
      } else {
        for (i = 0; i < ordered.length; i++) {
          tmp = displayFiltered.indexOf(ordered[i]);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(ordered[i]);
          }
        }
      }
    }
    return a;
  };
  var __row_selector2 = function(settings, selector, opts) {
    var rows;
    var run = function(sel) {
      var selInt = _intVal2(sel);
      var aoData = settings.aoData;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      if (!rows) {
        rows = _selector_row_indexes2(settings, opts);
      }
      if (selInt !== null && rows.indexOf(selInt) !== -1) {
        return [selInt];
      } else if (sel === null || sel === void 0 || sel === "") {
        return rows;
      }
      if (typeof sel === "function") {
        return rows.map(function(idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex;
        var cellIdx = sel._DT_CellIndex;
        if (rowIdx !== void 0) {
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $3(sel).closest("*[data-dt-row]");
          return host.length ? [host.data("dt-row")] : [];
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== void 0) {
          return [rowObj.idx];
        }
      }
      var nodes = _removeEmpty2(
        _pluck_order2(settings.aoData, rows, "nTr")
      );
      return $3(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    var matched = _selector_run2("row", selector, run, settings, opts);
    if (opts.order === "current" || opts.order === "applied") {
      _fnSortDisplay2(settings, matched);
    }
    return matched;
  };
  _api_register2("rows()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($3.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts2(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector2(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register2("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || void 0;
    }, 1);
  });
  _api_register2("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order2(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural2("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r = settings.aoData[row];
      return type === "search" ? r._aFilterData : r._aSortData;
    }, 1);
  });
  _api_registerPlural2("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate2(settings, row, src);
    });
  });
  _api_registerPlural2("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural2("rows().ids()", "row().id()", function(hash) {
    var a = [];
    var context = this.context;
    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? "#" : "") + id);
      }
    }
    return new _Api2(context, a);
  });
  _api_registerPlural2("rows().remove()", "row().remove()", function() {
    this.iterator("row", function(settings, row) {
      var data = settings.aoData;
      var rowData = data[row];
      var idx = settings.aiDisplayMaster.indexOf(row);
      if (idx !== -1) {
        settings.aiDisplayMaster.splice(idx, 1);
      }
      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      }
      _fnLengthOverflow2(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== void 0) {
        delete settings.aIds[id];
      }
      data[row] = null;
    });
    return this;
  });
  _api_register2("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i, ien;
      var out = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr2(settings, row)[0]);
        } else {
          out.push(_fnAddData2(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    modRows.push.apply(modRows, newRows);
    return modRows;
  });
  _api_register2("row()", function(selector, opts) {
    return _selector_first2(this.rows(selector, opts));
  });
  _api_register2("row().data()", function(data) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]]._aData : void 0;
    }
    var row = ctx[0].aoData[this[0]];
    row._aData = data;
    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn2(ctx[0].rowId)(data, row.nTr.id);
    }
    _fnInvalidate2(ctx[0], this[0], "data");
    return this;
  });
  _api_register2("row().node()", function() {
    var ctx = this.context;
    return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]].nTr || null : null;
  });
  _api_register2("row.add()", function(row) {
    if (row instanceof $3 && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr2(settings, row)[0];
      }
      return _fnAddData2(settings, row);
    });
    return this.row(rows[0]);
  });
  $3(document).on("plugin-init.dt", function(e, context) {
    var api = new _Api2(context);
    api.on("stateSaveParams.DT", function(e2, settings, d) {
      var idFn = settings.rowIdFn;
      var rows = settings.aiDisplayMaster;
      var ids = [];
      for (var i = 0; i < rows.length; i++) {
        var rowIdx = rows[i];
        var data = settings.aoData[rowIdx];
        if (data._detailsShow) {
          ids.push("#" + idFn(data._aData));
        }
      }
      d.childRows = ids;
    });
    api.on("stateLoaded.DT", function(e2, settings, state) {
      __details_state_load2(api, state);
    });
    __details_state_load2(api, api.state.loaded());
  });
  var __details_state_load2 = function(api, state) {
    if (state && state.childRows) {
      api.rows(state.childRows.map(function(id) {
        return id.replace(/(?<!\\):/g, "\\:");
      })).every(function() {
        _fnCallbackFire2(api.settings()[0], null, "requestChild", [this]);
      });
    }
  };
  var __details_add2 = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r, k) {
      if (Array.isArray(r) || r instanceof $3) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }
        return;
      }
      if (r.nodeName && r.nodeName.toLowerCase() === "tr") {
        r.setAttribute("data-dt-row", row.idx);
        rows.push(r);
      } else {
        var created = $3("<tr><td></td></tr>").attr("data-dt-row", row.idx).addClass(k);
        $3("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns2(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.detach();
    }
    row._details = $3(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_state2 = DataTable2.util.throttle(
    function(ctx) {
      _fnSaveState2(ctx[0]);
    },
    500
  );
  var __details_remove2 = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = void 0;
        row._details = void 0;
        $3(row.nTr).removeClass("dt-hasChild");
        __details_state2(ctx);
      }
    }
  };
  var __details_display2 = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
          $3(row.nTr).addClass("dt-hasChild");
        } else {
          row._details.detach();
          $3(row.nTr).removeClass("dt-hasChild");
        }
        _fnCallbackFire2(ctx[0], null, "childRow", [show, api.row(api[0])]);
        __details_events2(ctx[0]);
        __details_state2(ctx);
      }
    }
  };
  var __details_events2 = function(settings) {
    var api = new _Api2(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-sizing" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck2(data, "_details").length > 0) {
      api.on(drawEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({ page: "current" }).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns2(ctx);
        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];
          if (row && row._details) {
            row._details.each(function() {
              var el = $3(this).children("td");
              if (el.length == 1) {
                el.attr("colspan", visible);
              }
            });
          }
        }
      });
      api.on(destroyEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i] && data[i]._details) {
            __details_remove2(api, i);
          }
        }
      });
    }
  };
  var _emp2 = "";
  var _child_obj2 = _emp2 + "row().child";
  var _child_mth2 = _child_obj2 + "()";
  _api_register2(_child_mth2, function(data, klass) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && ctx[0].aoData[this[0]] ? ctx[0].aoData[this[0]]._details : void 0;
    } else if (data === true) {
      this.child.show();
    } else if (data === false) {
      __details_remove2(this);
    } else if (ctx.length && this.length) {
      __details_add2(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }
    return this;
  });
  _api_register2([
    _child_obj2 + ".show()",
    _child_mth2 + ".show()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display2(this, true);
    return this;
  });
  _api_register2([
    _child_obj2 + ".hide()",
    _child_mth2 + ".hide()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display2(this, false);
    return this;
  });
  _api_register2([
    _child_obj2 + ".remove()",
    _child_mth2 + ".remove()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_remove2(this);
    return this;
  });
  _api_register2(_child_obj2 + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector2 = /^([^:]+):(name|title|visIdx|visible)$/;
  var __columnData2 = function(settings, column, r1, r2, rows, type) {
    var a = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData2(settings, rows[row], column, type));
    }
    return a;
  };
  var __column_header2 = function(settings, column, row) {
    var header = settings.aoHeader;
    var target = row !== void 0 ? row : settings.bSortCellsTop ? 0 : header.length - 1;
    return header[target][column].cell;
  };
  var __column_selector2 = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck2(columns, "sName"), titles = _pluck2(columns, "sTitle"), cells = DataTable2.util.get("[].[].cell")(settings.aoHeader), nodes = _unique2(_flatten2([], cells));
    var run = function(s) {
      var selInt = _intVal2(s);
      if (s === "") {
        return _range2(columns.length);
      }
      if (selInt !== null) {
        return [
          selInt >= 0 ? selInt : (
            // Count from left
            columns.length + selInt
          )
          // Count from right (+ because its a negative value)
        ];
      }
      if (typeof s === "function") {
        var rows = _selector_row_indexes2(settings, opts);
        return columns.map(function(col, idx2) {
          return s(
            idx2,
            __columnData2(settings, idx2, 0, 0, rows),
            __column_header2(settings, idx2)
          ) ? idx2 : null;
        });
      }
      var match = typeof s === "string" ? s.match(__re_column_selector2) : "";
      if (match) {
        switch (match[2]) {
          case "visIdx":
          case "visible":
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = columns.map(function(col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex2(settings, idx)];
          case "name":
            return names.map(function(name, i) {
              return name === match[1] ? i : null;
            });
          case "title":
            return titles.map(function(title, i) {
              return title === match[1] ? i : null;
            });
          default:
            return [];
        }
      }
      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      }
      var jqResult = $3(nodes).filter(s).map(function() {
        return _fnColumnsFromHeader2(this);
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      var host = $3(s).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run2("column", selector, run, settings, opts);
  };
  var __setColumnVis2 = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, cells, i, ien, tr;
    if (vis === void 0) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return false;
    }
    if (vis) {
      var insertBefore = _pluck2(cols, "bVisible").indexOf(true, column + 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        if (data[i]) {
          tr = data[i].nTr;
          cells = data[i].anCells;
          if (tr) {
            tr.insertBefore(cells[column], cells[insertBefore] || null);
          }
        }
      }
    } else {
      $3(_pluck2(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
    _colGroup2(settings);
    return true;
  };
  _api_register2("columns()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($3.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts2(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector2(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural2("columns().header()", "column().header()", function(row) {
    return this.iterator("column", function(settings, column) {
      return __column_header2(settings, column, row);
    }, 1);
  });
  _api_registerPlural2("columns().footer()", "column().footer()", function(row) {
    return this.iterator("column", function(settings, column) {
      var footer = settings.aoFooter;
      if (!footer.length) {
        return null;
      }
      return settings.aoFooter[row !== void 0 ? row : 0][column].cell;
    }, 1);
  });
  _api_registerPlural2("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData2, 1);
  });
  _api_registerPlural2("columns().render()", "column().render()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return __columnData2(settings, column, i, j, rows, type);
    }, 1);
  });
  _api_registerPlural2("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural2("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order2(
        settings.aoData,
        rows,
        type === "search" ? "_aFilterData" : "_aSortData",
        column
      );
    }, 1);
  });
  _api_registerPlural2("columns().init()", "column().init()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column];
    }, 1);
  });
  _api_registerPlural2("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order2(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural2("columns().titles()", "column().title()", function(title, row) {
    return this.iterator("column", function(settings, column) {
      if (typeof title === "number") {
        row = title;
        title = void 0;
      }
      var span = $3("span.dt-column-title", this.column(column).header(row));
      if (title !== void 0) {
        span.html(title);
        return this;
      }
      return span.html();
    }, 1);
  });
  _api_registerPlural2("columns().types()", "column().type()", function() {
    return this.iterator("column", function(settings, column) {
      var type = settings.aoColumns[column].sType;
      if (!type) {
        _fnColumnTypes2(settings);
      }
      return type;
    }, 1);
  });
  _api_registerPlural2("columns().visible()", "column().visible()", function(vis, calc) {
    var that = this;
    var changed = [];
    var ret = this.iterator("column", function(settings, column) {
      if (vis === void 0) {
        return settings.aoColumns[column].bVisible;
      }
      if (__setColumnVis2(settings, column, vis)) {
        changed.push(column);
      }
    });
    if (vis !== void 0) {
      this.iterator("table", function(settings) {
        _fnDrawHead2(settings, settings.aoHeader);
        _fnDrawHead2(settings, settings.aoFooter);
        if (!settings.aiDisplay.length) {
          $3(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns2(settings));
        }
        _fnSaveState2(settings);
        that.iterator("column", function(settings2, column) {
          if (changed.includes(column)) {
            _fnCallbackFire2(settings2, null, "column-visibility", [settings2, column, vis, calc]);
          }
        });
        if (changed.length && (calc === void 0 || calc)) {
          that.columns.adjust();
        }
      });
    }
    return ret;
  });
  _api_registerPlural2("columns().widths()", "column().width()", function() {
    var columns = this.columns(":visible").count();
    var row = $3("<tr>").html("<td>" + Array(columns).join("</td><td>") + "</td>");
    $3(this.table().body()).append(row);
    var widths = row.children().map(function() {
      return $3(this).outerWidth();
    });
    row.remove();
    return this.iterator("column", function(settings, column) {
      var visIdx = _fnColumnIndexToVisible2(settings, column);
      return visIdx !== null ? widths[visIdx] : 0;
    }, 1);
  });
  _api_registerPlural2("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible2(settings, column) : column;
    }, 1);
  });
  _api_register2("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing2(settings);
    }, 1);
  });
  _api_register2("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex2(ctx, idx);
      } else if (type === "fromData" || type === "toVisible") {
        return _fnColumnIndexToVisible2(ctx, idx);
      }
    }
  });
  _api_register2("column()", function(selector, opts) {
    return _selector_first2(this.columns(selector, opts));
  });
  var __cell_selector2 = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes2(settings, opts);
    var cells = _removeEmpty2(_pluck_order2(data, rows, "anCells"));
    var allCells = $3(_flatten2([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;
    var run = function(s) {
      var fnSelector = typeof s === "function";
      if (s === null || s === void 0 || fnSelector) {
        a = [];
        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];
          for (j = 0; j < columns; j++) {
            o = {
              row,
              column: j
            };
            if (fnSelector) {
              host = data[row];
              if (s(o, _fnGetCellData2(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              a.push(o);
            }
          }
        }
        return a;
      }
      if ($3.isPlainObject(s)) {
        return s.column !== void 0 && s.row !== void 0 && rows.indexOf(s.row) !== -1 ? [s] : [];
      }
      var jqResult = allCells.filter(s).map(function(i2, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      host = $3(s).closest("*[data-dt-row]");
      return host.length ? [{
        row: host.data("dt-row"),
        column: host.data("dt-column")
      }] : [];
    };
    return _selector_run2("cell", selector, run, settings, opts);
  };
  _api_register2("cells()", function(rowSelector, columnSelector, opts) {
    if ($3.isPlainObject(rowSelector)) {
      if (rowSelector.row === void 0) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($3.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === void 0) {
      return this.iterator("table", function(settings) {
        return __cell_selector2(settings, rowSelector, _selector_opts2(opts));
      });
    }
    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {};
    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator("table", function(settings, idx) {
      var a = [];
      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }
      return a;
    }, 1);
    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $3.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts
    });
    return cells;
  });
  _api_registerPlural2("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : void 0;
    }, 1);
  });
  _api_register2("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData2(settings, row, column);
    }, 1);
  });
  _api_registerPlural2("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural2("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData2(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural2("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {
        row,
        column,
        columnVisible: _fnColumnIndexToVisible2(settings, column)
      };
    }, 1);
  });
  _api_registerPlural2("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate2(settings, row, src, column);
    });
  });
  _api_register2("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first2(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register2("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === void 0) {
      return ctx.length && cell.length ? _fnGetCellData2(ctx[0], cell[0].row, cell[0].column) : void 0;
    }
    _fnSetCellData2(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate2(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register2("order()", function(order, dir) {
    var ctx = this.context;
    var args = Array.prototype.slice.call(arguments);
    if (order === void 0) {
      return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
    }
    if (typeof order === "number") {
      order = [[order, dir]];
    } else if (args.length > 1) {
      order = args;
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = Array.isArray(order) ? order.slice() : order;
    });
  });
  _api_register2("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener2(settings, node, {}, column, callback);
    });
  });
  _api_register2("order.fixed()", function(set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
      return Array.isArray(fixed) ? { pre: fixed } : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $3.extend(true, {}, set);
    });
  });
  _api_register2([
    "columns().order()",
    "column().order()"
  ], function(dir) {
    var that = this;
    if (!dir) {
      return this.iterator("column", function(settings, idx) {
        var sort = _fnSortFlatten2(settings);
        for (var i = 0, ien = sort.length; i < ien; i++) {
          if (sort[i].col === idx) {
            return sort[i].dir;
          }
        }
        return null;
      }, 1);
    } else {
      return this.iterator("table", function(settings, i) {
        settings.aaSorting = that[i].map(function(col) {
          return [col, dir];
        });
      });
    }
  });
  _api_registerPlural2("columns().orderable()", "column().orderable()", function(directions) {
    return this.iterator("column", function(settings, idx) {
      var col = settings.aoColumns[idx];
      return directions ? col.asSorting : col.bSortable;
    }, 1);
  });
  _api_register2("processing()", function(show) {
    return this.iterator("table", function(ctx) {
      _fnProcessingDisplay2(ctx, show);
    });
  });
  _api_register2("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === void 0) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.search : void 0;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      if (typeof regex === "object") {
        _fnFilterComplete2(settings, $3.extend(settings.oPreviousSearch, regex, {
          search: input
        }));
      } else {
        _fnFilterComplete2(settings, $3.extend(settings.oPreviousSearch, {
          search: input,
          regex: regex === null ? false : regex,
          smart: smart === null ? true : smart,
          caseInsensitive: caseInsen === null ? true : caseInsen
        }));
      }
    });
  });
  _api_register2("search.fixed()", function(name, search) {
    var ret = this.iterator(true, "table", function(settings) {
      var fixed = settings.searchFixed;
      if (!name) {
        return Object.keys(fixed);
      } else if (search === void 0) {
        return fixed[name];
      } else if (search === null) {
        delete fixed[name];
      } else {
        fixed[name] = search;
      }
      return this;
    });
    return name !== void 0 && search === void 0 ? ret[0] : ret;
  });
  _api_registerPlural2(
    "columns().search()",
    "column().search()",
    function(input, regex, smart, caseInsen) {
      return this.iterator("column", function(settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === void 0) {
          return preSearch[column].search;
        }
        if (!settings.oFeatures.bFilter) {
          return;
        }
        if (typeof regex === "object") {
          $3.extend(preSearch[column], regex, {
            search: input
          });
        } else {
          $3.extend(preSearch[column], {
            search: input,
            regex: regex === null ? false : regex,
            smart: smart === null ? true : smart,
            caseInsensitive: caseInsen === null ? true : caseInsen
          });
        }
        _fnFilterComplete2(settings, settings.oPreviousSearch);
      });
    }
  );
  _api_register2(
    [
      "columns().search.fixed()",
      "column().search.fixed()"
    ],
    function(name, search) {
      var ret = this.iterator(true, "column", function(settings, colIdx) {
        var fixed = settings.aoColumns[colIdx].searchFixed;
        if (!name) {
          return Object.keys(fixed);
        } else if (search === void 0) {
          return fixed[name];
        } else if (search === null) {
          delete fixed[name];
        } else {
          fixed[name] = search;
        }
        return this;
      });
      return name !== void 0 && search === void 0 ? ret[0] : ret;
    }
  );
  _api_register2("state()", function(set, ignoreTime) {
    if (!set) {
      return this.context.length ? this.context[0].oSavedState : null;
    }
    var setMutate = $3.extend(true, {}, set);
    return this.iterator("table", function(settings) {
      if (ignoreTime !== false) {
        setMutate.time = +/* @__PURE__ */ new Date() + 100;
      }
      _fnImplementState2(settings, setMutate, function() {
      });
    });
  });
  _api_register2("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register2("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register2("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState2(settings);
    });
  });
  DataTable2.use = function(module, type) {
    if (type === "lib" || module.fn) {
      $3 = module;
    } else if (type == "win" || module.document) {
      window = module;
      document = module.document;
    } else if (type === "datetime" || module.type === "DateTime") {
      DataTable2.DateTime = module;
    }
  };
  DataTable2.factory = function(root, jq) {
    var is = false;
    if (root && root.document) {
      window = root;
      document = root.document;
    }
    if (jq && jq.fn && jq.fn.jquery) {
      $3 = jq;
      is = true;
    }
    return is;
  };
  DataTable2.versionCheck = function(version, version2) {
    var aThis = version2 ? version2.split(".") : DataTable2.version.split(".");
    var aThat = version.split(".");
    var iThis, iThat;
    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable2.isDataTable = function(table) {
    var t = $3(table).get(0);
    var is = false;
    if (table instanceof DataTable2.Api) {
      return true;
    }
    $3.each(DataTable2.settings, function(i, o) {
      var head = o.nScrollHead ? $3("table", o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $3("table", o.nScrollFoot)[0] : null;
      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  DataTable2.tables = function(visible) {
    var api = false;
    if ($3.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a = DataTable2.settings.filter(function(o) {
      return !visible || visible && $3(o.nTable).is(":visible") ? true : false;
    }).map(function(o) {
      return o.nTable;
    });
    return api ? new _Api2(a) : a;
  };
  DataTable2.camelToHungarian = _fnCamelToHungarian2;
  _api_register2("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $3(rows);
    return $3([].concat(
      jqRows.filter(selector).toArray(),
      jqRows.find(selector).toArray()
    ));
  });
  $3.each(["on", "one", "off"], function(i, key) {
    _api_register2(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      args[0] = args[0].split(/\s/).map(function(e) {
        return !e.match(/\.dt\b/) ? e + ".dt" : e;
      }).join(" ");
      var inst = $3(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register2("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable2(settings);
    });
  });
  _api_register2("error()", function(msg) {
    return this.iterator("table", function(settings) {
      _fnLog2(settings, 0, msg);
    });
  });
  _api_register2("settings()", function() {
    return new _Api2(this.context, this.context);
  });
  _api_register2("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register2("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck2(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register2("trigger()", function(name, args, bubbles) {
    return this.iterator("table", function(settings) {
      return _fnCallbackFire2(settings, null, name, args, bubbles);
    }).flatten();
  });
  _api_register2("ready()", function(fn) {
    var ctx = this.context;
    if (!fn) {
      return ctx.length ? ctx[0]._bInitComplete || false : null;
    }
    return this.tables().every(function() {
      if (this.context[0]._bInitComplete) {
        fn.call(this);
      } else {
        this.on("init", function() {
          fn.call(this);
        });
      }
    });
  });
  _api_register2("destroy()", function(remove) {
    remove = remove || false;
    return this.iterator("table", function(settings) {
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $3(table);
      var jqTbody = $3(tbody);
      var jqWrapper = $3(settings.nTableWrapper);
      var rows = settings.aoData.map(function(r) {
        return r ? r.nTr : null;
      });
      var orderClasses = classes.order;
      settings.bDestroying = true;
      _fnCallbackFire2(settings, "aoDestroyCallback", "destroy", [settings], true);
      if (!remove) {
        new _Api2(settings).columns().visible(true);
      }
      jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
      $3(window).off(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.colgroup.remove();
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses2(settings);
      $3("th, td", thead).removeClass(
        orderClasses.canAsc + " " + orderClasses.canDesc + " " + orderClasses.isAsc + " " + orderClasses.isDesc
      ).css("width", "");
      jqTbody.children().detach();
      jqTbody.append(rows);
      var orig = settings.nTableWrapper.parentNode;
      var insertBefore = settings.nTableWrapper.nextSibling;
      var removedMethod = remove ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove && orig) {
        orig.insertBefore(table, insertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.table);
      }
      var idx = DataTable2.settings.indexOf(settings);
      if (idx !== -1) {
        DataTable2.settings.splice(idx, 1);
      }
    });
  });
  $3.each(["column", "row", "cell"], function(i, type) {
    _api_register2(type + "s().every()", function(fn) {
      var opts = this.selector.opts;
      var api = this;
      var inst;
      var counter = 0;
      return this.iterator("every", function(settings, selectedIdx, tableIdx) {
        inst = api[type](selectedIdx, opts);
        if (type === "cell") {
          fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
        } else {
          fn.call(inst, selectedIdx, tableIdx, counter);
        }
        counter++;
      });
    });
  });
  _api_register2("i18n()", function(token, def, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn2(token)(ctx.oLanguage);
    if (resolved === void 0) {
      resolved = def;
    }
    if ($3.isPlainObject(resolved)) {
      resolved = plural !== void 0 && resolved[plural] !== void 0 ? resolved[plural] : resolved._;
    }
    return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
  });
  DataTable2.version = "2.0.5";
  DataTable2.settings = [];
  DataTable2.models = {};
  DataTable2.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     */
    "caseInsensitive": true,
    /**
     * Applied search term
     */
    "search": "",
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     */
    "regex": false,
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     */
    "smart": true,
    /**
     * Flag to indicate if DataTables should only trigger a search when
     * the return key is pressed.
     */
    "return": false
  };
  DataTable2.models.oRow = {
    /**
     * TR element for the row
     */
    "nTr": null,
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     */
    "anCells": null,
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     */
    "_aData": [],
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     */
    "_aSortData": null,
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     */
    "_aFilterData": null,
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     */
    "_sFilterRow": null,
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     */
    "src": null,
    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     */
    "idx": -1,
    /**
     * Cached display value
     */
    displayData: null
  };
  DataTable2.models.oColumn = {
    /**
     * Column index.
     */
    "idx": null,
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     */
    "aDataSort": null,
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     */
    "asSorting": null,
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     */
    "bSearchable": null,
    /**
     * Flag to indicate if the column is sortable or not.
     */
    "bSortable": null,
    /**
     * Flag to indicate if the column is currently visible in the table or not
     */
    "bVisible": null,
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     */
    "_sManualType": null,
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     */
    "_bAttrSrc": false,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     */
    "fnGetData": null,
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     */
    "fnSetData": null,
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     */
    "mData": null,
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     */
    "mRender": null,
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     */
    "sClass": null,
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     */
    "sContentPadding": null,
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     */
    "sName": null,
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     */
    "sSortDataType": "std",
    /**
     * Class to be applied to the header element when sorting on this column
     */
    "sSortingClass": null,
    /**
     * Title of the column - what is seen in the TH element (nTh).
     */
    "sTitle": null,
    /**
     * Column sorting and filtering type
     */
    "sType": null,
    /**
     * Width of the column
     */
    "sWidth": null,
    /**
     * Width of the column when it was first "encountered"
     */
    "sWidthOrig": null,
    /** Cached string which is the longest in the column */
    maxLenString: null,
    /**
     * Store for named searches
     */
    searchFixed: null
  };
  DataTable2.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     */
    "aaData": null,
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     */
    "aaSorting": [[0, "asc"]],
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     */
    "aaSortingFixed": [],
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     */
    "ajax": null,
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     */
    "aLengthMenu": [10, 25, 50, 100],
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     */
    "aoColumns": null,
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     */
    "aoColumnDefs": null,
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     */
    "aoSearchCols": [],
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     */
    "bAutoWidth": true,
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     */
    "bDeferRender": true,
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     */
    "bDestroy": false,
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     */
    "bFilter": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bInfo": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bLengthChange": true,
    /**
     * Enable or disable pagination.
     */
    "bPaginate": true,
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     */
    "bProcessing": false,
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     */
    "bRetrieve": false,
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     */
    "bScrollCollapse": false,
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     */
    "bServerSide": false,
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     */
    "bSort": true,
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     */
    "bSortMulti": true,
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     */
    "bSortCellsTop": null,
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     */
    "bSortClasses": true,
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     */
    "bStateSave": false,
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     */
    "fnCreatedRow": null,
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     */
    "fnDrawCallback": null,
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     */
    "fnFooterCallback": null,
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     */
    "fnFormatNumber": function(toFormat) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     */
    "fnHeaderCallback": null,
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     */
    "fnInfoCallback": null,
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     */
    "fnInitComplete": null,
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     */
    "fnPreDrawCallback": null,
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     */
    "fnRowCallback": null,
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateLoadCallback": function(settings) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            "DataTables_" + settings.sInstance + "_" + location.pathname
          )
        );
      } catch (e) {
        return {};
      }
    },
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     */
    "fnStateLoadParams": null,
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     */
    "fnStateLoaded": null,
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateSaveCallback": function(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname,
          JSON.stringify(data)
        );
      } catch (e) {
      }
    },
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     */
    "fnStateSaveParams": null,
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     */
    "iStateDuration": 7200,
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     */
    "iDisplayLength": 10,
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     */
    "iDisplayStart": 0,
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     */
    "iTabIndex": 0,
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     */
    "oClasses": {},
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be sorted
         */
        "orderable": ": Activate to sort",
        /**
         * ARIA label that is added to the table headers when the column is currently being sorted
         */
        "orderableReverse": ": Activate to invert sorting",
        /**
         * ARIA label that is added to the table headers when the column is currently being 
         * sorted and next step is to remove sorting
         */
        "orderableRemove": ": Activate to remove sorting",
        paginate: {
          first: "First",
          last: "Last",
          next: "Next",
          previous: "Previous"
        }
      },
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       */
      "oPaginate": {
        /**
         * Label and character for first page button ()
         */
        "sFirst": "\xAB",
        /**
         * Last page button ()
         */
        "sLast": "\xBB",
        /**
         * Next page button ()
         */
        "sNext": "\u203A",
        /**
         * Previous page button ()
         */
        "sPrevious": "\u2039"
      },
      /**
       * Plural object for the data type the table is showing
       */
      entries: {
        _: "entries",
        1: "entry"
      },
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       */
      "sEmptyTable": "No data available in table",
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       */
      "sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       */
      "sInfoPostFix": "",
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       */
      "sDecimal": "",
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       */
      "sThousands": ",",
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       */
      "sLengthMenu": "_MENU_ _ENTRIES_ per page",
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       */
      "sLoadingRecords": "Loading...",
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       */
      "sProcessing": "",
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       */
      "sSearch": "Search:",
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       */
      "sUrl": "",
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       */
      "sZeroRecords": "No matching records found"
    },
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     */
    "oSearch": $3.extend({}, DataTable2.models.oSearch),
    /**
     * Table and control layout. This replaces the legacy `dom` option.
     */
    layout: {
      topStart: "pageLength",
      topEnd: "search",
      bottomStart: "info",
      bottomEnd: "paging"
    },
    /**
     * Legacy DOM layout option
     */
    "sDom": null,
    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     */
    "searchDelay": null,
    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     */
    "sPaginationType": "full_numbers",
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     */
    "sScrollX": "",
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     */
    "sScrollXInner": "",
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     */
    "sScrollY": "",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     */
    "sServerMethod": "GET",
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     */
    "renderer": null,
    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     */
    "rowId": "DT_RowId",
    /**
     * Caption value
     */
    "caption": null
  };
  _fnHungarianMap2(DataTable2.defaults);
  DataTable2.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     */
    "aDataSort": null,
    "iDataSort": -1,
    ariaTitle: "",
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     */
    "asSorting": ["asc", "desc", ""],
    /**
     * Enable or disable filtering on the data in this column.
     */
    "bSearchable": true,
    /**
     * Enable or disable ordering on this column.
     */
    "bSortable": true,
    /**
     * Enable or disable the display of this column.
     */
    "bVisible": true,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     */
    "mData": null,
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     */
    "mRender": null,
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     */
    "sCellType": "td",
    /**
     * Class to give to each cell in this column.
     */
    "sClass": "",
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     */
    "sContentPadding": "",
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     */
    "sName": "",
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     */
    "sSortDataType": "std",
    /**
     * The title of this column.
     */
    "sTitle": null,
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     */
    "sType": null,
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     */
    "sWidth": null
  };
  _fnHungarianMap2(DataTable2.defaults.column);
  DataTable2.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bAutoWidth": null,
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all for DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bDeferRender": null,
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bFilter": null,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bInfo": true,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bLengthChange": true,
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bPaginate": null,
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bProcessing": null,
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bServerSide": null,
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSort": null,
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortMulti": null,
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortClasses": null,
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bStateSave": null
    },
    /**
     * Scrolling settings for a table.
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bCollapse": null,
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       */
      "iBarWidth": 0,
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sX": null,
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @deprecated
       */
      "sXInner": null,
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sY": null
    },
    /**
     * Language information for the table.
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       */
      "fnInfoCallback": null
    },
    /**
     * Browser support parameters
     */
    "oBrowser": {
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       */
      "bScrollbarLeft": false,
      /**
       * Browser scrollbar width
       */
      "barWidth": 0
    },
    "ajax": null,
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     */
    "aanFeatures": [],
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     */
    "aoData": [],
    /**
     * Array of indexes which are in the current display (after filtering etc)
     */
    "aiDisplay": [],
    /**
     * Array of indexes for display - no filtering
     */
    "aiDisplayMaster": [],
    /**
     * Map of row ids to data indexes
     */
    "aIds": {},
    /**
     * Store information about each column that is in use
     */
    "aoColumns": [],
    /**
     * Store information about the table's header
     */
    "aoHeader": [],
    /**
     * Store information about the table's footer
     */
    "aoFooter": [],
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "oPreviousSearch": {},
    /**
     * Store for named searches
     */
    searchFixed: {},
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     */
    "aoPreSearchCols": [],
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSorting": null,
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSortingFixed": [],
    /**
     * If restoring a table - we should restore its width
     */
    "sDestroyWidth": 0,
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     */
    "aoRowCallback": [],
    /**
     * Callback functions for the header on each draw.
     */
    "aoHeaderCallback": [],
    /**
     * Callback function for the footer on each draw.
     */
    "aoFooterCallback": [],
    /**
     * Array of callback functions for draw callback functions
     */
    "aoDrawCallback": [],
    /**
     * Array of callback functions for row created function
     */
    "aoRowCreatedCallback": [],
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     */
    "aoPreDrawCallback": [],
    /**
     * Callback functions for when the table has been initialised.
     */
    "aoInitComplete": [],
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     */
    "aoStateSaveParams": [],
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     */
    "aoStateLoadParams": [],
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     */
    "aoStateLoaded": [],
    /**
     * Cache the table ID for quick access
     */
    "sTableId": "",
    /**
     * The TABLE node for the main table
     */
    "nTable": null,
    /**
     * Permanent ref to the thead element
     */
    "nTHead": null,
    /**
     * Permanent ref to the tfoot element - if it exists
     */
    "nTFoot": null,
    /**
     * Permanent ref to the tbody element
     */
    "nTBody": null,
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     */
    "nTableWrapper": null,
    /**
     * Indicate if all required information has been read in
     */
    "bInitialised": false,
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     */
    "aoOpenRows": [],
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sDom": null,
    /**
     * Search delay (in mS)
     */
    "searchDelay": null,
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sPaginationType": "two_button",
    /**
     * Number of paging controls on the page. Only used for backwards compatibility
     */
    pagingControls: 0,
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "iStateDuration": 0,
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateSave": [],
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateLoad": [],
    /**
     * State that was saved. Useful for back reference
     */
    "oSavedState": null,
    /**
     * State that was loaded. Useful for back reference
     */
    "oLoadedState": null,
    /**
     * Note if draw should be blocked while getting data
     */
    "bAjaxDataGet": true,
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     */
    "jqXHR": null,
    /**
     * JSON returned from the server in the last Ajax request
     */
    "json": void 0,
    /**
     * Data submitted as part of the last Ajax request
     */
    "oAjaxData": void 0,
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sServerMethod": null,
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "fnFormatNumber": null,
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aLengthMenu": null,
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     */
    "iDraw": 0,
    /**
     * Indicate if a redraw is being done - useful for Ajax
     */
    "bDrawing": false,
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     */
    "iDrawError": -1,
    /**
     * Paging display length
     */
    "_iDisplayLength": 10,
    /**
     * Paging start point - aiDisplay index
     */
    "_iDisplayStart": 0,
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsTotal": 0,
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsDisplay": 0,
    /**
     * The classes to use for the table
     */
    "oClasses": {},
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bFiltered": false,
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bSorted": false,
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSortCellsTop": null,
    /**
     * Initialisation object that is used for the table
     */
    "oInit": null,
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     */
    "aoDestroyCallback": [],
    /**
     * Get the number of records in the current record set, before filtering
     */
    "fnRecordsTotal": function() {
      return _fnDataSource2(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },
    /**
     * Get the number of records in the current record set, after filtering
     */
    "fnRecordsDisplay": function() {
      return _fnDataSource2(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },
    /**
     * Get the display end point - aiDisplay index
     */
    "fnDisplayEnd": function() {
      var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },
    /**
     * The DataTables object for this table
     */
    "oInstance": null,
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     */
    "sInstance": null,
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
    /**
     * Last applied sort
     */
    "aLastSort": [],
    /**
     * Stored plug-in instances
     */
    "oPlugins": {},
    /**
     * Function used to get a row's id from the row's data
     */
    "rowIdFn": null,
    /**
     * Data location where to store a row's id
     */
    "rowId": null,
    caption: "",
    captionNode: null,
    colgroup: null
  };
  var extPagination2 = DataTable2.ext.pager;
  $3.extend(extPagination2, {
    simple: function() {
      return ["previous", "next"];
    },
    full: function() {
      return ["first", "previous", "next", "last"];
    },
    numbers: function() {
      return ["numbers"];
    },
    simple_numbers: function() {
      return ["previous", "numbers", "next"];
    },
    full_numbers: function() {
      return ["first", "previous", "numbers", "next", "last"];
    },
    first_last: function() {
      return ["first", "last"];
    },
    first_last_numbers: function() {
      return ["first", "numbers", "last"];
    },
    // For testing and plug-ins to use
    _numbers: _pagingNumbers2,
    // Number of number buttons - legacy, use `numbers` option for paging feature
    numbers_length: 7
  });
  $3.extend(true, DataTable2.ext.renderer, {
    pagingButton: {
      _: function(settings, buttonType, content, active, disabled) {
        var classes = settings.oClasses.paging;
        var btnClasses = [classes.button];
        var btn;
        if (active) {
          btnClasses.push(classes.active);
        }
        if (disabled) {
          btnClasses.push(classes.disabled);
        }
        if (buttonType === "ellipsis") {
          btn = $3('<span class="ellipsis"></span>').html(content)[0];
        } else {
          btn = $3("<button>", {
            class: btnClasses.join(" "),
            role: "link",
            type: "button"
          }).html(content);
        }
        return {
          display: btn,
          clicker: btn
        };
      }
    },
    pagingContainer: {
      _: function(settings, buttons) {
        return buttons;
      }
    }
  });
  var _filterString2 = function(stripHtml, normalize) {
    return function(str) {
      if (_empty2(str) || typeof str !== "string") {
        return str;
      }
      str = str.replace(_re_new_lines2, " ");
      if (stripHtml) {
        str = _stripHtml2(str);
      }
      if (normalize) {
        str = _normalize2(str, false);
      }
      return str;
    };
  };
  function __mldFnName(name) {
    return name.replace(/[\W]/g, "_");
  }
  function __mld2(dt, momentFn, luxonFn, dateFn, arg1) {
    if (window.moment) {
      return dt[momentFn](arg1);
    } else if (window.luxon) {
      return dt[luxonFn](arg1);
    }
    return dateFn ? dt[dateFn](arg1) : dt;
  }
  var __mlWarning2 = false;
  function __mldObj2(d, format, locale) {
    var dt;
    if (window.moment) {
      dt = window.moment.utc(d, format, locale, true);
      if (!dt.isValid()) {
        return null;
      }
    } else if (window.luxon) {
      dt = format && typeof d === "string" ? window.luxon.DateTime.fromFormat(d, format) : window.luxon.DateTime.fromISO(d);
      if (!dt.isValid) {
        return null;
      }
      dt.setLocale(locale);
    } else if (!format) {
      dt = new Date(d);
    } else {
      if (!__mlWarning2) {
        alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
      }
      __mlWarning2 = true;
    }
    return dt;
  }
  function __mlHelper2(localeString) {
    return function(from, to, locale, def) {
      if (arguments.length === 0) {
        locale = "en";
        to = null;
        from = null;
      } else if (arguments.length === 1) {
        locale = "en";
        to = from;
        from = null;
      } else if (arguments.length === 2) {
        locale = to;
        to = from;
        from = null;
      }
      var typeName = "datetime" + (to ? "-" + __mldFnName(to) : "");
      if (!DataTable2.ext.type.order[typeName]) {
        DataTable2.type(typeName, {
          detect: function(d) {
            return d === typeName ? typeName : false;
          },
          order: {
            pre: function(d) {
              return d.valueOf();
            }
          },
          className: "dt-right"
        });
      }
      return function(d, type) {
        if (d === null || d === void 0) {
          if (def === "--now") {
            var local = /* @__PURE__ */ new Date();
            d = new Date(Date.UTC(
              local.getFullYear(),
              local.getMonth(),
              local.getDate(),
              local.getHours(),
              local.getMinutes(),
              local.getSeconds()
            ));
          } else {
            d = "";
          }
        }
        if (type === "type") {
          return typeName;
        }
        if (d === "") {
          return type !== "sort" ? "" : __mldObj2("0000-01-01 00:00:00", null, locale);
        }
        if (to !== null && from === to && type !== "sort" && type !== "type" && !(d instanceof Date)) {
          return d;
        }
        var dt = __mldObj2(d, from, locale);
        if (dt === null) {
          return d;
        }
        if (type === "sort") {
          return dt;
        }
        var formatted = to === null ? __mld2(dt, "toDate", "toJSDate", "")[localeString]() : __mld2(dt, "format", "toFormat", "toISOString", to);
        return type === "display" ? _escapeHtml2(formatted) : formatted;
      };
    };
  }
  var __thousands2 = ",";
  var __decimal2 = ".";
  if (window.Intl !== void 0) {
    try {
      num = new Intl.NumberFormat().formatToParts(100000.1);
      for (i = 0; i < num.length; i++) {
        if (num[i].type === "group") {
          __thousands2 = num[i].value;
        } else if (num[i].type === "decimal") {
          __decimal2 = num[i].value;
        }
      }
    } catch (e) {
    }
  }
  var num;
  var i;
  DataTable2.datetime = function(format, locale) {
    var typeName = "datetime-detect-" + __mldFnName(format);
    if (!locale) {
      locale = "en";
    }
    if (!DataTable2.ext.type.order[typeName]) {
      DataTable2.type(typeName, {
        detect: function(d) {
          var dt = __mldObj2(d, format, locale);
          return d === "" || dt ? typeName : false;
        },
        order: {
          pre: function(d) {
            return __mldObj2(d, format, locale) || 0;
          }
        },
        className: "dt-right"
      });
    }
  };
  DataTable2.render = {
    date: __mlHelper2("toLocaleDateString"),
    datetime: __mlHelper2("toLocaleString"),
    time: __mlHelper2("toLocaleTimeString"),
    number: function(thousands, decimal, precision, prefix, postfix) {
      if (thousands === null || thousands === void 0) {
        thousands = __thousands2;
      }
      if (decimal === null || decimal === void 0) {
        decimal = __decimal2;
      }
      return {
        display: function(d) {
          if (typeof d !== "number" && typeof d !== "string") {
            return d;
          }
          if (d === "" || d === null) {
            return d;
          }
          var negative = d < 0 ? "-" : "";
          var flo = parseFloat(d);
          var abs = Math.abs(flo);
          if (abs >= 1e11 || abs < 1e-4 && abs !== 0) {
            var exp = flo.toExponential(precision).split(/e\+?/);
            return exp[0] + " x 10<sup>" + exp[1] + "</sup>";
          }
          if (isNaN(flo)) {
            return _escapeHtml2(d);
          }
          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
          if (intPart === 0 && parseFloat(floatPart) === 0) {
            negative = "";
          }
          return negative + (prefix || "") + intPart.toString().replace(
            /\B(?=(\d{3})+(?!\d))/g,
            thousands
          ) + floatPart + (postfix || "");
        }
      };
    },
    text: function() {
      return {
        display: _escapeHtml2,
        filter: _escapeHtml2
      };
    }
  };
  var _extTypes2 = DataTable2.ext.type;
  DataTable2.type = function(name, prop, val) {
    if (!prop) {
      return {
        className: _extTypes2.className[name],
        detect: _extTypes2.detect.find(function(fn) {
          return fn.name === name;
        }),
        order: {
          pre: _extTypes2.order[name + "-pre"],
          asc: _extTypes2.order[name + "-asc"],
          desc: _extTypes2.order[name + "-desc"]
        },
        render: _extTypes2.render[name],
        search: _extTypes2.search[name]
      };
    }
    var setProp = function(prop2, propVal) {
      _extTypes2[prop2][name] = propVal;
    };
    var setDetect = function(fn) {
      var cb = function(d, s) {
        var ret = fn(d, s);
        return ret === true ? name : ret;
      };
      Object.defineProperty(cb, "name", { value: name });
      var idx = _extTypes2.detect.findIndex(function(fn2) {
        return fn2.name === name;
      });
      if (idx === -1) {
        _extTypes2.detect.unshift(cb);
      } else {
        _extTypes2.detect.splice(idx, 1, cb);
      }
    };
    var setOrder = function(obj) {
      _extTypes2.order[name + "-pre"] = obj.pre;
      _extTypes2.order[name + "-asc"] = obj.asc;
      _extTypes2.order[name + "-desc"] = obj.desc;
    };
    if (val === void 0) {
      val = prop;
      prop = null;
    }
    if (prop === "className") {
      setProp("className", val);
    } else if (prop === "detect") {
      setDetect(val);
    } else if (prop === "order") {
      setOrder(val);
    } else if (prop === "render") {
      setProp("render", val);
    } else if (prop === "search") {
      setProp("search", val);
    } else if (!prop) {
      if (val.className) {
        setProp("className", val.className);
      }
      if (val.detect !== void 0) {
        setDetect(val.detect);
      }
      if (val.order) {
        setOrder(val.order);
      }
      if (val.render !== void 0) {
        setProp("render", val.render);
      }
      if (val.search !== void 0) {
        setProp("search", val.search);
      }
    }
  };
  DataTable2.types = function() {
    return _extTypes2.detect.map(function(fn) {
      return fn.name;
    });
  };
  DataTable2.type("string", {
    detect: function() {
      return "string";
    },
    order: {
      pre: function(a) {
        return _empty2(a) ? "" : typeof a === "string" ? a.toLowerCase() : !a.toString ? "" : a.toString();
      }
    },
    search: _filterString2(false, true)
  });
  DataTable2.type("html", {
    detect: function(d) {
      return _empty2(d) || typeof d === "string" && d.indexOf("<") !== -1 ? "html" : null;
    },
    order: {
      pre: function(a) {
        return _empty2(a) ? "" : a.replace ? _stripHtml2(a).trim().toLowerCase() : a + "";
      }
    },
    search: _filterString2(true, true)
  });
  DataTable2.type("date", {
    className: "dt-type-date",
    detect: function(d) {
      if (d && !(d instanceof Date) && !_re_date2.test(d)) {
        return null;
      }
      var parsed = Date.parse(d);
      return parsed !== null && !isNaN(parsed) || _empty2(d) ? "date" : null;
    },
    order: {
      pre: function(d) {
        var ts = Date.parse(d);
        return isNaN(ts) ? -Infinity : ts;
      }
    }
  });
  DataTable2.type("html-num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric2(d, decimal, true) ? "html-num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace2(d, dp, _re_html2, _re_formatted_numeric2);
      }
    },
    search: _filterString2(true, true)
  });
  DataTable2.type("html-num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric2(d, decimal) ? "html-num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace2(d, dp, _re_html2);
      }
    },
    search: _filterString2(true, true)
  });
  DataTable2.type("num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber2(d, decimal, true) ? "num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace2(d, dp, _re_formatted_numeric2);
      }
    }
  });
  DataTable2.type("num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber2(d, decimal) ? "num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace2(d, dp);
      }
    }
  });
  var __numericReplace2 = function(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === "-")) {
      return -Infinity;
    }
    var type = typeof d;
    if (type === "number" || type === "bigint") {
      return d;
    }
    if (decimalPlace) {
      d = _numToDecimal2(d, decimalPlace);
    }
    if (d.replace) {
      if (re1) {
        d = d.replace(re1, "");
      }
      if (re2) {
        d = d.replace(re2, "");
      }
    }
    return d * 1;
  };
  $3.extend(true, DataTable2.ext.renderer, {
    footer: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.tfoot.cell);
      }
    },
    header: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.thead.cell);
        if (!settings.oFeatures.bSort) {
          cell.addClass(classes.order.none);
        }
        var legacyTop = settings.bSortCellsTop;
        var headerRows = cell.closest("thead").find("tr");
        var rowIdx = cell.parent().index();
        if (
          // Cells and rows which have the attribute to disable the icons
          cell.attr("data-dt-order") === "disable" || cell.parent().attr("data-dt-order") === "disable" || // Legacy support for `orderCellsTop`. If it is set, then cells
          // which are not in the top or bottom row of the header (depending
          // on the value) do not get the sorting classes applied to them
          legacyTop === true && rowIdx !== 0 || legacyTop === false && rowIdx !== headerRows.length - 1
        ) {
          return;
        }
        $3(settings.nTable).on("order.dt.DT", function(e, ctx, sorting) {
          if (settings !== ctx) {
            return;
          }
          var orderClasses = classes.order;
          var columns = ctx.api.columns(cell);
          var col = settings.aoColumns[columns.flatten()[0]];
          var orderable = columns.orderable().includes(true);
          var ariaType = "";
          var indexes = columns.indexes();
          var sortDirs = columns.orderable(true).flatten();
          var orderedColumns = "," + sorting.map(function(val) {
            return val.col;
          }).join(",") + ",";
          cell.removeClass(
            orderClasses.isAsc + " " + orderClasses.isDesc
          ).toggleClass(orderClasses.none, !orderable).toggleClass(orderClasses.canAsc, orderable && sortDirs.includes("asc")).toggleClass(orderClasses.canDesc, orderable && sortDirs.includes("desc"));
          var sortIdx = orderedColumns.indexOf("," + indexes.toArray().join(",") + ",");
          if (sortIdx !== -1) {
            var orderDirs = columns.order();
            cell.addClass(
              orderDirs.includes("asc") ? orderClasses.isAsc : "" + orderDirs.includes("desc") ? orderClasses.isDesc : ""
            );
          }
          if (sortIdx === 0) {
            var firstSort = sorting[0];
            var sortOrder = col.asSorting;
            cell.attr("aria-sort", firstSort.dir === "asc" ? "ascending" : "descending");
            ariaType = !sortOrder[firstSort.index + 1] ? "Remove" : "Reverse";
          } else {
            cell.removeAttr("aria-sort");
          }
          cell.attr(
            "aria-label",
            orderable ? col.ariaTitle + ctx.api.i18n("oAria.orderable" + ariaType) : col.ariaTitle
          );
          if (orderable) {
            cell.find(".dt-column-title").attr("role", "button");
            cell.attr("tabindex", 0);
          }
        });
      }
    },
    layout: {
      _: function(settings, container, items) {
        var row = $3("<div/>").addClass("dt-layout-row").appendTo(container);
        $3.each(items, function(key, val) {
          var klass = !val.table ? "dt-" + key + " " : "";
          if (val.table) {
            row.addClass("dt-layout-table");
          }
          $3("<div/>").attr({
            id: val.id || null,
            "class": "dt-layout-cell " + klass + (val.className || "")
          }).append(val.contents).appendTo(row);
        });
      }
    }
  });
  DataTable2.feature = {};
  DataTable2.feature.register = function(name, cb, legacy) {
    DataTable2.ext.features[name] = cb;
    if (legacy) {
      _ext2.feature.push({
        cFeature: legacy,
        fnInit: cb
      });
    }
  };
  DataTable2.feature.register("info", function(settings, opts) {
    if (!settings.oFeatures.bInfo) {
      return null;
    }
    var lang = settings.oLanguage, tid = settings.sTableId, n = $3("<div/>", {
      "class": settings.oClasses.info.container
    });
    opts = $3.extend({
      callback: lang.fnInfoCallback,
      empty: lang.sInfoEmpty,
      postfix: lang.sInfoPostFix,
      search: lang.sInfoFiltered,
      text: lang.sInfo
    }, opts);
    settings.aoDrawCallback.push(function(s) {
      _fnUpdateInfo2(s, opts, n);
    });
    if (!settings._infoEl) {
      n.attr({
        "aria-live": "polite",
        id: tid + "_info",
        role: "status"
      });
      $3(settings.nTable).attr("aria-describedby", tid + "_info");
      settings._infoEl = n;
    }
    return n;
  }, "i");
  function _fnUpdateInfo2(settings, opts, node) {
    var start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? opts.text : opts.empty;
    if (total !== max) {
      out += " " + opts.search;
    }
    out += opts.postfix;
    out = _fnMacros2(settings, out);
    if (opts.callback) {
      out = opts.callback.call(
        settings.oInstance,
        settings,
        start,
        end,
        max,
        total,
        out
      );
    }
    node.html(out);
    _fnCallbackFire2(settings, null, "info", [settings, node[0], out]);
  }
  var __searchCounter2 = 0;
  DataTable2.feature.register("search", function(settings, opts) {
    if (!settings.oFeatures.bFilter) {
      return null;
    }
    var classes = settings.oClasses.search;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var input = '<input type="search" class="' + classes.input + '"/>';
    opts = $3.extend({
      placeholder: language.sSearchPlaceholder,
      text: language.sSearch
    }, opts);
    if (opts.text.indexOf("_INPUT_") === -1) {
      opts.text += "_INPUT_";
    }
    opts.text = _fnMacros2(settings, opts.text);
    var end = opts.text.match(/_INPUT_$/);
    var start = opts.text.match(/^_INPUT_/);
    var removed = opts.text.replace(/_INPUT_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_INPUT_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_INPUT_";
    }
    var filter = $3("<div>").addClass(classes.container).append(str.replace(/_INPUT_/, input));
    filter.find("label").attr("for", "dt-search-" + __searchCounter2);
    filter.find("input").attr("id", "dt-search-" + __searchCounter2);
    __searchCounter2++;
    var searchFn = function(event) {
      var val = this.value;
      if (previousSearch.return && event.key !== "Enter") {
        return;
      }
      if (val != previousSearch.search) {
        previousSearch.search = val;
        _fnFilterComplete2(settings, previousSearch);
        settings._iDisplayStart = 0;
        _fnDraw2(settings);
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : 0;
    var jqFilter = $3("input", filter).val(previousSearch.search).attr("placeholder", opts.placeholder).on(
      "keyup.DT search.DT input.DT paste.DT cut.DT",
      searchDelay ? DataTable2.util.debounce(searchFn, searchDelay) : searchFn
    ).on("mouseup.DT", function(e) {
      setTimeout(function() {
        searchFn.call(jqFilter[0], e);
      }, 10);
    }).on("keypress.DT", function(e) {
      if (e.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $3(settings.nTable).on("search.dt.DT", function(ev, s) {
      if (settings === s && jqFilter[0] !== document.activeElement) {
        jqFilter.val(
          typeof previousSearch.search !== "function" ? previousSearch.search : ""
        );
      }
    });
    return filter;
  }, "f");
  DataTable2.feature.register("paging", function(settings, opts) {
    if (!settings.oFeatures.bPaginate) {
      return null;
    }
    opts = $3.extend({
      buttons: DataTable2.ext.pager.numbers_length,
      type: settings.sPaginationType,
      boundaryNumbers: true
    }, opts);
    if (opts.numbers) {
      opts.buttons = opts.numbers;
    }
    var host = $3("<div/>").addClass(settings.oClasses.paging.container + " paging_" + opts.type);
    var draw = function() {
      _pagingDraw2(settings, host, opts);
    };
    settings.aoDrawCallback.push(draw);
    $3(settings.nTable).on("column-sizing.dt.DT", draw);
    return host;
  }, "p");
  function _pagingDraw2(settings, host, opts) {
    if (!settings._bInitComplete) {
      return;
    }
    var plugin = DataTable2.ext.pager[opts.type], aria = settings.oLanguage.oAria.paginate || {}, start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin().map(function(val) {
      return val === "numbers" ? _pagingNumbers2(page, pages, opts.buttons, opts.boundaryNumbers) : val;
    }).flat();
    var buttonEls = [];
    for (var i = 0; i < buttons.length; i++) {
      var button = buttons[i];
      var btnInfo = _pagingButtonInfo2(settings, button, page, pages);
      var btn = _fnRenderer2(settings, "pagingButton")(
        settings,
        button,
        btnInfo.display,
        btnInfo.active,
        btnInfo.disabled
      );
      $3(btn.clicker).attr({
        "aria-controls": settings.sTableId,
        "aria-disabled": btnInfo.disabled ? "true" : null,
        "aria-current": btnInfo.active ? "page" : null,
        "aria-label": aria[button],
        "data-dt-idx": button,
        "tabIndex": btnInfo.disabled ? -1 : settings.iTabIndex
      });
      if (typeof button !== "number") {
        $3(btn.clicker).addClass(button);
      }
      _fnBindAction2(
        btn.clicker,
        { action: button },
        function(e) {
          e.preventDefault();
          _fnPageChange2(settings, e.data.action, true);
        }
      );
      buttonEls.push(btn.display);
    }
    var wrapped = _fnRenderer2(settings, "pagingContainer")(
      settings,
      buttonEls
    );
    var activeEl = host.find(document.activeElement).data("dt-idx");
    host.empty().append(wrapped);
    if (activeEl !== void 0) {
      host.find("[data-dt-idx=" + activeEl + "]").trigger("focus");
    }
    if (buttonEls.length && // any buttons
    opts.numbers > 1 && // prevent infinite
    $3(host).height() >= $3(buttonEls[0]).outerHeight() * 2 - 10) {
      _pagingDraw2(settings, host, $3.extend({}, opts, { numbers: opts.numbers - 2 }));
    }
  }
  function _pagingButtonInfo2(settings, button, page, pages) {
    var lang = settings.oLanguage.oPaginate;
    var o = {
      display: "",
      active: false,
      disabled: false
    };
    switch (button) {
      case "ellipsis":
        o.display = "&#x2026;";
        o.disabled = true;
        break;
      case "first":
        o.display = lang.sFirst;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "previous":
        o.display = lang.sPrevious;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "next":
        o.display = lang.sNext;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      case "last":
        o.display = lang.sLast;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      default:
        if (typeof button === "number") {
          o.display = settings.fnFormatNumber(button + 1);
          if (page === button) {
            o.active = true;
          }
        }
        break;
    }
    return o;
  }
  function _pagingNumbers2(page, pages, buttons, addFirstLast) {
    var numbers = [], half = Math.floor(buttons / 2), before = addFirstLast ? 2 : 1, after = addFirstLast ? 1 : 0;
    if (pages <= buttons) {
      numbers = _range2(0, pages);
    } else if (buttons === 1) {
      numbers = [page];
    } else if (buttons === 3) {
      if (page <= 1) {
        numbers = [0, 1, "ellipsis"];
      } else if (page >= pages - 2) {
        numbers = _range2(pages - 2, pages);
        numbers.unshift("ellipsis");
      } else {
        numbers = ["ellipsis", page, "ellipsis"];
      }
    } else if (page <= half) {
      numbers = _range2(0, buttons - before);
      numbers.push("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
      }
    } else if (page >= pages - 1 - half) {
      numbers = _range2(pages - (buttons - before), pages);
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.unshift(0);
      }
    } else {
      numbers = _range2(page - half + before, page + half - after);
      numbers.push("ellipsis");
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
        numbers.unshift(0);
      }
    }
    return numbers;
  }
  var __lengthCounter2 = 0;
  DataTable2.feature.register("pageLength", function(settings, opts) {
    var features = settings.oFeatures;
    if (!features.bPaginate || !features.bLengthChange) {
      return null;
    }
    opts = $3.extend({
      menu: settings.aLengthMenu,
      text: settings.oLanguage.sLengthMenu
    }, opts);
    var classes = settings.oClasses.length, tableId = settings.sTableId, menu = opts.menu, lengths = [], language = [], i;
    if (Array.isArray(menu[0])) {
      lengths = menu[0];
      language = menu[1];
    } else {
      for (i = 0; i < menu.length; i++) {
        if ($3.isPlainObject(menu[i])) {
          lengths.push(menu[i].value);
          language.push(menu[i].label);
        } else {
          lengths.push(menu[i]);
          language.push(menu[i]);
        }
      }
    }
    var end = opts.text.match(/_MENU_$/);
    var start = opts.text.match(/^_MENU_/);
    var removed = opts.text.replace(/_MENU_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_MENU_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_MENU_";
    }
    var div = $3("<div/>").addClass(classes.container).append(
      str.replace("_MENU_", "<span></span>")
    );
    var textNodes = [];
    div.find("label")[0].childNodes.forEach(function(el) {
      if (el.nodeType === Node.TEXT_NODE) {
        textNodes.push({
          el,
          text: el.textContent
        });
      }
    });
    var updateEntries = function(len) {
      textNodes.forEach(function(node) {
        node.el.textContent = _fnMacros2(settings, node.text, len);
      });
    };
    var select = $3("<select/>", {
      "name": tableId + "_length",
      "aria-controls": tableId,
      "class": classes.select
    });
    for (i = 0; i < lengths.length; i++) {
      select[0][i] = new Option(
        typeof language[i] === "number" ? settings.fnFormatNumber(language[i]) : language[i],
        lengths[i]
      );
    }
    div.find("label").attr("for", "dt-length-" + __lengthCounter2);
    select.attr("id", "dt-length-" + __lengthCounter2);
    __lengthCounter2++;
    div.find("span").replaceWith(select);
    $3("select", div).val(settings._iDisplayLength).on("change.DT", function() {
      _fnLengthChange2(settings, $3(this).val());
      _fnDraw2(settings);
    });
    $3(settings.nTable).on("length.dt.DT", function(e, s, len) {
      if (settings === s) {
        $3("select", div).val(len);
        updateEntries(len);
      }
    });
    updateEntries(settings._iDisplayLength);
    return div;
  }, "l");
  $3.fn.dataTable = DataTable2;
  DataTable2.$ = $3;
  $3.fn.dataTableSettings = DataTable2.settings;
  $3.fn.dataTableExt = DataTable2.ext;
  $3.fn.DataTable = function(opts) {
    return $3(this).dataTable(opts).api();
  };
  $3.each(DataTable2, function(prop, val) {
    $3.fn.DataTable[prop] = val;
  });
  var dataTables_default2 = DataTable2;

  // node_modules/datatables.net-fixedcolumns-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs
  var $4 = import_jquery4.default;
  $4.extend(true, dataTables_default2.defaults, {
    renderer: "bootstrap"
  });
  $4.extend(true, dataTables_default2.ext.classes, {
    container: "dt-container dt-bootstrap5",
    search: {
      input: "form-control form-control-sm"
    },
    length: {
      select: "form-select form-select-sm"
    },
    processing: {
      container: "dt-processing card"
    }
  });
  dataTables_default2.ext.renderer.pagingButton.bootstrap = function(settings, buttonType, content, active, disabled) {
    var btnClasses = ["dt-paging-button", "page-item"];
    if (active) {
      btnClasses.push("active");
    }
    if (disabled) {
      btnClasses.push("disabled");
    }
    var li = $4("<li>").addClass(btnClasses.join(" "));
    var a = $4("<a>", {
      "href": disabled ? null : "#",
      "class": "page-link"
    }).html(content).appendTo(li);
    return {
      display: li,
      clicker: a
    };
  };
  dataTables_default2.ext.renderer.pagingContainer.bootstrap = function(settings, buttonEls) {
    return $4("<ul/>").addClass("pagination").append(buttonEls);
  };
  dataTables_default2.ext.renderer.layout.bootstrap = function(settings, container, items) {
    var row = $4("<div/>", {
      "class": items.full ? "row mt-2 justify-content-md-center" : "row mt-2 justify-content-between"
    }).appendTo(container);
    $4.each(items, function(key, val) {
      var klass;
      if (val.table) {
        klass = "col-12";
      } else if (key === "start") {
        klass = "col-md-auto me-auto";
      } else if (key === "end") {
        klass = "col-md-auto ms-auto";
      } else {
        klass = "col-md";
      }
      $4("<div/>", {
        id: val.id || null,
        "class": klass + " " + (val.className || "")
      }).append(val.contents).appendTo(row);
    });
  };

  // node_modules/datatables.net-fixedcolumns/js/dataTables.fixedColumns.mjs
  var import_jquery6 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-fixedcolumns/node_modules/datatables.net/js/dataTables.mjs
  var import_jquery5 = __toESM(require_jquery(), 1);
  var $5 = import_jquery5.default;
  var DataTable3 = function(selector, options) {
    if (DataTable3.factory(selector, options)) {
      return DataTable3;
    }
    if (this instanceof DataTable3) {
      return $5(selector).DataTable(options);
    } else {
      options = selector;
    }
    var _that = this;
    var emptyInit = options === void 0;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.api = function() {
      return new _Api3(this);
    };
    this.each(function() {
      var o = {};
      var oInit = len > 1 ? (
        // optimisation for single table case
        _fnExtend3(o, options, true)
      ) : options;
      var i = 0, iLen;
      var sId = this.getAttribute("id");
      var bInitHandedOff = false;
      var defaults = DataTable3.defaults;
      var $this = $5(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog3(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      $5(this).trigger("options.dt", oInit);
      _fnCompatOpts3(defaults);
      _fnCompatCols3(defaults.column);
      _fnCamelToHungarian3(defaults, defaults, true);
      _fnCamelToHungarian3(defaults.column, defaults.column, true);
      _fnCamelToHungarian3(defaults, $5.extend(oInit, $this.data()), true);
      var allSettings = DataTable3.settings;
      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            new DataTable3.Api(s).destroy();
            break;
          } else {
            _fnLog3(s, 0, "Cannot reinitialise DataTable", 3);
            return;
          }
        }
        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable3.ext._unique++;
        this.id = sId;
      }
      var oSettings = $5.extend(true, {}, DataTable3.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId,
        colgroup: $5("<colgroup>").prependTo(this),
        fastData: function(row, column, type) {
          return _fnGetCellData3(oSettings, row, column, type);
        }
      });
      oSettings.nTable = this;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.api = new _Api3(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts3(oInit);
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : $5.isPlainObject(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0].value : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend3($5.extend(true, {}, defaults), oInit);
      _fnMap3(oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ]);
      _fnMap3(oSettings, oInit, [
        "ajax",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "iStateDuration",
        "bSortCellsTop",
        "iTabIndex",
        "sDom",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        "caption",
        "layout",
        ["iCookieDuration", "iStateDuration"],
        // backwards compat
        ["oSearch", "oPreviousSearch"],
        ["aoSearchCols", "aoPreSearchCols"],
        ["iDisplayLength", "_iDisplayLength"]
      ]);
      _fnMap3(oSettings.oScroll, oInit, [
        ["sScrollX", "sX"],
        ["sScrollXInner", "sXInner"],
        ["sScrollY", "sY"],
        ["bScrollCollapse", "bCollapse"]
      ]);
      _fnMap3(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg3(oSettings, "aoDrawCallback", oInit.fnDrawCallback);
      _fnCallbackReg3(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams);
      _fnCallbackReg3(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams);
      _fnCallbackReg3(oSettings, "aoStateLoaded", oInit.fnStateLoaded);
      _fnCallbackReg3(oSettings, "aoRowCallback", oInit.fnRowCallback);
      _fnCallbackReg3(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow);
      _fnCallbackReg3(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback);
      _fnCallbackReg3(oSettings, "aoFooterCallback", oInit.fnFooterCallback);
      _fnCallbackReg3(oSettings, "aoInitComplete", oInit.fnInitComplete);
      _fnCallbackReg3(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback);
      oSettings.rowIdFn = _fnGetObjectDataFn3(oInit.rowId);
      _fnBrowserDetect3(oSettings);
      var oClasses = oSettings.oClasses;
      $5.extend(oClasses, DataTable3.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.table);
      if (!oSettings.oFeatures.bPaginate) {
        oInit.iDisplayStart = 0;
      }
      if (oSettings.iInitDisplayStart === void 0) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      var oLanguage = oSettings.oLanguage;
      $5.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl) {
        $5.ajax({
          dataType: "json",
          url: oLanguage.sUrl,
          success: function(json) {
            _fnCamelToHungarian3(defaults.oLanguage, json);
            $5.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
            _fnCallbackFire3(oSettings, null, "i18n", [oSettings], true);
            _fnInitialise3(oSettings);
          },
          error: function() {
            _fnLog3(oSettings, 0, "i18n file loading error", 21);
            _fnInitialise3(oSettings);
          }
        });
        bInitHandedOff = true;
      } else {
        _fnCallbackFire3(oSettings, null, "i18n", [oSettings]);
      }
      var columnsInit = [];
      var thead = this.getElementsByTagName("thead");
      var initHeaderLayout = _fnDetectHeader3(oSettings, thead[0]);
      if (oInit.aoColumns) {
        columnsInit = oInit.aoColumns;
      } else if (initHeaderLayout.length) {
        for (i = 0, iLen = initHeaderLayout[0].length; i < iLen; i++) {
          columnsInit.push(null);
        }
      }
      for (i = 0, iLen = columnsInit.length; i < iLen; i++) {
        _fnAddColumn3(oSettings);
      }
      _fnApplyColumnDefs3(oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function(iCol, oDef) {
        _fnColumnOptions3(oSettings, iCol, oDef);
      });
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if (rowOne.length) {
        var a = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $5(rowOne[0]).children("th, td").each(function(i2, cell) {
          var col = oSettings.aoColumns[i2];
          if (!col) {
            _fnLog3(oSettings, 0, "Incorrect column count", 18);
          }
          if (col.mData === i2) {
            var sort = a(cell, "sort") || a(cell, "order");
            var filter = a(cell, "filter") || a(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {
                _: i2 + ".display",
                sort: sort !== null ? i2 + ".@data-" + sort : void 0,
                type: sort !== null ? i2 + ".@data-" + sort : void 0,
                filter: filter !== null ? i2 + ".@data-" + filter : void 0
              };
              col._isArrayHost = true;
              _fnColumnOptions3(oSettings, i2);
            }
          }
        });
      }
      var features = oSettings.oFeatures;
      var loadedInit = function() {
        if (oInit.aaSorting === void 0) {
          var sorting = oSettings.aaSorting;
          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        _fnSortingClasses3(oSettings);
        _fnCallbackReg3(oSettings, "aoDrawCallback", function() {
          if (oSettings.bSorted || _fnDataSource3(oSettings) === "ssp" || features.bDeferRender) {
            _fnSortingClasses3(oSettings);
          }
        });
        var caption = $this.children("caption");
        if (oSettings.caption) {
          if (caption.length === 0) {
            caption = $5("<caption/>").appendTo($this);
          }
          caption.html(oSettings.caption);
        }
        if (caption.length) {
          caption[0]._captionSide = caption.css("caption-side");
          oSettings.captionNode = caption[0];
        }
        if (thead.length === 0) {
          thead = $5("<thead/>").appendTo($this);
        }
        oSettings.nTHead = thead[0];
        $5("tr", thead).addClass(oClasses.thead.row);
        var tbody = $this.children("tbody");
        if (tbody.length === 0) {
          tbody = $5("<tbody/>").insertAfter(thead);
        }
        oSettings.nTBody = tbody[0];
        var tfoot = $this.children("tfoot");
        if (tfoot.length === 0) {
          tfoot = $5("<tfoot/>").appendTo($this);
        }
        oSettings.nTFoot = tfoot[0];
        $5("tr", tfoot).addClass(oClasses.tfoot.row);
        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData3(oSettings, oInit.aaData[i]);
          }
        } else if (_fnDataSource3(oSettings) == "dom") {
          _fnAddTr3(oSettings, $5(oSettings.nTBody).children("tr"));
        }
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        oSettings.bInitialised = true;
        if (bInitHandedOff === false) {
          _fnInitialise3(oSettings);
        }
      };
      _fnCallbackReg3(oSettings, "aoDrawCallback", _fnSaveState3);
      if (oInit.bStateSave) {
        features.bStateSave = true;
        _fnLoadState3(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  DataTable3.ext = _ext3 = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",
    /**
     * Legacy so v1 plug-ins don't throw js errors on load
     */
    feature: [],
    /**
     * Feature plug-ins.
     * 
     * This is an object of callbacks which provide the features for DataTables
     * to be initialised via the `layout` option.
     */
    features: {},
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Automatic column class assignment
       */
      className: {},
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
      /**
       * Automatic renderer assignment
       */
      render: {},
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatibility only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable3.fnVersionCheck,
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable3.version
  };
  $5.extend(_ext3, {
    afnFiltering: _ext3.search,
    aTypes: _ext3.type.detect,
    ofnSearch: _ext3.type.search,
    oSort: _ext3.type.order,
    afnSortData: _ext3.order,
    aoFeatures: _ext3.feature,
    oStdClasses: _ext3.classes,
    oPagination: _ext3.pager
  });
  $5.extend(DataTable3.ext.classes, {
    container: "dt-container",
    empty: {
      row: "dt-empty"
    },
    info: {
      container: "dt-info"
    },
    length: {
      container: "dt-length",
      select: "dt-input"
    },
    order: {
      canAsc: "dt-orderable-asc",
      canDesc: "dt-orderable-desc",
      isAsc: "dt-ordering-asc",
      isDesc: "dt-ordering-desc",
      none: "dt-orderable-none",
      position: "sorting_"
    },
    processing: {
      container: "dt-processing"
    },
    scrolling: {
      body: "dt-scroll-body",
      container: "dt-scroll",
      footer: {
        self: "dt-scroll-foot",
        inner: "dt-scroll-footInner"
      },
      header: {
        self: "dt-scroll-head",
        inner: "dt-scroll-headInner"
      }
    },
    search: {
      container: "dt-search",
      input: "dt-input"
    },
    table: "dataTable",
    tbody: {
      cell: "",
      row: ""
    },
    thead: {
      cell: "",
      row: ""
    },
    tfoot: {
      cell: "",
      row: ""
    },
    paging: {
      active: "current",
      button: "dt-paging-button",
      container: "dt-paging",
      disabled: "disabled"
    }
  });
  var _ext3;
  var _Api3;
  var _api_register3;
  var _api_registerPlural3;
  var _re_dic3 = {};
  var _re_new_lines3 = /[\r\n\u2028]/g;
  var _re_html3 = /<([^>]*>)/g;
  var _max_str_len3 = Math.pow(2, 28);
  var _re_date3 = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;
  var _re_escape_regex3 = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric3 = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty3 = function(d) {
    return !d || d === true || d === "-" ? true : false;
  };
  var _intVal3 = function(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  var _numToDecimal3 = function(num, decimalPoint) {
    if (!_re_dic3[decimalPoint]) {
      _re_dic3[decimalPoint] = new RegExp(_fnEscapeRegex3(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic3[decimalPoint], ".") : num;
  };
  var _isNumber3 = function(d, decimalPoint, formatted) {
    var type = typeof d;
    var strType = type === "string";
    if (type === "number" || type === "bigint") {
      return true;
    }
    if (_empty3(d)) {
      return true;
    }
    if (decimalPoint && strType) {
      d = _numToDecimal3(d, decimalPoint);
    }
    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric3, "");
    }
    return !isNaN(parseFloat(d)) && isFinite(d);
  };
  var _isHtml3 = function(d) {
    return _empty3(d) || typeof d === "string";
  };
  var _htmlNumeric3 = function(d, decimalPoint, formatted) {
    if (_empty3(d)) {
      return true;
    }
    if (typeof d === "string" && d.match(/<(input|select)/i)) {
      return null;
    }
    var html = _isHtml3(d);
    return !html ? null : _isNumber3(_stripHtml3(d), decimalPoint, formatted) ? true : null;
  };
  var _pluck3 = function(a, prop, prop2) {
    var out = [];
    var i = 0, ien = a.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order3 = function(a, order, prop, prop2) {
    var out = [];
    var i = 0, ien = order.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[order[i]]) {
          out.push(a[order[i]][prop]);
        }
      }
    }
    return out;
  };
  var _range3 = function(len, start) {
    var out = [];
    var end;
    if (start === void 0) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }
    for (var i = start; i < end; i++) {
      out.push(i);
    }
    return out;
  };
  var _removeEmpty3 = function(a) {
    var out = [];
    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        out.push(a[i]);
      }
    }
    return out;
  };
  var _stripHtml3 = function(input) {
    if (input.length > _max_str_len3) {
      throw new Error("Exceeded max str len");
    }
    var previous;
    input = input.replace(_re_html3, "");
    do {
      previous = input;
      input = input.replace(/<script/i, "");
    } while (input !== previous);
    return previous;
  };
  var _escapeHtml3 = function(d) {
    if (Array.isArray(d)) {
      d = d.join(",");
    }
    return typeof d === "string" ? d.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d;
  };
  var _normalize3 = function(str, both) {
    if (typeof str !== "string") {
      return str;
    }
    var res = str.normalize("NFD");
    return res.length !== str.length ? (both === true ? str + " " : "") + res.replace(/[\u0300-\u036f]/g, "") : res;
  };
  var _areAllUnique3 = function(src) {
    if (src.length < 2) {
      return true;
    }
    var sorted = src.slice().sort();
    var last = sorted[0];
    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }
      last = sorted[i];
    }
    return true;
  };
  var _unique3 = function(src) {
    if (Array.from && Set) {
      return Array.from(new Set(src));
    }
    if (_areAllUnique3(src)) {
      return src.slice();
    }
    var out = [], val, i, ien = src.length, j, k = 0;
    again: for (i = 0; i < ien; i++) {
      val = src[i];
      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }
      out.push(val);
      k++;
    }
    return out;
  };
  var _flatten3 = function(out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten3(out, val[i]);
      }
    } else {
      out.push(val);
    }
    return out;
  };
  function _addClass3(el, name) {
    if (name) {
      name.split(" ").forEach(function(n) {
        if (n) {
          el.classList.add(n);
        }
      });
    }
  }
  DataTable3.util = {
    /**
     * Return a string with diacritic characters decomposed
     * @param {*} mixed Function or string to normalize
     * @param {*} both Return original string and the normalized string
     * @returns String or undefined
     */
    diacritics: function(mixed, both) {
      var type = typeof mixed;
      if (type !== "function") {
        return _normalize3(mixed, both);
      }
      _normalize3 = mixed;
    },
    /**
     * Debounce a function
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    debounce: function(fn, timeout) {
      var timer;
      return function() {
        var that = this;
        var args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(that, args);
        }, timeout || 250);
      };
    },
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function(fn, freq) {
      var frequency = freq !== void 0 ? freq : 200, last, timer;
      return function() {
        var that = this, now = +/* @__PURE__ */ new Date(), args = arguments;
        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            last = void 0;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },
    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function(val) {
      return val.replace(_re_escape_regex3, "\\$1");
    },
    /**
     * Create a function that will write to a nested object or array
     * @param {*} source JSON notation string
     * @returns Write function
     */
    set: function(source) {
      if ($5.isPlainObject(source)) {
        return DataTable3.util.set(source._);
      } else if (source === null) {
        return function() {
        };
      } else if (typeof source === "function") {
        return function(data, val, meta) {
          source(data, "set", val, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var setData = function(data, val, src) {
          var a = _fnSplitObjNotation3(src), b;
          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;
          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            if (a[i] === "__proto__" || a[i] === "constructor") {
              throw new Error("Cannot set prototype values");
            }
            arrayNotation = a[i].match(__reArray3);
            funcNotation = a[i].match(__reFn3);
            if (arrayNotation) {
              a[i] = a[i].replace(__reArray3, "");
              data[a[i]] = [];
              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join(".");
              if (Array.isArray(val)) {
                for (var j = 0, jLen = val.length; j < jLen; j++) {
                  o = {};
                  setData(o, val[j], innerSrc);
                  data[a[i]].push(o);
                }
              } else {
                data[a[i]] = val;
              }
              return;
            } else if (funcNotation) {
              a[i] = a[i].replace(__reFn3, "");
              data = data[a[i]](val);
            }
            if (data[a[i]] === null || data[a[i]] === void 0) {
              data[a[i]] = {};
            }
            data = data[a[i]];
          }
          if (aLast.match(__reFn3)) {
            data = data[aLast.replace(__reFn3, "")](val);
          } else {
            data[aLast.replace(__reArray3, "")] = val;
          }
        };
        return function(data, val) {
          return setData(data, val, source);
        };
      } else {
        return function(data, val) {
          data[source] = val;
        };
      }
    },
    /**
     * Create a function that will read nested objects from arrays, based on JSON notation
     * @param {*} source JSON notation string
     * @returns Value read
     */
    get: function(source) {
      if ($5.isPlainObject(source)) {
        var o = {};
        $5.each(source, function(key, val) {
          if (val) {
            o[key] = DataTable3.util.get(val);
          }
        });
        return function(data, type, row, meta) {
          var t = o[type] || o._;
          return t !== void 0 ? t(data, type, row, meta) : data;
        };
      } else if (source === null) {
        return function(data) {
          return data;
        };
      } else if (typeof source === "function") {
        return function(data, type, row, meta) {
          return source(data, type, row, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var fetchData = function(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== "") {
            var a = _fnSplitObjNotation3(src);
            for (var i = 0, iLen = a.length; i < iLen; i++) {
              arrayNotation = a[i].match(__reArray3);
              funcNotation = a[i].match(__reFn3);
              if (arrayNotation) {
                a[i] = a[i].replace(__reArray3, "");
                if (a[i] !== "") {
                  data = data[a[i]];
                }
                out = [];
                a.splice(0, i + 1);
                innerSrc = a.join(".");
                if (Array.isArray(data)) {
                  for (var j = 0, jLen = data.length; j < jLen; j++) {
                    out.push(fetchData(data[j], type, innerSrc));
                  }
                }
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join);
                break;
              } else if (funcNotation) {
                a[i] = a[i].replace(__reFn3, "");
                data = data[a[i]]();
                continue;
              }
              if (data === null || data[a[i]] === null) {
                return null;
              } else if (data === void 0 || data[a[i]] === void 0) {
                return void 0;
              }
              data = data[a[i]];
            }
          }
          return data;
        };
        return function(data, type) {
          return fetchData(data, type, source);
        };
      } else {
        return function(data) {
          return data[source];
        };
      }
    },
    stripHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _stripHtml3 = mixed;
        return;
      } else if (type === "string") {
        return _stripHtml3(mixed);
      }
      return mixed;
    },
    escapeHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _escapeHtml3 = mixed;
        return;
      } else if (type === "string" || Array.isArray(mixed)) {
        return _escapeHtml3(mixed);
      }
      return mixed;
    },
    unique: _unique3
  };
  function _fnHungarianMap3(o) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map2 = {};
    $5.each(o, function(key) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map2[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap3(o[key]);
        }
      }
    });
    o._hungarianMap = map2;
  }
  function _fnCamelToHungarian3(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap3(src);
    }
    var hungarianKey;
    $5.each(user, function(key) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $5.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian3(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  var _fnCompatMap3 = function(o, knew, old) {
    if (o[knew] !== void 0) {
      o[old] = o[knew];
    }
  };
  function _fnCompatOpts3(init2) {
    _fnCompatMap3(init2, "ordering", "bSort");
    _fnCompatMap3(init2, "orderMulti", "bSortMulti");
    _fnCompatMap3(init2, "orderClasses", "bSortClasses");
    _fnCompatMap3(init2, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap3(init2, "order", "aaSorting");
    _fnCompatMap3(init2, "orderFixed", "aaSortingFixed");
    _fnCompatMap3(init2, "paging", "bPaginate");
    _fnCompatMap3(init2, "pagingType", "sPaginationType");
    _fnCompatMap3(init2, "pageLength", "iDisplayLength");
    _fnCompatMap3(init2, "searching", "bFilter");
    if (typeof init2.sScrollX === "boolean") {
      init2.sScrollX = init2.sScrollX ? "100%" : "";
    }
    if (typeof init2.scrollX === "boolean") {
      init2.scrollX = init2.scrollX ? "100%" : "";
    }
    var searchCols = init2.aoSearchCols;
    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian3(DataTable3.models.oSearch, searchCols[i]);
        }
      }
    }
    if (init2.serverSide && !init2.searchDelay) {
      init2.searchDelay = 400;
    }
  }
  function _fnCompatCols3(init2) {
    _fnCompatMap3(init2, "orderable", "bSortable");
    _fnCompatMap3(init2, "orderData", "aDataSort");
    _fnCompatMap3(init2, "orderSequence", "asSorting");
    _fnCompatMap3(init2, "orderDataType", "sortDataType");
    var dataSort = init2.aDataSort;
    if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
      init2.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect3(settings) {
    if (!DataTable3.__browser) {
      var browser = {};
      DataTable3.__browser = browser;
      var n = $5("<div/>").css({
        position: "fixed",
        top: 0,
        left: -1 * window.pageXOffset,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(
        $5("<div/>").css({
          position: "absolute",
          top: 1,
          left: 1,
          width: 100,
          overflow: "scroll"
        }).append(
          $5("<div/>").css({
            width: "100%",
            height: 10
          })
        )
      ).appendTo("body");
      var outer = n.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      n.remove();
    }
    $5.extend(settings.oBrowser, DataTable3.__browser);
    settings.oScroll.iBarWidth = DataTable3.__browser.barWidth;
  }
  function _fnAddColumn3(oSettings) {
    var oDefaults = DataTable3.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $5.extend({}, DataTable3.models.oColumn, oDefaults, {
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol,
      searchFixed: {},
      colEl: $5("<col>").attr("data-dt-column", iCol)
    });
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $5.extend({}, DataTable3.models.oSearch, searchCols[iCol]);
  }
  function _fnColumnOptions3(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    if (oOptions !== void 0 && oOptions !== null) {
      _fnCompatCols3(oOptions);
      _fnCamelToHungarian3(DataTable3.defaults.column, oOptions, true);
      if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      var origClass = oCol.sClass;
      $5.extend(oCol, oOptions);
      _fnMap3(oCol, oOptions, "sWidth", "sWidthOrig");
      if (origClass !== oCol.sClass) {
        oCol.sClass = origClass + " " + oCol.sClass;
      }
      if (oOptions.iDataSort !== void 0) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap3(oCol, oOptions, "aDataSort");
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn3(mDataSrc);
    if (oCol.mRender && Array.isArray(oCol.mRender)) {
      var copy = oCol.mRender.slice();
      var name = copy.shift();
      oCol.mRender = DataTable3.render[name].apply(window, copy);
    }
    oCol._render = oCol.mRender ? _fnGetObjectDataFn3(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $5.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, void 0, meta);
      return oCol._render && type ? oCol._render(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn3(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
    }
  }
  function _fnAdjustColumnSizing3(settings) {
    _fnCalculateColumnWidths3(settings);
    _fnColumnSizes3(settings);
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw3(settings);
    }
    _fnCallbackFire3(settings, null, "column-sizing", [settings]);
  }
  function _fnColumnSizes3(settings) {
    var cols = settings.aoColumns;
    for (var i = 0; i < cols.length; i++) {
      var width = _fnColumnsSumWidth3(settings, [i], false, false);
      cols[i].colEl.css("width", width);
    }
  }
  function _fnVisibleToColumnIndex3(oSettings, iMatch) {
    var aiVis = _fnGetColumns3(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible3(oSettings, iMatch) {
    var aiVis = _fnGetColumns3(oSettings, "bVisible");
    var iPos = aiVis.indexOf(iMatch);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns3(settings) {
    var layout = settings.aoHeader;
    var columns = settings.aoColumns;
    var vis = 0;
    if (layout.length) {
      for (var i = 0, ien = layout[0].length; i < ien; i++) {
        if (columns[i].bVisible && $5(layout[0][i].cell).css("display") !== "none") {
          vis++;
        }
      }
    }
    return vis;
  }
  function _fnGetColumns3(oSettings, sParam) {
    var a = [];
    oSettings.aoColumns.map(function(val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  function _fnColumnTypes3(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable3.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, detectedType, cache;
    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            if (!data[k]) {
              continue;
            }
            if (cache[k] === void 0) {
              cache[k] = _fnGetCellData3(settings, k, i, "type");
            }
            detectedType = types[j](cache[k], settings);
            if (!detectedType && j !== types.length - 2) {
              break;
            }
            if (detectedType === "html" && !_empty3(cache[k])) {
              break;
            }
          }
          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        if (!col.sType) {
          col.sType = "string";
        }
      }
      var autoClass = _ext3.type.className[col.sType];
      if (autoClass) {
        _columnAutoClass3(settings.aoHeader, i, autoClass);
        _columnAutoClass3(settings.aoFooter, i, autoClass);
      }
      var renderer = _ext3.type.render[col.sType];
      if (renderer && !col._render) {
        col._render = DataTable3.util.get(renderer);
        _columnAutoRender3(settings, i);
      }
    }
  }
  function _columnAutoRender3(settings, colIdx) {
    var data = settings.aoData;
    for (var i = 0; i < data.length; i++) {
      if (data[i].nTr) {
        var display = _fnGetCellData3(settings, i, colIdx, "display");
        data[i].displayData[colIdx] = display;
        _fnWriteCell3(data[i].anCells[colIdx], display);
      }
    }
  }
  function _columnAutoClass3(container, colIdx, className) {
    container.forEach(function(row) {
      if (row[colIdx] && row[colIdx].unique) {
        _addClass3(row[colIdx].cell, className);
      }
    });
  }
  function _fnApplyColumnDefs3(oSettings, aoColDefs, aoCols, headerLayout, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        if (aoCols[i] && aoCols[i].name) {
          columns[i].sName = aoCols[i].name;
        }
      }
    }
    if (aoColDefs) {
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        var aTargets = def.target !== void 0 ? def.target : def.targets !== void 0 ? def.targets : def.aTargets;
        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          var target = aTargets[j];
          if (typeof target === "number" && target >= 0) {
            while (columns.length <= target) {
              _fnAddColumn3(oSettings);
            }
            fn(target, def);
          } else if (typeof target === "number" && target < 0) {
            fn(columns.length + target, def);
          } else if (typeof target === "string") {
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (target === "_all") {
                fn(k, def);
              } else if (target.indexOf(":name") !== -1) {
                if (columns[k].sName === target.replace(":name", "")) {
                  fn(k, def);
                }
              } else {
                headerLayout.forEach(function(row) {
                  if (row[k]) {
                    var cell = $5(row[k].cell);
                    if (target.match(/^[a-z][\w-]*$/i)) {
                      target = "." + target;
                    }
                    if (cell.is(target)) {
                      fn(k, def);
                    }
                  }
                });
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  function _fnColumnsSumWidth3(settings, targets, original, incVisible) {
    if (!Array.isArray(targets)) {
      targets = _fnColumnsFromHeader3(targets);
    }
    var sum = 0;
    var unit;
    var columns = settings.aoColumns;
    for (var i = 0, ien = targets.length; i < ien; i++) {
      var column = columns[targets[i]];
      var definedWidth = original ? column.sWidthOrig : column.sWidth;
      if (!incVisible && column.bVisible === false) {
        continue;
      }
      if (definedWidth === null || definedWidth === void 0) {
        return null;
      } else if (typeof definedWidth === "number") {
        unit = "px";
        sum += definedWidth;
      } else {
        var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);
        if (matched) {
          sum += matched[1] * 1;
          unit = matched.length === 3 ? matched[2] : "px";
        }
      }
    }
    return sum + unit;
  }
  function _fnColumnsFromHeader3(cell) {
    var attr = $5(cell).closest("[data-dt-column]").attr("data-dt-column");
    if (!attr) {
      return [];
    }
    return attr.split(",").map(function(val) {
      return val * 1;
    });
  }
  function _fnAddData3(settings, dataIn, tr, tds) {
    var rowIdx = settings.aoData.length;
    var rowModel = $5.extend(true, {}, DataTable3.models.oRow, {
      src: tr ? "dom" : "data",
      idx: rowIdx
    });
    rowModel._aData = dataIn;
    settings.aoData.push(rowModel);
    var columns = settings.aoColumns;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    settings.aiDisplayMaster.push(rowIdx);
    var id = settings.rowIdFn(dataIn);
    if (id !== void 0) {
      settings.aIds[id] = rowModel;
    }
    if (tr || !settings.oFeatures.bDeferRender) {
      _fnCreateTr3(settings, rowIdx, tr, tds);
    }
    return rowIdx;
  }
  function _fnAddTr3(settings, trs) {
    var row;
    if (!(trs instanceof $5)) {
      trs = $5(trs);
    }
    return trs.map(function(i, el) {
      row = _fnGetRowElements3(settings, el);
      return _fnAddData3(settings, row.data, el, row.cells);
    });
  }
  function _fnGetCellData3(settings, rowIdx, colIdx, type) {
    if (type === "search") {
      type = "filter";
    } else if (type === "order") {
      type = "sort";
    }
    var row = settings.aoData[rowIdx];
    if (!row) {
      return void 0;
    }
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = row._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings,
      row: rowIdx,
      col: colIdx
    });
    if (type !== "display" && cellData && typeof cellData === "object" && cellData.nodeName) {
      cellData = cellData.innerHTML;
    }
    if (cellData === void 0) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog3(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
      cellData = defaultContent;
    } else if (typeof cellData === "function") {
      return cellData.call(rowData);
    }
    if (cellData === null && type === "display") {
      return "";
    }
    if (type === "filter") {
      var fomatters = DataTable3.ext.type.search;
      if (fomatters[col.sType]) {
        cellData = fomatters[col.sType](cellData);
      }
    }
    return cellData;
  }
  function _fnSetCellData3(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings,
      row: rowIdx,
      col: colIdx
    });
  }
  function _fnWriteCell3(td, val) {
    if (val && typeof val === "object" && val.nodeName) {
      $5(td).empty().append(val);
    } else {
      td.innerHTML = val;
    }
  }
  var __reArray3 = /\[.*?\]$/;
  var __reFn3 = /\(\)$/;
  function _fnSplitObjNotation3(str) {
    var parts = str.match(/(\\.|[^.])+/g) || [""];
    return parts.map(function(s) {
      return s.replace(/\\\./g, ".");
    });
  }
  var _fnGetObjectDataFn3 = DataTable3.util.get;
  var _fnSetObjectDataFn3 = DataTable3.util.set;
  function _fnGetDataMaster3(settings) {
    return _pluck3(settings.aoData, "_aData");
  }
  function _fnClearTable3(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnInvalidate3(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;
    row._aSortData = null;
    row._aFilterData = null;
    row.displayData = null;
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements3(
        settings,
        row,
        colIdx,
        colIdx === void 0 ? void 0 : row._aData
      ).data;
    } else {
      var cells = row.anCells;
      var display = _fnGetRowDisplay3(settings, rowIdx);
      if (cells) {
        if (colIdx !== void 0) {
          _fnWriteCell3(cells[colIdx], display[colIdx]);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            _fnWriteCell3(cells[i], display[i]);
          }
        }
      }
    }
    var cols = settings.aoColumns;
    if (colIdx !== void 0) {
      cols[colIdx].sType = null;
      cols[colIdx].maxLenString = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
        cols[i].maxLenString = null;
      }
      _fnRowAttributes3(settings, row);
    }
  }
  function _fnGetRowElements3(settings, row, colIdx, d) {
    var tds = [], td = row.firstChild, name, col, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d = d !== void 0 ? d : objectRead ? {} : [];
    var attr = function(str, td2) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr2 = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn3(str);
          setter(d, td2.getAttribute(attr2));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === void 0 || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn3(col.mData._);
          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn3(col.mData);
            }
            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }
      i++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn3(settings.rowId)(d, id);
      }
    }
    return {
      data: d,
      cells: tds
    };
  }
  function _fnGetRowDisplay3(settings, rowIdx) {
    let rowModal = settings.aoData[rowIdx];
    let columns = settings.aoColumns;
    if (!rowModal.displayData) {
      rowModal.displayData = [];
      for (var colIdx = 0, len = columns.length; colIdx < len; colIdx++) {
        rowModal.displayData.push(
          _fnGetCellData3(settings, rowIdx, colIdx, "display")
        );
      }
    }
    return rowModal.displayData;
  }
  function _fnCreateTr3(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create, trClass = oSettings.oClasses.tbody.row;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      _addClass3(nTr, trClass);
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes3(oSettings, row);
      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn && anTds[i] ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        if (!nTd) {
          _fnLog3(oSettings, 0, "Incorrect column count", 18);
        }
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd);
        var display = _fnGetRowDisplay3(oSettings, iRow);
        if (create || (oCol.mRender || oCol.mData !== i) && (!$5.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
          _fnWriteCell3(nTd, display[i]);
        }
        if (oCol.bVisible && create) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && !create) {
          nTd.parentNode.removeChild(nTd);
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(
            oSettings.oInstance,
            nTd,
            _fnGetCellData3(oSettings, iRow, i),
            rowData,
            iRow,
            i
          );
        }
      }
      _fnCallbackFire3(oSettings, "aoRowCreatedCallback", "row-created", [nTr, rowData, iRow, cells]);
    } else {
      _addClass3(row.nTr, trClass);
    }
  }
  function _fnRowAttributes3(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique3(row.__rowc.concat(a)) : a;
        $5(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $5(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $5(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead3(settings, side) {
    var classes = settings.oClasses;
    var columns = settings.aoColumns;
    var i, ien, row;
    var target = side === "header" ? settings.nTHead : settings.nTFoot;
    var titleProp = side === "header" ? "sTitle" : side;
    if (!target) {
      return;
    }
    if (side === "header" || _pluck3(settings.aoColumns, titleProp).join("")) {
      row = $5("tr", target);
      if (!row.length) {
        row = $5("<tr/>").appendTo(target);
      }
      if (row.length === 1) {
        var cells = $5("td, th", row);
        for (i = cells.length, ien = columns.length; i < ien; i++) {
          $5("<th/>").html(columns[i][titleProp] || "").appendTo(row);
        }
      }
    }
    var detected = _fnDetectHeader3(settings, target, true);
    if (side === "header") {
      settings.aoHeader = detected;
    } else {
      settings.aoFooter = detected;
    }
    $5(target).children("tr").attr("role", "row");
    $5(target).children("tr").children("th, td").each(function() {
      _fnRenderer3(settings, side)(
        settings,
        $5(this),
        classes
      );
    });
  }
  function _fnHeaderLayout3(settings, source, incColumns) {
    var row, column, cell;
    var local = [];
    var structure = [];
    var columns = settings.aoColumns;
    var columnCount = columns.length;
    var rowspan, colspan;
    if (!source) {
      return;
    }
    if (!incColumns) {
      incColumns = _range3(columnCount).filter(function(idx) {
        return columns[idx].bVisible;
      });
    }
    for (row = 0; row < source.length; row++) {
      local[row] = source[row].slice().filter(function(cell2, i) {
        return incColumns.includes(i);
      });
      structure.push([]);
    }
    for (row = 0; row < local.length; row++) {
      for (column = 0; column < local[row].length; column++) {
        rowspan = 1;
        colspan = 1;
        if (structure[row][column] === void 0) {
          cell = local[row][column].cell;
          while (local[row + rowspan] !== void 0 && local[row][column].cell == local[row + rowspan][column].cell) {
            structure[row + rowspan][column] = null;
            rowspan++;
          }
          while (local[row][column + colspan] !== void 0 && local[row][column].cell == local[row][column + colspan].cell) {
            for (var k = 0; k < rowspan; k++) {
              structure[row + k][column + colspan] = null;
            }
            colspan++;
          }
          var titleSpan = $5("span.dt-column-title", cell);
          structure[row][column] = {
            cell,
            colspan,
            rowspan,
            title: titleSpan.length ? titleSpan.html() : $5(cell).html()
          };
        }
      }
    }
    return structure;
  }
  function _fnDrawHead3(settings, source) {
    var layout = _fnHeaderLayout3(settings, source);
    var tr, n;
    for (var row = 0; row < source.length; row++) {
      tr = source[row].row;
      if (tr) {
        while (n = tr.firstChild) {
          tr.removeChild(n);
        }
      }
      for (var column = 0; column < layout[row].length; column++) {
        var point = layout[row][column];
        if (point) {
          $5(point.cell).appendTo(tr).attr("rowspan", point.rowspan).attr("colspan", point.colspan);
        }
      }
    }
  }
  function _fnDraw3(oSettings, ajaxComplete) {
    _fnStart3(oSettings);
    var aPreDraw = _fnCallbackFire3(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if (aPreDraw.indexOf(false) !== -1) {
      _fnProcessingDisplay3(oSettings, false);
      return;
    }
    var anRows = [];
    var iRowCount = 0;
    var bServerSide = _fnDataSource3(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    var columns = oSettings.aoColumns;
    var body = $5(oSettings.nTBody);
    oSettings.bDrawing = true;
    if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !ajaxComplete) {
      if (oSettings.iDraw === 0) {
        body.empty().append(_emptyRow3(oSettings));
      }
      _fnAjaxUpdate3(oSettings);
      return;
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr3(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        for (var i = 0; i < columns.length; i++) {
          var col = columns[i];
          var td = aoData.anCells[i];
          _addClass3(td, _ext3.type.className[col.sType]);
          _addClass3(td, col.sClass);
          _addClass3(td, oSettings.oClasses.tbody.cell);
        }
        _fnCallbackFire3(
          oSettings,
          "aoRowCallback",
          null,
          [nRow, aoData._aData, iRowCount, j, iDataIndex]
        );
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      anRows[0] = _emptyRow3(oSettings);
    }
    _fnCallbackFire3(oSettings, "aoHeaderCallback", "header", [
      $5(oSettings.nTHead).children("tr")[0],
      _fnGetDataMaster3(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    _fnCallbackFire3(oSettings, "aoFooterCallback", "footer", [
      $5(oSettings.nTFoot).children("tr")[0],
      _fnGetDataMaster3(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    if (body[0].replaceChildren) {
      body[0].replaceChildren.apply(body[0], anRows);
    } else {
      body.children().detach();
      body.append($5(anRows));
    }
    $5(oSettings.nTableWrapper).toggleClass("dt-empty-footer", $5("tr", oSettings.nTFoot).length === 0);
    _fnCallbackFire3(oSettings, "aoDrawCallback", "draw", [oSettings], true);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw3(settings, holdPosition, recompute) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (recompute === void 0 || recompute === true) {
      if (sort) {
        _fnSort3(settings);
      }
      if (filter) {
        _fnFilterComplete3(settings, settings.oPreviousSearch);
      } else {
        settings.aiDisplay = settings.aiDisplayMaster.slice();
      }
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw3(settings);
    settings._drawHold = false;
  }
  function _emptyRow3(settings) {
    var oLang = settings.oLanguage;
    var zero = oLang.sZeroRecords;
    var dataSrc = _fnDataSource3(settings);
    if (settings.iDraw < 1 && dataSrc === "ssp" || settings.iDraw <= 1 && dataSrc === "ajax") {
      zero = oLang.sLoadingRecords;
    } else if (oLang.sEmptyTable && settings.fnRecordsTotal() === 0) {
      zero = oLang.sEmptyTable;
    }
    return $5("<tr/>").append($5("<td />", {
      "colSpan": _fnVisbleColumns3(settings),
      "class": settings.oClasses.empty.row
    }).html(zero))[0];
  }
  function _layoutArray3(settings, layout, side) {
    var groups = {};
    $5.each(layout, function(pos, val) {
      if (val === null) {
        return;
      }
      var splitPos = pos.replace(/([A-Z])/g, " $1").split(" ");
      if (!groups[splitPos[0]]) {
        groups[splitPos[0]] = {};
      }
      var align = splitPos.length === 1 ? "full" : splitPos[1].toLowerCase();
      var group = groups[splitPos[0]];
      var groupRun = function(contents, innerVal) {
        if ($5.isPlainObject(innerVal)) {
          Object.keys(innerVal).map(function(key) {
            contents.push({
              feature: key,
              opts: innerVal[key]
            });
          });
        } else {
          contents.push(innerVal);
        }
      };
      if (!group[align] || !group[align].contents) {
        group[align] = { contents: [] };
      }
      if (Array.isArray(val)) {
        for (var i2 = 0; i2 < val.length; i2++) {
          groupRun(group[align].contents, val[i2]);
        }
      } else {
        groupRun(group[align].contents, val);
      }
      if (!Array.isArray(group[align].contents)) {
        group[align].contents = [group[align].contents];
      }
    });
    var filtered = Object.keys(groups).map(function(pos) {
      if (pos.indexOf(side) !== 0) {
        return null;
      }
      return {
        name: pos,
        val: groups[pos]
      };
    }).filter(function(item) {
      return item !== null;
    });
    filtered.sort(function(a, b) {
      var order1 = a.name.replace(/[^0-9]/g, "") * 1;
      var order2 = b.name.replace(/[^0-9]/g, "") * 1;
      return order2 - order1;
    });
    if (side === "bottom") {
      filtered.reverse();
    }
    var rows = [];
    for (var i = 0, ien = filtered.length; i < ien; i++) {
      if (filtered[i].val.full) {
        rows.push({ full: filtered[i].val.full });
        _layoutResolve3(settings, rows[rows.length - 1]);
        delete filtered[i].val.full;
      }
      if (Object.keys(filtered[i].val).length) {
        rows.push(filtered[i].val);
        _layoutResolve3(settings, rows[rows.length - 1]);
      }
    }
    return rows;
  }
  function _layoutResolve3(settings, row) {
    var getFeature = function(feature, opts) {
      if (!_ext3.features[feature]) {
        _fnLog3(settings, 0, "Unknown feature: " + feature);
      }
      return _ext3.features[feature].apply(this, [settings, opts]);
    };
    var resolve = function(item) {
      var line = row[item].contents;
      for (var i = 0, ien = line.length; i < ien; i++) {
        if (!line[i]) {
          continue;
        } else if (typeof line[i] === "string") {
          line[i] = getFeature(line[i], null);
        } else if ($5.isPlainObject(line[i])) {
          line[i] = getFeature(line[i].feature, line[i].opts);
        } else if (typeof line[i].node === "function") {
          line[i] = line[i].node(settings);
        } else if (typeof line[i] === "function") {
          var inst = line[i](settings);
          line[i] = typeof inst.node === "function" ? inst.node() : inst;
        }
      }
    };
    $5.each(row, function(key) {
      resolve(key);
    });
  }
  function _fnAddOptionsHtml3(settings) {
    var classes = settings.oClasses;
    var table = $5(settings.nTable);
    var insert = $5("<div/>").attr({
      id: settings.sTableId + "_wrapper",
      "class": classes.container
    }).insertBefore(table);
    settings.nTableWrapper = insert[0];
    if (settings.sDom) {
      _fnLayoutDom3(settings, settings.sDom, insert);
    } else {
      var top = _layoutArray3(settings, settings.layout, "top");
      var bottom = _layoutArray3(settings, settings.layout, "bottom");
      var renderer = _fnRenderer3(settings, "layout");
      top.forEach(function(item) {
        renderer(settings, insert, item);
      });
      renderer(settings, insert, {
        full: {
          table: true,
          contents: [_fnFeatureHtmlTable3(settings)]
        }
      });
      bottom.forEach(function(item) {
        renderer(settings, insert, item);
      });
    }
    _processingHtml3(settings);
  }
  function _fnLayoutDom3(settings, dom, insert) {
    var parts = dom.match(/(".*?")|('.*?')|./g);
    var featureNode, option, newNode, next, attr;
    for (var i = 0; i < parts.length; i++) {
      featureNode = null;
      option = parts[i];
      if (option == "<") {
        newNode = $5("<div/>");
        next = parts[i + 1];
        if (next[0] == "'" || next[0] == '"') {
          attr = next.replace(/['"]/g, "");
          var id = "", className;
          if (attr.indexOf(".") != -1) {
            var split = attr.split(".");
            id = split[0];
            className = split[1];
          } else if (attr[0] == "#") {
            id = attr;
          } else {
            className = attr;
          }
          newNode.attr("id", id.substring(1)).addClass(className);
          i++;
        }
        insert.append(newNode);
        insert = newNode;
      } else if (option == ">") {
        insert = insert.parent();
      } else if (option == "t") {
        featureNode = _fnFeatureHtmlTable3(settings);
      } else {
        DataTable3.ext.feature.forEach(function(feature) {
          if (option == feature.cFeature) {
            featureNode = feature.fnInit(settings);
          }
        });
      }
      if (featureNode) {
        insert.append(featureNode);
      }
    }
  }
  function _fnDetectHeader3(settings, thead, write) {
    var columns = settings.aoColumns;
    var rows = $5(thead).children("tr");
    var row, cell;
    var i, k, l, iLen, shifted, column, colspan, rowspan;
    var isHeader = thead && thead.nodeName.toLowerCase() === "thead";
    var layout = [];
    var unique;
    var shift = function(a, i2, j) {
      var k2 = a[i2];
      while (k2[j]) {
        j++;
      }
      return j;
    };
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      layout.push([]);
    }
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      row = rows[i];
      column = 0;
      cell = row.firstChild;
      while (cell) {
        if (cell.nodeName.toUpperCase() == "TD" || cell.nodeName.toUpperCase() == "TH") {
          var cols = [];
          colspan = cell.getAttribute("colspan") * 1;
          rowspan = cell.getAttribute("rowspan") * 1;
          colspan = !colspan || colspan === 0 || colspan === 1 ? 1 : colspan;
          rowspan = !rowspan || rowspan === 0 || rowspan === 1 ? 1 : rowspan;
          shifted = shift(layout, i, column);
          unique = colspan === 1 ? true : false;
          if (write) {
            if (unique) {
              _fnColumnOptions3(settings, shifted, $5(cell).data());
              var columnDef = columns[shifted];
              var width = cell.getAttribute("width") || null;
              var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
              if (t) {
                width = t[1];
              }
              columnDef.sWidthOrig = columnDef.sWidth || width;
              if (isHeader) {
                if (columnDef.sTitle !== null && !columnDef.autoTitle) {
                  cell.innerHTML = columnDef.sTitle;
                }
                if (!columnDef.sTitle && unique) {
                  columnDef.sTitle = _stripHtml3(cell.innerHTML);
                  columnDef.autoTitle = true;
                }
              } else {
                if (columnDef.footer) {
                  cell.innerHTML = columnDef.footer;
                }
              }
              if (!columnDef.ariaTitle) {
                columnDef.ariaTitle = $5(cell).attr("aria-label") || columnDef.sTitle;
              }
              if (columnDef.className) {
                $5(cell).addClass(columnDef.className);
              }
            }
            if ($5("span.dt-column-title", cell).length === 0) {
              $5("<span>").addClass("dt-column-title").append(cell.childNodes).appendTo(cell);
            }
            if (isHeader && $5("span.dt-column-order", cell).length === 0) {
              $5("<span>").addClass("dt-column-order").appendTo(cell);
            }
          }
          for (l = 0; l < colspan; l++) {
            for (k = 0; k < rowspan; k++) {
              layout[i + k][shifted + l] = {
                cell,
                unique
              };
              layout[i + k].row = row;
            }
            cols.push(shifted + l);
          }
          cell.setAttribute("data-dt-column", _unique3(cols).join(","));
        }
        cell = cell.nextSibling;
      }
    }
    return layout;
  }
  function _fnStart3(oSettings) {
    var bServerSide = _fnDataSource3(oSettings) == "ssp";
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
  }
  function _fnBuildAjax3(oSettings, data, fn) {
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
      if (json === null || typeof status === "number" && status == 204) {
        json = {};
        _fnAjaxDataSrc3(oSettings, json, []);
      }
      var error = json.error || json.sError;
      if (error) {
        _fnLog3(oSettings, 0, error);
      }
      oSettings.json = json;
      _fnCallbackFire3(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR], true);
      fn(json);
    };
    if ($5.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === "function" ? ajaxData(data, oSettings) : (
        // fn can manipulate data or return
        ajaxData
      );
      data = typeof ajaxData === "function" && newData ? newData : $5.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {
      "url": typeof ajax === "string" ? ajax : "",
      "data": data,
      "success": callback,
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function(xhr, error) {
        var ret = _fnCallbackFire3(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR], true);
        if (ret.indexOf(true) === -1) {
          if (error == "parsererror") {
            _fnLog3(oSettings, 0, "Invalid JSON response", 1);
          } else if (xhr.readyState === 4) {
            _fnLog3(oSettings, 0, "Ajax error", 7);
          }
        }
        _fnProcessingDisplay3(oSettings, false);
      }
    };
    if ($5.isPlainObject(ajax)) {
      $5.extend(baseAjax, ajax);
    }
    oSettings.oAjaxData = data;
    _fnCallbackFire3(oSettings, null, "preXhr", [oSettings, data, baseAjax], true);
    if (typeof ajax === "function") {
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else if (ajax.url === "") {
      var empty = {};
      DataTable3.util.set(ajax.dataSrc)(empty, []);
      callback(empty);
    } else {
      oSettings.jqXHR = $5.ajax(baseAjax);
      if (ajaxData) {
        ajax.data = ajaxData;
      }
    }
  }
  function _fnAjaxUpdate3(settings) {
    settings.iDraw++;
    _fnProcessingDisplay3(settings, true);
    _fnBuildAjax3(
      settings,
      _fnAjaxParameters3(settings),
      function(json) {
        _fnAjaxUpdateDraw3(settings, json);
      }
    );
  }
  function _fnAjaxParameters3(settings) {
    var columns = settings.aoColumns, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, colData = function(idx, prop) {
      return typeof columns[idx][prop] === "function" ? "function" : columns[idx][prop];
    };
    return {
      draw: settings.iDraw,
      columns: columns.map(function(column, i) {
        return {
          data: colData(i, "mData"),
          name: column.sName,
          searchable: column.bSearchable,
          orderable: column.bSortable,
          search: {
            value: preColSearch[i].search,
            regex: preColSearch[i].regex,
            fixed: Object.keys(column.searchFixed).map(function(name) {
              return {
                name,
                term: column.searchFixed[name].toString()
              };
            })
          }
        };
      }),
      order: _fnSortFlatten3(settings).map(function(val) {
        return {
          column: val.col,
          dir: val.dir,
          name: colData(val.col, "sName")
        };
      }),
      start: settings._iDisplayStart,
      length: features.bPaginate ? settings._iDisplayLength : -1,
      search: {
        value: preSearch.search,
        regex: preSearch.regex,
        fixed: Object.keys(settings.searchFixed).map(function(name) {
          return {
            name,
            term: settings.searchFixed[name].toString()
          };
        })
      }
    };
  }
  function _fnAjaxUpdateDraw3(settings, json) {
    var data = _fnAjaxDataSrc3(settings, json);
    var draw = _fnAjaxDataSrcParam3(settings, "draw", json);
    var recordsTotal = _fnAjaxDataSrcParam3(settings, "recordsTotal", json);
    var recordsFiltered = _fnAjaxDataSrcParam3(settings, "recordsFiltered", json);
    if (draw !== void 0) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    if (!data) {
      data = [];
    }
    _fnClearTable3(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData3(settings, data[i]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnDraw3(settings, true);
    _fnInitComplete3(settings);
    _fnProcessingDisplay3(settings, false);
  }
  function _fnAjaxDataSrc3(settings, json, write) {
    var dataProp = "data";
    if ($5.isPlainObject(settings.ajax) && settings.ajax.dataSrc !== void 0) {
      var dataSrc = settings.ajax.dataSrc;
      if (typeof dataSrc === "string" || typeof dataSrc === "function") {
        dataProp = dataSrc;
      } else if (dataSrc.data !== void 0) {
        dataProp = dataSrc.data;
      }
    }
    if (!write) {
      if (dataProp === "data") {
        return json.aaData || json[dataProp];
      }
      return dataProp !== "" ? _fnGetObjectDataFn3(dataProp)(json) : json;
    }
    _fnSetObjectDataFn3(dataProp)(json, write);
  }
  function _fnAjaxDataSrcParam3(settings, param, json) {
    var dataSrc = $5.isPlainObject(settings.ajax) ? settings.ajax.dataSrc : null;
    if (dataSrc && dataSrc[param]) {
      return _fnGetObjectDataFn3(dataSrc[param])(json);
    }
    var old = "";
    if (param === "draw") {
      old = "sEcho";
    } else if (param === "recordsTotal") {
      old = "iTotalRecords";
    } else if (param === "recordsFiltered") {
      old = "iTotalDisplayRecords";
    }
    return json[old] !== void 0 ? json[old] : json[param];
  }
  function _fnFilterComplete3(settings, input) {
    var columnsSearch = settings.aoPreSearchCols;
    _fnColumnTypes3(settings);
    if (_fnDataSource3(settings) != "ssp") {
      _fnFilterData3(settings);
      settings.aiDisplay = settings.aiDisplayMaster.slice();
      _fnFilter3(settings.aiDisplay, settings, input.search, input);
      $5.each(settings.searchFixed, function(name, term) {
        _fnFilter3(settings.aiDisplay, settings, term, {});
      });
      for (var i = 0; i < columnsSearch.length; i++) {
        var col = columnsSearch[i];
        _fnFilter3(
          settings.aiDisplay,
          settings,
          col.search,
          col,
          i
        );
        $5.each(settings.aoColumns[i].searchFixed, function(name, term) {
          _fnFilter3(settings.aiDisplay, settings, term, {}, i);
        });
      }
      _fnFilterCustom3(settings);
    }
    settings.bFiltered = true;
    _fnCallbackFire3(settings, null, "search", [settings]);
  }
  function _fnFilterCustom3(settings) {
    var filters = DataTable3.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = [];
      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];
        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      displayRows.push.apply(displayRows, rows);
    }
  }
  function _fnFilter3(searchRows, settings, input, options, column) {
    if (input === "") {
      return;
    }
    var i = 0;
    var searchFunc = typeof input === "function" ? input : null;
    var rpSearch = input instanceof RegExp ? input : searchFunc ? null : _fnFilterCreateSearch3(input, options);
    while (i < searchRows.length) {
      var row = settings.aoData[searchRows[i]];
      var data = column === void 0 ? row._sFilterRow : row._aFilterData[column];
      if (searchFunc && !searchFunc(data, row._aData, searchRows[i], column) || rpSearch && !rpSearch.test(data)) {
        searchRows.splice(i, 1);
        i--;
      }
      i++;
    }
  }
  function _fnFilterCreateSearch3(search, inOpts) {
    var not = [];
    var options = $5.extend({}, {
      boundary: false,
      caseInsensitive: true,
      exact: false,
      regex: false,
      smart: true
    }, inOpts);
    if (typeof search !== "string") {
      search = search.toString();
    }
    search = _normalize3(search);
    if (options.exact) {
      return new RegExp(
        "^" + _fnEscapeRegex3(search) + "$",
        options.caseInsensitive ? "i" : ""
      );
    }
    search = options.regex ? search : _fnEscapeRegex3(search);
    if (options.smart) {
      var parts = search.match(/!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""];
      var a = parts.map(function(word) {
        var negative = false;
        var m2;
        if (word.charAt(0) === "!") {
          negative = true;
          word = word.substring(1);
        }
        if (word.charAt(0) === '"') {
          m2 = word.match(/^"(.*)"$/);
          word = m2 ? m2[1] : word;
        } else if (word.charAt(0) === "\u201C") {
          m2 = word.match(/^\u201C(.*)\u201D$/);
          word = m2 ? m2[1] : word;
        }
        if (negative) {
          if (word.length > 1) {
            not.push("(?!" + word + ")");
          }
          word = "";
        }
        return word.replace(/"/g, "");
      });
      var match = not.length ? not.join("") : "";
      var boundary = options.boundary ? "\\b" : "";
      search = "^(?=.*?" + boundary + a.join(")(?=.*?" + boundary) + ")(" + match + ".)*$";
    }
    return new RegExp(search, options.caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex3 = DataTable3.util.escapeRegex;
  var __filter_div3 = $5("<div>")[0];
  var __filter_div_textContent3 = __filter_div3.textContent !== void 0;
  function _fnFilterData3(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var column;
    var j, jen, filterData, cellData, row;
    var wasInvalidated = false;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aFilterData) {
        filterData = [];
        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];
          if (column.bSearchable) {
            cellData = _fnGetCellData3(settings, rowIdx, j, "filter");
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div3.innerHTML = cellData;
            cellData = __filter_div_textContent3 ? __filter_div3.textContent : __filter_div3.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnInitialise3(settings) {
    var i, iAjaxStart = settings.iInitDisplayStart;
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise3(settings);
      }, 200);
      return;
    }
    _fnBuildHead3(settings, "header");
    _fnBuildHead3(settings, "footer");
    _fnDrawHead3(settings, settings.aoHeader);
    _fnDrawHead3(settings, settings.aoFooter);
    _fnAddOptionsHtml3(settings);
    _fnSortInit3(settings);
    _colGroup3(settings);
    _fnProcessingDisplay3(settings, true);
    _fnCallbackFire3(settings, null, "preInit", [settings], true);
    _fnReDraw3(settings);
    var dataSrc = _fnDataSource3(settings);
    if (dataSrc != "ssp") {
      if (dataSrc == "ajax") {
        _fnBuildAjax3(settings, {}, function(json) {
          var aData = _fnAjaxDataSrc3(settings, json);
          for (i = 0; i < aData.length; i++) {
            _fnAddData3(settings, aData[i]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw3(settings);
          _fnProcessingDisplay3(settings, false);
          _fnInitComplete3(settings);
        }, settings);
      } else {
        _fnInitComplete3(settings);
        _fnProcessingDisplay3(settings, false);
      }
    }
  }
  function _fnInitComplete3(settings) {
    if (settings._bInitComplete) {
      return;
    }
    var args = [settings, settings.json];
    settings._bInitComplete = true;
    _fnAdjustColumnSizing3(settings);
    _fnCallbackFire3(settings, null, "plugin-init", args, true);
    _fnCallbackFire3(settings, "aoInitComplete", "init", args, true);
  }
  function _fnLengthChange3(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow3(settings);
    _fnCallbackFire3(settings, null, "length", [settings, len]);
  }
  function _fnPageChange3(settings, action, redraw) {
    var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;
      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;
      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else if (action === "ellipsis") {
      return;
    } else {
      _fnLog3(settings, 0, "Unknown paging action: " + action, 5);
    }
    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;
    _fnCallbackFire3(settings, null, changed ? "page" : "page-nc", [settings]);
    if (changed && redraw) {
      _fnDraw3(settings);
    }
    return changed;
  }
  function _processingHtml3(settings) {
    var table = settings.nTable;
    if (settings.oFeatures.bProcessing) {
      var n = $5("<div/>", {
        "id": settings.sTableId + "_processing",
        "class": settings.oClasses.processing.container,
        "role": "status"
      }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>").insertBefore(table);
      $5(table).on("processing.dt.DT", function(e, s, show) {
        n.css("display", show ? "block" : "none");
      });
    }
  }
  function _fnProcessingDisplay3(settings, show) {
    _fnCallbackFire3(settings, null, "processing", [settings, show]);
  }
  function _fnFeatureHtmlTable3(settings) {
    var table = $5(settings.nTable);
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses.scrolling;
    var caption = settings.captionNode;
    var captionSide = caption ? caption._captionSide : null;
    var headerClone = $5(table[0].cloneNode(false));
    var footerClone = $5(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size = function(s) {
      return !s ? null : _fnStringToCss3(s);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $5(_div, { "class": classes.container }).append(
      $5(_div, { "class": classes.header.self }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: scrollX ? size(scrollX) : "100%"
      }).append(
        $5(_div, { "class": classes.header.inner }).css({
          "box-sizing": "content-box",
          width: scroll.sXInner || "100%"
        }).append(
          headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
            table.children("thead")
          )
        )
      )
    ).append(
      $5(_div, { "class": classes.body }).css({
        position: "relative",
        overflow: "auto",
        width: size(scrollX)
      }).append(table)
    );
    if (footer) {
      scroller.append(
        $5(_div, { "class": classes.footer.self }).css({
          overflow: "hidden",
          border: 0,
          width: scrollX ? size(scrollX) : "100%"
        }).append(
          $5(_div, { "class": classes.footer.inner }).append(
            footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
              table.children("tfoot")
            )
          )
        )
      );
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    $5(scrollBody).on("scroll.DT", function() {
      var scrollLeft = this.scrollLeft;
      scrollHead.scrollLeft = scrollLeft;
      if (footer) {
        scrollFoot.scrollLeft = scrollLeft;
      }
    });
    $5("th, td", scrollHead).on("focus", function() {
      var scrollLeft = scrollHead.scrollLeft;
      scrollBody.scrollLeft = scrollLeft;
      if (footer) {
        scrollBody.scrollLeft = scrollLeft;
      }
    });
    $5(scrollBody).css("max-height", scrollY);
    if (!scroll.bCollapse) {
      $5(scrollBody).css("height", scrollY);
    }
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push(_fnScrollDraw3);
    return scroller[0];
  }
  function _fnScrollDraw3(settings) {
    var scroll = settings.oScroll, barWidth = scroll.iBarWidth, divHeader = $5(settings.nScrollHead), divHeaderInner = divHeader.children("div"), divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $5(divBodyEl), divFooter = $5(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $5(settings.nTHead), table = $5(settings.nTable), footer = settings.nTFoot && $5("th, td", settings.nTFoot).length ? $5(settings.nTFoot) : null, browser = settings.oBrowser, headerCopy, footerCopy;
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing3(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    headerCopy = header.clone().prependTo(table);
    headerCopy.find("th, td").removeAttr("tabindex");
    headerCopy.find("[id]").removeAttr("id");
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerCopy.find("[id]").removeAttr("id");
    }
    if (settings.aiDisplay.length) {
      var colSizes = table.find("tbody tr").eq(0).find("th, td").map(function(vis) {
        return {
          idx: _fnVisibleToColumnIndex3(settings, vis),
          width: $5(this).outerWidth()
        };
      });
      for (var i = 0; i < colSizes.length; i++) {
        var colEl = settings.aoColumns[colSizes[i].idx].colEl[0];
        var colWidth = colEl.style.width.replace("px", "");
        if (colWidth !== colSizes[i].width) {
          colEl.style.width = colSizes[i].width + "px";
        }
      }
    }
    divHeaderTable.find("colgroup").remove();
    divHeaderTable.append(settings.colgroup.clone());
    if (footer) {
      divFooterTable.find("colgroup").remove();
      divFooterTable.append(settings.colgroup.clone());
    }
    $5("th, td", headerCopy).each(function() {
      $5(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
    });
    if (footer) {
      $5("th, td", footerCopy).each(function() {
        $5(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
      });
    }
    var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var paddingSide = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    var outerWidth = table.outerWidth();
    divHeaderTable.css("width", _fnStringToCss3(outerWidth));
    divHeaderInner.css("width", _fnStringToCss3(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    if (footer) {
      divFooterTable.css("width", _fnStringToCss3(outerWidth));
      divFooterInner.css("width", _fnStringToCss3(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    }
    table.children("colgroup").prependTo(table);
    divBody.trigger("scroll");
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnCalculateColumnWidths3(settings) {
    if (!settings.oFeatures.bAutoWidth) {
      return;
    }
    var table = settings.nTable, columns = settings.aoColumns, scroll = settings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, visibleColumns = _fnGetColumns3(settings, "bVisible"), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, i, column, columnIdx;
    var styleWidth = table.style.width;
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    _fnCallbackFire3(
      settings,
      null,
      "column-calc",
      { visible: visibleColumns },
      false
    );
    var tmpTable = $5(table.cloneNode()).css("visibility", "hidden").removeAttr("id");
    tmpTable.append("<tbody>");
    var tr = $5("<tr/>").appendTo(tmpTable.find("tbody"));
    tmpTable.append($5(settings.nTHead).clone()).append($5(settings.nTFoot).clone());
    tmpTable.find("tfoot th, tfoot td").css("width", "");
    tmpTable.find("thead th, thead td").each(function() {
      var width = _fnColumnsSumWidth3(settings, this, true, false);
      if (width) {
        this.style.width = width;
        if (scrollX) {
          $5(this).append($5("<div/>").css({
            width,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } else {
        this.style.width = "";
      }
    });
    for (i = 0; i < visibleColumns.length; i++) {
      columnIdx = visibleColumns[i];
      column = columns[columnIdx];
      var longest = _fnGetMaxLenString3(settings, columnIdx);
      var autoClass = _ext3.type.className[column.sType];
      var text = longest + column.sContentPadding;
      var insert = longest.indexOf("<") === -1 ? document.createTextNode(text) : text;
      $5("<td/>").addClass(autoClass).addClass(column.sClass).append(insert).appendTo(tr);
    }
    $5("[name]", tmpTable).removeAttr("name");
    var holder = $5("<div/>").css(
      scrollX || scrollY ? {
        position: "absolute",
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: "hidden"
      } : {}
    ).append(tmpTable).appendTo(tableContainer);
    if (scrollX && scrollXInner) {
      tmpTable.width(scrollXInner);
    } else if (scrollX) {
      tmpTable.css("width", "auto");
      tmpTable.removeAttr("width");
      if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
        tmpTable.width(tableContainer.clientWidth);
      }
    } else if (scrollY) {
      tmpTable.width(tableContainer.clientWidth);
    } else if (tableWidthAttr) {
      tmpTable.width(tableWidthAttr);
    }
    var total = 0;
    var bodyCells = tmpTable.find("tbody tr").eq(0).children();
    for (i = 0; i < visibleColumns.length; i++) {
      var bounding = bodyCells[i].getBoundingClientRect().width;
      total += bounding;
      columns[visibleColumns[i]].sWidth = _fnStringToCss3(bounding);
    }
    table.style.width = _fnStringToCss3(total);
    holder.remove();
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss3(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !settings._reszEvt) {
      var bindResize = function() {
        $5(window).on("resize.DT-" + settings.sInstance, DataTable3.util.throttle(function() {
          if (!settings.bDestroying) {
            _fnAdjustColumnSizing3(settings);
          }
        }));
      };
      bindResize();
      settings._reszEvt = true;
    }
  }
  function _fnGetMaxLenString3(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    if (!column.maxLenString) {
      var s, max = "", maxLen = -1;
      for (var i = 0, ien = settings.aiDisplayMaster.length; i < ien; i++) {
        var rowIdx = settings.aiDisplayMaster[i];
        var data = _fnGetRowDisplay3(settings, rowIdx)[colIdx];
        var cellString = data && typeof data === "object" && data.nodeType ? data.innerHTML : data + "";
        cellString = cellString.replace(/id=".*?"/g, "").replace(/name=".*?"/g, "");
        s = _stripHtml3(cellString).replace(/&nbsp;/g, " ");
        if (s.length > maxLen) {
          max = cellString;
          maxLen = s.length;
        }
      }
      column.maxLenString = max;
    }
    return column.maxLenString;
  }
  function _fnStringToCss3(s) {
    if (s === null) {
      return "0px";
    }
    if (typeof s == "number") {
      return s < 0 ? "0px" : s + "px";
    }
    return s.match(/\d$/) ? s + "px" : s;
  }
  function _colGroup3(settings) {
    var cols = settings.aoColumns;
    settings.colgroup.empty();
    for (i = 0; i < cols.length; i++) {
      if (cols[i].bVisible) {
        settings.colgroup.append(cols[i].colEl);
      }
    }
  }
  function _fnSortInit3(settings) {
    var target = settings.nTHead;
    var headerRows = target.querySelectorAll("tr");
    var legacyTop = settings.bSortCellsTop;
    var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
    if (legacyTop === true) {
      target = headerRows[0];
    } else if (legacyTop === false) {
      target = headerRows[headerRows.length - 1];
    }
    _fnSortAttachListener3(
      settings,
      target,
      target === settings.nTHead ? "tr" + notSelector + " th" + notSelector + ", tr" + notSelector + " td" + notSelector : "th" + notSelector + ", td" + notSelector
    );
    var order = [];
    _fnSortResolve3(settings, order, settings.aaSorting);
    settings.aaSorting = order;
  }
  function _fnSortAttachListener3(settings, node, selector, column, callback) {
    _fnBindAction3(node, selector, function(e) {
      var run = false;
      var columns = column === void 0 ? _fnColumnsFromHeader3(e.target) : [column];
      if (columns.length) {
        for (var i = 0, ien = columns.length; i < ien; i++) {
          var ret = _fnSortAdd3(settings, columns[i], i, e.shiftKey);
          if (ret !== false) {
            run = true;
          }
          if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === "") {
            break;
          }
        }
        if (run) {
          _fnProcessingDisplay3(settings, true);
          setTimeout(function() {
            _fnSort3(settings);
            _fnSortDisplay3(settings, settings.aiDisplay);
            _fnProcessingDisplay3(settings, false);
            _fnReDraw3(settings, false, false);
            if (callback) {
              callback();
            }
          }, 0);
        }
      }
    });
  }
  function _fnSortDisplay3(settings, display) {
    var master = settings.aiDisplayMaster;
    var masterMap = {};
    var map2 = {};
    var i;
    for (i = 0; i < master.length; i++) {
      masterMap[master[i]] = i;
    }
    for (i = 0; i < display.length; i++) {
      map2[display[i]] = masterMap[display[i]];
    }
    display.sort(function(a, b) {
      return map2[a] - map2[b];
    });
  }
  function _fnSortResolve3(settings, nestedSort, sort) {
    var push = function(a) {
      if ($5.isPlainObject(a)) {
        if (a.idx !== void 0) {
          nestedSort.push([a.idx, a.dir]);
        } else if (a.name) {
          var cols = _pluck3(settings.aoColumns, "sName");
          var idx = cols.indexOf(a.name);
          if (idx !== -1) {
            nestedSort.push([idx, a.dir]);
          }
        }
      } else {
        nestedSort.push(a);
      }
    };
    if ($5.isPlainObject(sort)) {
      push(sort);
    } else if (sort.length && typeof sort[0] === "number") {
      push(sort);
    } else if (sort.length) {
      for (var z = 0; z < sort.length; z++) {
        push(sort[z]);
      }
    }
  }
  function _fnSortFlatten3(settings) {
    var i, k, kLen, aSort = [], extSort = DataTable3.ext.type.order, aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $5.isPlainObject(fixed), nestedSort = [];
    if (!settings.oFeatures.bSort) {
      return aSort;
    }
    if (Array.isArray(fixed)) {
      _fnSortResolve3(settings, nestedSort, fixed);
    }
    if (fixedObj && fixed.pre) {
      _fnSortResolve3(settings, nestedSort, fixed.pre);
    }
    _fnSortResolve3(settings, nestedSort, settings.aaSorting);
    if (fixedObj && fixed.post) {
      _fnSortResolve3(settings, nestedSort, fixed.post);
    }
    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      if (aoColumns[srcCol]) {
        aDataSort = aoColumns[srcCol].aDataSort;
        for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
          iCol = aDataSort[k];
          sType = aoColumns[iCol].sType || "string";
          if (nestedSort[i]._idx === void 0) {
            nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
          }
          if (nestedSort[i][1]) {
            aSort.push({
              src: srcCol,
              col: iCol,
              dir: nestedSort[i][1],
              index: nestedSort[i]._idx,
              type: sType,
              formatter: extSort[sType + "-pre"],
              sorter: extSort[sType + "-" + nestedSort[i][1]]
            });
          }
        }
      }
    }
    return aSort;
  }
  function _fnSort3(oSettings, col, dir) {
    var i, ien, iLen, aiOrig = [], extSort = DataTable3.ext.type.order, aoData = oSettings.aoData, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    _fnColumnTypes3(oSettings);
    if (col !== void 0) {
      var srcCol = oSettings.aoColumns[col];
      aSort = [{
        src: col,
        col,
        dir,
        index: 0,
        type: srcCol.sType,
        formatter: extSort[srcCol.sType + "-pre"],
        sorter: extSort[srcCol.sType + "-" + dir]
      }];
      displayMaster = displayMaster.slice();
    } else {
      aSort = _fnSortFlatten3(oSettings);
    }
    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i];
      _fnSortData3(oSettings, sortCol.col);
    }
    if (_fnDataSource3(oSettings) != "ssp" && aSort.length !== 0) {
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[i] = i;
      }
      if (aSort.length && aSort[0].dir === "desc") {
        aiOrig.reverse();
      }
      displayMaster.sort(function(a, b) {
        var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
        for (k = 0; k < len; k++) {
          sort = aSort[k];
          x = dataA[sort.col];
          y = dataB[sort.col];
          if (sort.sorter) {
            test = sort.sorter(x, y);
            if (test !== 0) {
              return test;
            }
          } else {
            test = x < y ? -1 : x > y ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
        }
        x = aiOrig[a];
        y = aiOrig[b];
        return x < y ? -1 : x > y ? 1 : 0;
      });
    } else if (aSort.length === 0) {
      displayMaster.sort(function(x, y) {
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    if (col === void 0) {
      oSettings.bSorted = true;
      _fnCallbackFire3(oSettings, null, "order", [oSettings, aSort]);
    }
    return displayMaster;
  }
  function _fnSortAdd3(settings, colIdx, addIndex, shift) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a, overflow) {
      var idx = a._idx;
      if (idx === void 0) {
        idx = asSorting.indexOf(a[1]);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (!col.bSortable) {
      return false;
    }
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if ((shift || addIndex) && settings.oFeatures.bSortMulti) {
      var sortIdx = _pluck3(sorting, "0").indexOf(colIdx);
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else if (shift) {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      } else {
        sorting.push([colIdx, sorting[0][1], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    }
  }
  function _fnSortingClasses3(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.order.position;
    var sort = _fnSortFlatten3(settings);
    var features = settings.oFeatures;
    var i, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src;
        $5(_pluck3(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      }
      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $5(_pluck3(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData3(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    var customSort = DataTable3.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(
        settings.oInstance,
        settings,
        colIdx,
        _fnColumnIndexToVisible3(settings, colIdx)
      );
    }
    var row, cellData;
    var formatter = DataTable3.ext.type.order[column.sType + "-pre"];
    var data = settings.aoData;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[colIdx] || customSort) {
        cellData = customSort ? customData[rowIdx] : (
          // If there was a custom sort function, use data from there
          _fnGetCellData3(settings, rowIdx, colIdx, "sort")
        );
        row._aSortData[colIdx] = formatter ? formatter(cellData, settings) : cellData;
      }
    }
  }
  function _fnSaveState3(settings) {
    if (settings._bLoadingState) {
      return;
    }
    var state = {
      time: +/* @__PURE__ */ new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $5.extend(true, [], settings.aaSorting),
      search: $5.extend({}, settings.oPreviousSearch),
      columns: settings.aoColumns.map(function(col, i) {
        return {
          visible: col.bVisible,
          search: $5.extend({}, settings.aoPreSearchCols[i])
        };
      })
    };
    settings.oSavedState = state;
    _fnCallbackFire3(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
  }
  function _fnLoadState3(settings, init2, callback) {
    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }
    var loaded = function(state2) {
      _fnImplementState3(settings, state2, callback);
    };
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
    if (state !== void 0) {
      _fnImplementState3(settings, state, callback);
    }
    return true;
  }
  function _fnImplementState3(settings, s, callback) {
    var i, ien;
    var columns = settings.aoColumns;
    settings._bLoadingState = true;
    var api = settings._bInitComplete ? new DataTable3.Api(settings) : null;
    if (!s || !s.time) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && s.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var abStateLoad = _fnCallbackFire3(settings, "aoStateLoadParams", "stateLoadParams", [settings, s]);
    if (abStateLoad.indexOf(false) !== -1) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    if (s.columns && columns.length !== s.columns.length) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    settings.oLoadedState = $5.extend(true, {}, s);
    _fnCallbackFire3(settings, null, "stateLoadInit", [settings, s], true);
    if (s.length !== void 0) {
      if (api) {
        api.page.len(s.length);
      } else {
        settings._iDisplayLength = s.length;
      }
    }
    if (s.start !== void 0) {
      if (api === null) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      } else {
        _fnPageChange3(settings, s.start / settings._iDisplayLength);
      }
    }
    if (s.order !== void 0) {
      settings.aaSorting = [];
      $5.each(s.order, function(i2, col2) {
        settings.aaSorting.push(
          col2[0] >= columns.length ? [0, col2[1]] : col2
        );
      });
    }
    if (s.search !== void 0) {
      $5.extend(settings.oPreviousSearch, s.search);
    }
    if (s.columns) {
      for (i = 0, ien = s.columns.length; i < ien; i++) {
        var col = s.columns[i];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i).visible(col.visible, false);
          } else {
            columns[i].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $5.extend(settings.aoPreSearchCols[i], col.search);
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
    settings._bLoadingState = false;
    _fnCallbackFire3(settings, "aoStateLoaded", "stateLoaded", [settings, s]);
    callback();
  }
  function _fnLog3(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable3.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire3(settings, null, "dt-error", [settings, tn, msg], true);
      }
      if (type == "alert") {
        alert(msg);
      } else if (type == "throw") {
        throw new Error(msg);
      } else if (typeof type == "function") {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  function _fnMap3(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $5.each(name, function(i, val) {
        if (Array.isArray(val)) {
          _fnMap3(ret, src, val[0], val[1]);
        } else {
          _fnMap3(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === void 0) {
      mappedName = name;
    }
    if (src[name] !== void 0) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend3(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, prop)) {
        val = extender[prop];
        if ($5.isPlainObject(val)) {
          if (!$5.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $5.extend(true, out[prop], val);
        } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }
    return out;
  }
  function _fnBindAction3(n, selector, fn) {
    $5(n).on("click.DT", selector, function(e) {
      fn(e);
    }).on("keypress.DT", selector, function(e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on("selectstart.DT", selector, function() {
      return false;
    });
  }
  function _fnCallbackReg3(settings, store, fn) {
    if (fn) {
      settings[store].push(fn);
    }
  }
  function _fnCallbackFire3(settings, callbackArr, eventName, args, bubbles) {
    var ret = [];
    if (callbackArr) {
      ret = settings[callbackArr].slice().reverse().map(function(val) {
        return val.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e = $5.Event(eventName + ".dt");
      var table = $5(settings.nTable);
      e.dt = settings.api;
      table[bubbles ? "trigger" : "triggerHandler"](e, args);
      if (bubbles && table.parents("body").length === 0) {
        $5("body").trigger(e, args);
      }
      ret.push(e.result);
    }
    return ret;
  }
  function _fnLengthOverflow3(settings) {
    var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start >= end) {
      start = end - len;
    }
    start -= start % len;
    if (len === -1 || start < 0) {
      start = 0;
    }
    settings._iDisplayStart = start;
  }
  function _fnRenderer3(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable3.ext.renderer[type];
    if ($5.isPlainObject(renderer) && renderer[type]) {
      return host[renderer[type]] || host._;
    } else if (typeof renderer === "string") {
      return host[renderer] || host._;
    }
    return host._;
  }
  function _fnDataSource3(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else if (settings.ajax) {
      return "ajax";
    }
    return "dom";
  }
  function _fnMacros3(settings, str, entries) {
    var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), max = settings.fnRecordsTotal(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, max)).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len))).replace(/_ENTRIES_/g, settings.api.i18n("entries", "", entries)).replace(/_ENTRIES-MAX_/g, settings.api.i18n("entries", "", max)).replace(/_ENTRIES-TOTAL_/g, settings.api.i18n("entries", "", vis));
  }
  var __apiStruct3 = [];
  var __arrayProto3 = Array.prototype;
  var _toSettings3 = function(mixed) {
    var idx, jq;
    var settings = DataTable3.settings;
    var tables = _pluck3(settings, "nTable");
    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oFeatures) {
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
      idx = tables.indexOf(mixed);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === "function") {
      return mixed.settings().toArray();
    } else if (typeof mixed === "string") {
      jq = $5(mixed).get();
    } else if (mixed instanceof $5) {
      jq = mixed.get();
    }
    if (jq) {
      return settings.filter(function(v, idx2) {
        return jq.includes(tables[idx2]);
      });
    }
  };
  _Api3 = function(context, data) {
    if (!(this instanceof _Api3)) {
      return new _Api3(context, data);
    }
    var settings = [];
    var ctxSettings = function(o) {
      var a = _toSettings3(o);
      if (a) {
        settings.push.apply(settings, a);
      }
    };
    if (Array.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = settings.length > 1 ? _unique3(settings) : settings;
    if (data) {
      this.push.apply(this, data);
    }
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
    _Api3.extend(this, this, __apiStruct3);
  };
  DataTable3.Api = _Api3;
  $5.extend(_Api3.prototype, {
    any: function() {
      return this.count() !== 0;
    },
    context: [],
    // array of table settings objects
    count: function() {
      return this.flatten().length;
    },
    each: function(fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }
      return this;
    },
    eq: function(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api3(ctx[idx], this[idx]) : null;
    },
    filter: function(fn) {
      var a = __arrayProto3.filter.call(this, fn, this);
      return new _Api3(this.context, a);
    },
    flatten: function() {
      var a = [];
      return new _Api3(this.context, a.concat.apply(a, this.toArray()));
    },
    get: function(idx) {
      return this[idx];
    },
    join: __arrayProto3.join,
    includes: function(find) {
      return this.indexOf(find) === -1 ? false : true;
    },
    indexOf: __arrayProto3.indexOf,
    iterator: function(flatten, type, fn, alwaysNew) {
      var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
      if (typeof flatten === "string") {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }
      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api3(context[i]);
        if (type === "table") {
          ret = fn.call(apiInst, context[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "columns" || type === "rows") {
          ret = fn.call(apiInst, context[i], this[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "every" || type === "column" || type === "column-rows" || type === "row" || type === "cell") {
          items = this[i];
          if (type === "column-rows") {
            rows = _selector_row_indexes3(context[i], selector.opts);
          }
          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];
            if (type === "cell") {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }
            if (ret !== void 0) {
              a.push(ret);
            }
          }
        }
      }
      if (a.length || alwaysNew) {
        var api = new _Api3(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
    lastIndexOf: __arrayProto3.lastIndexOf,
    length: 0,
    map: function(fn) {
      var a = __arrayProto3.map.call(this, fn, this);
      return new _Api3(this.context, a);
    },
    pluck: function(prop) {
      var fn = DataTable3.util.get(prop);
      return this.map(function(el) {
        return fn(el);
      });
    },
    pop: __arrayProto3.pop,
    push: __arrayProto3.push,
    reduce: __arrayProto3.reduce,
    reduceRight: __arrayProto3.reduceRight,
    reverse: __arrayProto3.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto3.shift,
    slice: function() {
      return new _Api3(this.context, this);
    },
    sort: __arrayProto3.sort,
    splice: __arrayProto3.splice,
    toArray: function() {
      return __arrayProto3.slice.call(this);
    },
    to$: function() {
      return $5(this);
    },
    toJQuery: function() {
      return $5(this);
    },
    unique: function() {
      return new _Api3(this.context, _unique3(this.toArray()));
    },
    unshift: __arrayProto3.unshift
  });
  function _api_scope3(scope, fn, struc) {
    return function() {
      var ret = fn.apply(scope || this, arguments);
      _Api3.extend(ret, ret, struc.methodExt);
      return ret;
    };
  }
  function _api_find3(src, name) {
    for (var i = 0, ien = src.length; i < ien; i++) {
      if (src[i].name === name) {
        return src[i];
      }
    }
    return null;
  }
  window.__apiStruct = __apiStruct3;
  _Api3.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api3) && !obj.__dt_wrapper) {
      return;
    }
    var i, ien, struct;
    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i];
      if (struct.name === "__proto__") {
        continue;
      }
      obj[struct.name] = struct.type === "function" ? _api_scope3(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api3.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api3.register = _api_register3 = function(name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api3.register(name[j], val);
      }
      return;
    }
    var i, ien, heir = name.split("."), struct = __apiStruct3, key, method;
    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf("()") !== -1;
      key = method ? heir[i].replace("()", "") : heir[i];
      var src = _api_find3(struct, key);
      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: "object"
        };
        struct.push(src);
      }
      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === "function" ? "function" : $5.isPlainObject(val) ? "object" : "other";
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api3.registerPlural = _api_registerPlural3 = function(pluralName, singularName, val) {
    _Api3.register(pluralName, val);
    _Api3.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else if (ret instanceof _Api3) {
        return ret.length ? Array.isArray(ret[0]) ? new _Api3(ret.context, ret[0]) : (
          // Array results are 'enhanced'
          ret[0]
        ) : void 0;
      }
      return ret;
    });
  };
  var __table_selector3 = function(selector, a) {
    if (Array.isArray(selector)) {
      var result = [];
      selector.forEach(function(sel) {
        var inner = __table_selector3(sel, a);
        result.push.apply(result, inner);
      });
      return result.filter(function(item) {
        return item;
      });
    }
    if (typeof selector === "number") {
      return [a[selector]];
    }
    var nodes = a.map(function(el) {
      return el.nTable;
    });
    return $5(nodes).filter(selector).map(function() {
      var idx = nodes.indexOf(this);
      return a[idx];
    }).toArray();
  };
  _api_register3("tables()", function(selector) {
    return selector !== void 0 && selector !== null ? new _Api3(__table_selector3(selector, this.context)) : this;
  });
  _api_register3("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api3(ctx[0]) : tables;
  });
  [
    ["nodes", "node", "nTable"],
    ["body", "body", "nTBody"],
    ["header", "header", "nTHead"],
    ["footer", "footer", "nTFoot"]
  ].forEach(function(item) {
    _api_registerPlural3(
      "tables()." + item[0] + "()",
      "table()." + item[1] + "()",
      function() {
        return this.iterator("table", function(ctx) {
          return ctx[item[2]];
        }, 1);
      }
    );
  });
  [
    ["header", "aoHeader"],
    ["footer", "aoFooter"]
  ].forEach(function(item) {
    _api_register3("table()." + item[0] + ".structure()", function(selector) {
      var indexes = this.columns(selector).indexes().flatten();
      var ctx = this.context[0];
      return _fnHeaderLayout3(ctx, ctx[item[1]], indexes);
    });
  });
  _api_registerPlural3("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register3("tables().every()", function(fn) {
    var that = this;
    return this.iterator("table", function(s, i) {
      fn.call(that.table(i), i);
    });
  });
  _api_register3("caption()", function(value, side) {
    var context = this.context;
    if (value === void 0) {
      var caption = context[0].captionNode;
      return caption && context.length ? caption.innerHTML : null;
    }
    return this.iterator("table", function(ctx) {
      var table = $5(ctx.nTable);
      var caption2 = $5(ctx.captionNode);
      var container = $5(ctx.nTableWrapper);
      if (!caption2.length) {
        caption2 = $5("<caption/>").html(value);
        ctx.captionNode = caption2[0];
        if (!side) {
          table.prepend(caption2);
          side = caption2.css("caption-side");
        }
      }
      caption2.html(value);
      if (side) {
        caption2.css("caption-side", side);
        caption2[0]._captionSide = side;
      }
      if (container.find("div.dataTables_scroll").length) {
        var selector = side === "top" ? "Head" : "Foot";
        container.find("div.dataTables_scroll" + selector + " table").prepend(caption2);
      } else {
        table.prepend(caption2);
      }
    }, 1);
  });
  _api_register3("caption.node()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].captionNode : null;
  });
  _api_register3("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw3(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw3(settings, paging === false);
      }
    });
  });
  _api_register3("page()", function(action) {
    if (action === void 0) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange3(settings, action);
    });
  });
  _api_register3("page.info()", function() {
    if (this.context.length === 0) {
      return void 0;
    }
    var settings = this.context[0], start = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource3(settings) === "ssp"
    };
  });
  _api_register3("page.len()", function(len) {
    if (len === void 0) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange3(settings, len);
    });
  });
  var __reload3 = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api3(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource3(settings) == "ssp") {
      _fnReDraw3(settings, holdPosition);
    } else {
      _fnProcessingDisplay3(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax3(settings, {}, function(json) {
        _fnClearTable3(settings);
        var data = _fnAjaxDataSrc3(settings, json);
        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData3(settings, data[i]);
        }
        _fnReDraw3(settings, holdPosition);
        _fnInitComplete3(settings);
        _fnProcessingDisplay3(settings, false);
      });
    }
  };
  _api_register3("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register3("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register3("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload3(settings, resetPaging === false, callback);
    });
  });
  _api_register3("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === void 0) {
      if (ctx.length === 0) {
        return void 0;
      }
      ctx = ctx[0];
      return $5.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax;
    }
    return this.iterator("table", function(settings) {
      if ($5.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register3("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload3(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run3 = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
      selector = [selector];
    }
    for (i = 0, ien = selector.length; i < ien; i++) {
      a = selector[i] && selector[i].split && !selector[i].match(/[[(:]/) ? selector[i].split(",") : [selector[i]];
      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === "string" ? a[j].trim() : a[j]);
        res = res.filter(function(item) {
          return item !== null && item !== void 0;
        });
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext3.selector[type];
    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }
    return _unique3(out);
  };
  var _selector_opts3 = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === void 0) {
      opts.search = opts.filter;
    }
    return $5.extend({
      search: "none",
      order: "current",
      page: "all"
    }, opts);
  };
  var _selector_first3 = function(old) {
    let inst = new _Api3(old.context[0]);
    if (old.length) {
      inst.push(old[0]);
    }
    inst.selector = old.selector;
    if (inst.length && inst[0].length > 1) {
      inst[0].splice(1);
    }
    return inst;
  };
  var _selector_row_indexes3 = function(settings, opts) {
    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order = opts.order, page = opts.page;
    if (page == "current") {
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == "current" || order == "applied") {
      if (search == "none") {
        a = displayMaster.slice();
      } else if (search == "applied") {
        a = displayFiltered.slice();
      } else if (search == "removed") {
        var displayFilteredMap = {};
        for (i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }
        displayMaster.forEach(function(item) {
          if (!Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
            a.push(item);
          }
        });
      }
    } else if (order == "index" || order == "original") {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (!settings.aoData[i]) {
          continue;
        }
        if (search == "none") {
          a.push(i);
        } else {
          tmp = displayFiltered.indexOf(i);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(i);
          }
        }
      }
    } else if (typeof order === "number") {
      var ordered = _fnSort3(settings, order, "asc");
      if (search === "none") {
        a = ordered;
      } else {
        for (i = 0; i < ordered.length; i++) {
          tmp = displayFiltered.indexOf(ordered[i]);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(ordered[i]);
          }
        }
      }
    }
    return a;
  };
  var __row_selector3 = function(settings, selector, opts) {
    var rows;
    var run = function(sel) {
      var selInt = _intVal3(sel);
      var aoData = settings.aoData;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      if (!rows) {
        rows = _selector_row_indexes3(settings, opts);
      }
      if (selInt !== null && rows.indexOf(selInt) !== -1) {
        return [selInt];
      } else if (sel === null || sel === void 0 || sel === "") {
        return rows;
      }
      if (typeof sel === "function") {
        return rows.map(function(idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex;
        var cellIdx = sel._DT_CellIndex;
        if (rowIdx !== void 0) {
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $5(sel).closest("*[data-dt-row]");
          return host.length ? [host.data("dt-row")] : [];
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== void 0) {
          return [rowObj.idx];
        }
      }
      var nodes = _removeEmpty3(
        _pluck_order3(settings.aoData, rows, "nTr")
      );
      return $5(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    var matched = _selector_run3("row", selector, run, settings, opts);
    if (opts.order === "current" || opts.order === "applied") {
      _fnSortDisplay3(settings, matched);
    }
    return matched;
  };
  _api_register3("rows()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($5.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts3(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector3(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register3("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || void 0;
    }, 1);
  });
  _api_register3("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order3(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural3("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r = settings.aoData[row];
      return type === "search" ? r._aFilterData : r._aSortData;
    }, 1);
  });
  _api_registerPlural3("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate3(settings, row, src);
    });
  });
  _api_registerPlural3("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural3("rows().ids()", "row().id()", function(hash) {
    var a = [];
    var context = this.context;
    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? "#" : "") + id);
      }
    }
    return new _Api3(context, a);
  });
  _api_registerPlural3("rows().remove()", "row().remove()", function() {
    this.iterator("row", function(settings, row) {
      var data = settings.aoData;
      var rowData = data[row];
      var idx = settings.aiDisplayMaster.indexOf(row);
      if (idx !== -1) {
        settings.aiDisplayMaster.splice(idx, 1);
      }
      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      }
      _fnLengthOverflow3(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== void 0) {
        delete settings.aIds[id];
      }
      data[row] = null;
    });
    return this;
  });
  _api_register3("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i, ien;
      var out = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr3(settings, row)[0]);
        } else {
          out.push(_fnAddData3(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    modRows.push.apply(modRows, newRows);
    return modRows;
  });
  _api_register3("row()", function(selector, opts) {
    return _selector_first3(this.rows(selector, opts));
  });
  _api_register3("row().data()", function(data) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]]._aData : void 0;
    }
    var row = ctx[0].aoData[this[0]];
    row._aData = data;
    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn3(ctx[0].rowId)(data, row.nTr.id);
    }
    _fnInvalidate3(ctx[0], this[0], "data");
    return this;
  });
  _api_register3("row().node()", function() {
    var ctx = this.context;
    return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]].nTr || null : null;
  });
  _api_register3("row.add()", function(row) {
    if (row instanceof $5 && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr3(settings, row)[0];
      }
      return _fnAddData3(settings, row);
    });
    return this.row(rows[0]);
  });
  $5(document).on("plugin-init.dt", function(e, context) {
    var api = new _Api3(context);
    api.on("stateSaveParams.DT", function(e2, settings, d) {
      var idFn = settings.rowIdFn;
      var rows = settings.aiDisplayMaster;
      var ids = [];
      for (var i = 0; i < rows.length; i++) {
        var rowIdx = rows[i];
        var data = settings.aoData[rowIdx];
        if (data._detailsShow) {
          ids.push("#" + idFn(data._aData));
        }
      }
      d.childRows = ids;
    });
    api.on("stateLoaded.DT", function(e2, settings, state) {
      __details_state_load3(api, state);
    });
    __details_state_load3(api, api.state.loaded());
  });
  var __details_state_load3 = function(api, state) {
    if (state && state.childRows) {
      api.rows(state.childRows.map(function(id) {
        return id.replace(/(?<!\\):/g, "\\:");
      })).every(function() {
        _fnCallbackFire3(api.settings()[0], null, "requestChild", [this]);
      });
    }
  };
  var __details_add3 = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r, k) {
      if (Array.isArray(r) || r instanceof $5) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }
        return;
      }
      if (r.nodeName && r.nodeName.toLowerCase() === "tr") {
        r.setAttribute("data-dt-row", row.idx);
        rows.push(r);
      } else {
        var created = $5("<tr><td></td></tr>").attr("data-dt-row", row.idx).addClass(k);
        $5("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns3(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.detach();
    }
    row._details = $5(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_state3 = DataTable3.util.throttle(
    function(ctx) {
      _fnSaveState3(ctx[0]);
    },
    500
  );
  var __details_remove3 = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = void 0;
        row._details = void 0;
        $5(row.nTr).removeClass("dt-hasChild");
        __details_state3(ctx);
      }
    }
  };
  var __details_display3 = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
          $5(row.nTr).addClass("dt-hasChild");
        } else {
          row._details.detach();
          $5(row.nTr).removeClass("dt-hasChild");
        }
        _fnCallbackFire3(ctx[0], null, "childRow", [show, api.row(api[0])]);
        __details_events3(ctx[0]);
        __details_state3(ctx);
      }
    }
  };
  var __details_events3 = function(settings) {
    var api = new _Api3(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-sizing" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck3(data, "_details").length > 0) {
      api.on(drawEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({ page: "current" }).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns3(ctx);
        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];
          if (row && row._details) {
            row._details.each(function() {
              var el = $5(this).children("td");
              if (el.length == 1) {
                el.attr("colspan", visible);
              }
            });
          }
        }
      });
      api.on(destroyEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i] && data[i]._details) {
            __details_remove3(api, i);
          }
        }
      });
    }
  };
  var _emp3 = "";
  var _child_obj3 = _emp3 + "row().child";
  var _child_mth3 = _child_obj3 + "()";
  _api_register3(_child_mth3, function(data, klass) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && ctx[0].aoData[this[0]] ? ctx[0].aoData[this[0]]._details : void 0;
    } else if (data === true) {
      this.child.show();
    } else if (data === false) {
      __details_remove3(this);
    } else if (ctx.length && this.length) {
      __details_add3(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }
    return this;
  });
  _api_register3([
    _child_obj3 + ".show()",
    _child_mth3 + ".show()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display3(this, true);
    return this;
  });
  _api_register3([
    _child_obj3 + ".hide()",
    _child_mth3 + ".hide()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display3(this, false);
    return this;
  });
  _api_register3([
    _child_obj3 + ".remove()",
    _child_mth3 + ".remove()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_remove3(this);
    return this;
  });
  _api_register3(_child_obj3 + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector3 = /^([^:]+):(name|title|visIdx|visible)$/;
  var __columnData3 = function(settings, column, r1, r2, rows, type) {
    var a = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData3(settings, rows[row], column, type));
    }
    return a;
  };
  var __column_header3 = function(settings, column, row) {
    var header = settings.aoHeader;
    var target = row !== void 0 ? row : settings.bSortCellsTop ? 0 : header.length - 1;
    return header[target][column].cell;
  };
  var __column_selector3 = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck3(columns, "sName"), titles = _pluck3(columns, "sTitle"), cells = DataTable3.util.get("[].[].cell")(settings.aoHeader), nodes = _unique3(_flatten3([], cells));
    var run = function(s) {
      var selInt = _intVal3(s);
      if (s === "") {
        return _range3(columns.length);
      }
      if (selInt !== null) {
        return [
          selInt >= 0 ? selInt : (
            // Count from left
            columns.length + selInt
          )
          // Count from right (+ because its a negative value)
        ];
      }
      if (typeof s === "function") {
        var rows = _selector_row_indexes3(settings, opts);
        return columns.map(function(col, idx2) {
          return s(
            idx2,
            __columnData3(settings, idx2, 0, 0, rows),
            __column_header3(settings, idx2)
          ) ? idx2 : null;
        });
      }
      var match = typeof s === "string" ? s.match(__re_column_selector3) : "";
      if (match) {
        switch (match[2]) {
          case "visIdx":
          case "visible":
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = columns.map(function(col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex3(settings, idx)];
          case "name":
            return names.map(function(name, i) {
              return name === match[1] ? i : null;
            });
          case "title":
            return titles.map(function(title, i) {
              return title === match[1] ? i : null;
            });
          default:
            return [];
        }
      }
      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      }
      var jqResult = $5(nodes).filter(s).map(function() {
        return _fnColumnsFromHeader3(this);
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      var host = $5(s).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run3("column", selector, run, settings, opts);
  };
  var __setColumnVis3 = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, cells, i, ien, tr;
    if (vis === void 0) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return false;
    }
    if (vis) {
      var insertBefore = _pluck3(cols, "bVisible").indexOf(true, column + 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        if (data[i]) {
          tr = data[i].nTr;
          cells = data[i].anCells;
          if (tr) {
            tr.insertBefore(cells[column], cells[insertBefore] || null);
          }
        }
      }
    } else {
      $5(_pluck3(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
    _colGroup3(settings);
    return true;
  };
  _api_register3("columns()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($5.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts3(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector3(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural3("columns().header()", "column().header()", function(row) {
    return this.iterator("column", function(settings, column) {
      return __column_header3(settings, column, row);
    }, 1);
  });
  _api_registerPlural3("columns().footer()", "column().footer()", function(row) {
    return this.iterator("column", function(settings, column) {
      var footer = settings.aoFooter;
      if (!footer.length) {
        return null;
      }
      return settings.aoFooter[row !== void 0 ? row : 0][column].cell;
    }, 1);
  });
  _api_registerPlural3("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData3, 1);
  });
  _api_registerPlural3("columns().render()", "column().render()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return __columnData3(settings, column, i, j, rows, type);
    }, 1);
  });
  _api_registerPlural3("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural3("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order3(
        settings.aoData,
        rows,
        type === "search" ? "_aFilterData" : "_aSortData",
        column
      );
    }, 1);
  });
  _api_registerPlural3("columns().init()", "column().init()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column];
    }, 1);
  });
  _api_registerPlural3("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order3(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural3("columns().titles()", "column().title()", function(title, row) {
    return this.iterator("column", function(settings, column) {
      if (typeof title === "number") {
        row = title;
        title = void 0;
      }
      var span = $5("span.dt-column-title", this.column(column).header(row));
      if (title !== void 0) {
        span.html(title);
        return this;
      }
      return span.html();
    }, 1);
  });
  _api_registerPlural3("columns().types()", "column().type()", function() {
    return this.iterator("column", function(settings, column) {
      var type = settings.aoColumns[column].sType;
      if (!type) {
        _fnColumnTypes3(settings);
      }
      return type;
    }, 1);
  });
  _api_registerPlural3("columns().visible()", "column().visible()", function(vis, calc) {
    var that = this;
    var changed = [];
    var ret = this.iterator("column", function(settings, column) {
      if (vis === void 0) {
        return settings.aoColumns[column].bVisible;
      }
      if (__setColumnVis3(settings, column, vis)) {
        changed.push(column);
      }
    });
    if (vis !== void 0) {
      this.iterator("table", function(settings) {
        _fnDrawHead3(settings, settings.aoHeader);
        _fnDrawHead3(settings, settings.aoFooter);
        if (!settings.aiDisplay.length) {
          $5(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns3(settings));
        }
        _fnSaveState3(settings);
        that.iterator("column", function(settings2, column) {
          if (changed.includes(column)) {
            _fnCallbackFire3(settings2, null, "column-visibility", [settings2, column, vis, calc]);
          }
        });
        if (changed.length && (calc === void 0 || calc)) {
          that.columns.adjust();
        }
      });
    }
    return ret;
  });
  _api_registerPlural3("columns().widths()", "column().width()", function() {
    var columns = this.columns(":visible").count();
    var row = $5("<tr>").html("<td>" + Array(columns).join("</td><td>") + "</td>");
    $5(this.table().body()).append(row);
    var widths = row.children().map(function() {
      return $5(this).outerWidth();
    });
    row.remove();
    return this.iterator("column", function(settings, column) {
      var visIdx = _fnColumnIndexToVisible3(settings, column);
      return visIdx !== null ? widths[visIdx] : 0;
    }, 1);
  });
  _api_registerPlural3("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible3(settings, column) : column;
    }, 1);
  });
  _api_register3("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing3(settings);
    }, 1);
  });
  _api_register3("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex3(ctx, idx);
      } else if (type === "fromData" || type === "toVisible") {
        return _fnColumnIndexToVisible3(ctx, idx);
      }
    }
  });
  _api_register3("column()", function(selector, opts) {
    return _selector_first3(this.columns(selector, opts));
  });
  var __cell_selector3 = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes3(settings, opts);
    var cells = _removeEmpty3(_pluck_order3(data, rows, "anCells"));
    var allCells = $5(_flatten3([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;
    var run = function(s) {
      var fnSelector = typeof s === "function";
      if (s === null || s === void 0 || fnSelector) {
        a = [];
        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];
          for (j = 0; j < columns; j++) {
            o = {
              row,
              column: j
            };
            if (fnSelector) {
              host = data[row];
              if (s(o, _fnGetCellData3(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              a.push(o);
            }
          }
        }
        return a;
      }
      if ($5.isPlainObject(s)) {
        return s.column !== void 0 && s.row !== void 0 && rows.indexOf(s.row) !== -1 ? [s] : [];
      }
      var jqResult = allCells.filter(s).map(function(i2, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      host = $5(s).closest("*[data-dt-row]");
      return host.length ? [{
        row: host.data("dt-row"),
        column: host.data("dt-column")
      }] : [];
    };
    return _selector_run3("cell", selector, run, settings, opts);
  };
  _api_register3("cells()", function(rowSelector, columnSelector, opts) {
    if ($5.isPlainObject(rowSelector)) {
      if (rowSelector.row === void 0) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($5.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === void 0) {
      return this.iterator("table", function(settings) {
        return __cell_selector3(settings, rowSelector, _selector_opts3(opts));
      });
    }
    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {};
    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator("table", function(settings, idx) {
      var a = [];
      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }
      return a;
    }, 1);
    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $5.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts
    });
    return cells;
  });
  _api_registerPlural3("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : void 0;
    }, 1);
  });
  _api_register3("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData3(settings, row, column);
    }, 1);
  });
  _api_registerPlural3("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural3("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData3(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural3("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {
        row,
        column,
        columnVisible: _fnColumnIndexToVisible3(settings, column)
      };
    }, 1);
  });
  _api_registerPlural3("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate3(settings, row, src, column);
    });
  });
  _api_register3("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first3(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register3("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === void 0) {
      return ctx.length && cell.length ? _fnGetCellData3(ctx[0], cell[0].row, cell[0].column) : void 0;
    }
    _fnSetCellData3(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate3(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register3("order()", function(order, dir) {
    var ctx = this.context;
    var args = Array.prototype.slice.call(arguments);
    if (order === void 0) {
      return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
    }
    if (typeof order === "number") {
      order = [[order, dir]];
    } else if (args.length > 1) {
      order = args;
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = Array.isArray(order) ? order.slice() : order;
    });
  });
  _api_register3("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener3(settings, node, {}, column, callback);
    });
  });
  _api_register3("order.fixed()", function(set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
      return Array.isArray(fixed) ? { pre: fixed } : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $5.extend(true, {}, set);
    });
  });
  _api_register3([
    "columns().order()",
    "column().order()"
  ], function(dir) {
    var that = this;
    if (!dir) {
      return this.iterator("column", function(settings, idx) {
        var sort = _fnSortFlatten3(settings);
        for (var i = 0, ien = sort.length; i < ien; i++) {
          if (sort[i].col === idx) {
            return sort[i].dir;
          }
        }
        return null;
      }, 1);
    } else {
      return this.iterator("table", function(settings, i) {
        settings.aaSorting = that[i].map(function(col) {
          return [col, dir];
        });
      });
    }
  });
  _api_registerPlural3("columns().orderable()", "column().orderable()", function(directions) {
    return this.iterator("column", function(settings, idx) {
      var col = settings.aoColumns[idx];
      return directions ? col.asSorting : col.bSortable;
    }, 1);
  });
  _api_register3("processing()", function(show) {
    return this.iterator("table", function(ctx) {
      _fnProcessingDisplay3(ctx, show);
    });
  });
  _api_register3("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === void 0) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.search : void 0;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      if (typeof regex === "object") {
        _fnFilterComplete3(settings, $5.extend(settings.oPreviousSearch, regex, {
          search: input
        }));
      } else {
        _fnFilterComplete3(settings, $5.extend(settings.oPreviousSearch, {
          search: input,
          regex: regex === null ? false : regex,
          smart: smart === null ? true : smart,
          caseInsensitive: caseInsen === null ? true : caseInsen
        }));
      }
    });
  });
  _api_register3("search.fixed()", function(name, search) {
    var ret = this.iterator(true, "table", function(settings) {
      var fixed = settings.searchFixed;
      if (!name) {
        return Object.keys(fixed);
      } else if (search === void 0) {
        return fixed[name];
      } else if (search === null) {
        delete fixed[name];
      } else {
        fixed[name] = search;
      }
      return this;
    });
    return name !== void 0 && search === void 0 ? ret[0] : ret;
  });
  _api_registerPlural3(
    "columns().search()",
    "column().search()",
    function(input, regex, smart, caseInsen) {
      return this.iterator("column", function(settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === void 0) {
          return preSearch[column].search;
        }
        if (!settings.oFeatures.bFilter) {
          return;
        }
        if (typeof regex === "object") {
          $5.extend(preSearch[column], regex, {
            search: input
          });
        } else {
          $5.extend(preSearch[column], {
            search: input,
            regex: regex === null ? false : regex,
            smart: smart === null ? true : smart,
            caseInsensitive: caseInsen === null ? true : caseInsen
          });
        }
        _fnFilterComplete3(settings, settings.oPreviousSearch);
      });
    }
  );
  _api_register3(
    [
      "columns().search.fixed()",
      "column().search.fixed()"
    ],
    function(name, search) {
      var ret = this.iterator(true, "column", function(settings, colIdx) {
        var fixed = settings.aoColumns[colIdx].searchFixed;
        if (!name) {
          return Object.keys(fixed);
        } else if (search === void 0) {
          return fixed[name];
        } else if (search === null) {
          delete fixed[name];
        } else {
          fixed[name] = search;
        }
        return this;
      });
      return name !== void 0 && search === void 0 ? ret[0] : ret;
    }
  );
  _api_register3("state()", function(set, ignoreTime) {
    if (!set) {
      return this.context.length ? this.context[0].oSavedState : null;
    }
    var setMutate = $5.extend(true, {}, set);
    return this.iterator("table", function(settings) {
      if (ignoreTime !== false) {
        setMutate.time = +/* @__PURE__ */ new Date() + 100;
      }
      _fnImplementState3(settings, setMutate, function() {
      });
    });
  });
  _api_register3("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register3("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register3("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState3(settings);
    });
  });
  DataTable3.use = function(module, type) {
    if (type === "lib" || module.fn) {
      $5 = module;
    } else if (type == "win" || module.document) {
      window = module;
      document = module.document;
    } else if (type === "datetime" || module.type === "DateTime") {
      DataTable3.DateTime = module;
    }
  };
  DataTable3.factory = function(root, jq) {
    var is = false;
    if (root && root.document) {
      window = root;
      document = root.document;
    }
    if (jq && jq.fn && jq.fn.jquery) {
      $5 = jq;
      is = true;
    }
    return is;
  };
  DataTable3.versionCheck = function(version, version2) {
    var aThis = version2 ? version2.split(".") : DataTable3.version.split(".");
    var aThat = version.split(".");
    var iThis, iThat;
    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable3.isDataTable = function(table) {
    var t = $5(table).get(0);
    var is = false;
    if (table instanceof DataTable3.Api) {
      return true;
    }
    $5.each(DataTable3.settings, function(i, o) {
      var head = o.nScrollHead ? $5("table", o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $5("table", o.nScrollFoot)[0] : null;
      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  DataTable3.tables = function(visible) {
    var api = false;
    if ($5.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a = DataTable3.settings.filter(function(o) {
      return !visible || visible && $5(o.nTable).is(":visible") ? true : false;
    }).map(function(o) {
      return o.nTable;
    });
    return api ? new _Api3(a) : a;
  };
  DataTable3.camelToHungarian = _fnCamelToHungarian3;
  _api_register3("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $5(rows);
    return $5([].concat(
      jqRows.filter(selector).toArray(),
      jqRows.find(selector).toArray()
    ));
  });
  $5.each(["on", "one", "off"], function(i, key) {
    _api_register3(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      args[0] = args[0].split(/\s/).map(function(e) {
        return !e.match(/\.dt\b/) ? e + ".dt" : e;
      }).join(" ");
      var inst = $5(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register3("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable3(settings);
    });
  });
  _api_register3("error()", function(msg) {
    return this.iterator("table", function(settings) {
      _fnLog3(settings, 0, msg);
    });
  });
  _api_register3("settings()", function() {
    return new _Api3(this.context, this.context);
  });
  _api_register3("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register3("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck3(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register3("trigger()", function(name, args, bubbles) {
    return this.iterator("table", function(settings) {
      return _fnCallbackFire3(settings, null, name, args, bubbles);
    }).flatten();
  });
  _api_register3("ready()", function(fn) {
    var ctx = this.context;
    if (!fn) {
      return ctx.length ? ctx[0]._bInitComplete || false : null;
    }
    return this.tables().every(function() {
      if (this.context[0]._bInitComplete) {
        fn.call(this);
      } else {
        this.on("init", function() {
          fn.call(this);
        });
      }
    });
  });
  _api_register3("destroy()", function(remove) {
    remove = remove || false;
    return this.iterator("table", function(settings) {
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $5(table);
      var jqTbody = $5(tbody);
      var jqWrapper = $5(settings.nTableWrapper);
      var rows = settings.aoData.map(function(r) {
        return r ? r.nTr : null;
      });
      var orderClasses = classes.order;
      settings.bDestroying = true;
      _fnCallbackFire3(settings, "aoDestroyCallback", "destroy", [settings], true);
      if (!remove) {
        new _Api3(settings).columns().visible(true);
      }
      jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
      $5(window).off(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.colgroup.remove();
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses3(settings);
      $5("th, td", thead).removeClass(
        orderClasses.canAsc + " " + orderClasses.canDesc + " " + orderClasses.isAsc + " " + orderClasses.isDesc
      ).css("width", "");
      jqTbody.children().detach();
      jqTbody.append(rows);
      var orig = settings.nTableWrapper.parentNode;
      var insertBefore = settings.nTableWrapper.nextSibling;
      var removedMethod = remove ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove && orig) {
        orig.insertBefore(table, insertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.table);
      }
      var idx = DataTable3.settings.indexOf(settings);
      if (idx !== -1) {
        DataTable3.settings.splice(idx, 1);
      }
    });
  });
  $5.each(["column", "row", "cell"], function(i, type) {
    _api_register3(type + "s().every()", function(fn) {
      var opts = this.selector.opts;
      var api = this;
      var inst;
      var counter = 0;
      return this.iterator("every", function(settings, selectedIdx, tableIdx) {
        inst = api[type](selectedIdx, opts);
        if (type === "cell") {
          fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
        } else {
          fn.call(inst, selectedIdx, tableIdx, counter);
        }
        counter++;
      });
    });
  });
  _api_register3("i18n()", function(token, def, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn3(token)(ctx.oLanguage);
    if (resolved === void 0) {
      resolved = def;
    }
    if ($5.isPlainObject(resolved)) {
      resolved = plural !== void 0 && resolved[plural] !== void 0 ? resolved[plural] : resolved._;
    }
    return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
  });
  DataTable3.version = "2.0.5";
  DataTable3.settings = [];
  DataTable3.models = {};
  DataTable3.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     */
    "caseInsensitive": true,
    /**
     * Applied search term
     */
    "search": "",
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     */
    "regex": false,
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     */
    "smart": true,
    /**
     * Flag to indicate if DataTables should only trigger a search when
     * the return key is pressed.
     */
    "return": false
  };
  DataTable3.models.oRow = {
    /**
     * TR element for the row
     */
    "nTr": null,
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     */
    "anCells": null,
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     */
    "_aData": [],
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     */
    "_aSortData": null,
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     */
    "_aFilterData": null,
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     */
    "_sFilterRow": null,
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     */
    "src": null,
    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     */
    "idx": -1,
    /**
     * Cached display value
     */
    displayData: null
  };
  DataTable3.models.oColumn = {
    /**
     * Column index.
     */
    "idx": null,
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     */
    "aDataSort": null,
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     */
    "asSorting": null,
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     */
    "bSearchable": null,
    /**
     * Flag to indicate if the column is sortable or not.
     */
    "bSortable": null,
    /**
     * Flag to indicate if the column is currently visible in the table or not
     */
    "bVisible": null,
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     */
    "_sManualType": null,
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     */
    "_bAttrSrc": false,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     */
    "fnGetData": null,
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     */
    "fnSetData": null,
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     */
    "mData": null,
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     */
    "mRender": null,
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     */
    "sClass": null,
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     */
    "sContentPadding": null,
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     */
    "sName": null,
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     */
    "sSortDataType": "std",
    /**
     * Class to be applied to the header element when sorting on this column
     */
    "sSortingClass": null,
    /**
     * Title of the column - what is seen in the TH element (nTh).
     */
    "sTitle": null,
    /**
     * Column sorting and filtering type
     */
    "sType": null,
    /**
     * Width of the column
     */
    "sWidth": null,
    /**
     * Width of the column when it was first "encountered"
     */
    "sWidthOrig": null,
    /** Cached string which is the longest in the column */
    maxLenString: null,
    /**
     * Store for named searches
     */
    searchFixed: null
  };
  DataTable3.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     */
    "aaData": null,
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     */
    "aaSorting": [[0, "asc"]],
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     */
    "aaSortingFixed": [],
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     */
    "ajax": null,
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     */
    "aLengthMenu": [10, 25, 50, 100],
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     */
    "aoColumns": null,
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     */
    "aoColumnDefs": null,
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     */
    "aoSearchCols": [],
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     */
    "bAutoWidth": true,
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     */
    "bDeferRender": true,
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     */
    "bDestroy": false,
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     */
    "bFilter": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bInfo": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bLengthChange": true,
    /**
     * Enable or disable pagination.
     */
    "bPaginate": true,
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     */
    "bProcessing": false,
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     */
    "bRetrieve": false,
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     */
    "bScrollCollapse": false,
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     */
    "bServerSide": false,
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     */
    "bSort": true,
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     */
    "bSortMulti": true,
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     */
    "bSortCellsTop": null,
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     */
    "bSortClasses": true,
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     */
    "bStateSave": false,
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     */
    "fnCreatedRow": null,
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     */
    "fnDrawCallback": null,
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     */
    "fnFooterCallback": null,
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     */
    "fnFormatNumber": function(toFormat) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     */
    "fnHeaderCallback": null,
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     */
    "fnInfoCallback": null,
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     */
    "fnInitComplete": null,
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     */
    "fnPreDrawCallback": null,
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     */
    "fnRowCallback": null,
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateLoadCallback": function(settings) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            "DataTables_" + settings.sInstance + "_" + location.pathname
          )
        );
      } catch (e) {
        return {};
      }
    },
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     */
    "fnStateLoadParams": null,
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     */
    "fnStateLoaded": null,
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateSaveCallback": function(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname,
          JSON.stringify(data)
        );
      } catch (e) {
      }
    },
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     */
    "fnStateSaveParams": null,
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     */
    "iStateDuration": 7200,
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     */
    "iDisplayLength": 10,
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     */
    "iDisplayStart": 0,
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     */
    "iTabIndex": 0,
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     */
    "oClasses": {},
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be sorted
         */
        "orderable": ": Activate to sort",
        /**
         * ARIA label that is added to the table headers when the column is currently being sorted
         */
        "orderableReverse": ": Activate to invert sorting",
        /**
         * ARIA label that is added to the table headers when the column is currently being 
         * sorted and next step is to remove sorting
         */
        "orderableRemove": ": Activate to remove sorting",
        paginate: {
          first: "First",
          last: "Last",
          next: "Next",
          previous: "Previous"
        }
      },
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       */
      "oPaginate": {
        /**
         * Label and character for first page button ()
         */
        "sFirst": "\xAB",
        /**
         * Last page button ()
         */
        "sLast": "\xBB",
        /**
         * Next page button ()
         */
        "sNext": "\u203A",
        /**
         * Previous page button ()
         */
        "sPrevious": "\u2039"
      },
      /**
       * Plural object for the data type the table is showing
       */
      entries: {
        _: "entries",
        1: "entry"
      },
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       */
      "sEmptyTable": "No data available in table",
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       */
      "sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       */
      "sInfoPostFix": "",
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       */
      "sDecimal": "",
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       */
      "sThousands": ",",
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       */
      "sLengthMenu": "_MENU_ _ENTRIES_ per page",
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       */
      "sLoadingRecords": "Loading...",
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       */
      "sProcessing": "",
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       */
      "sSearch": "Search:",
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       */
      "sUrl": "",
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       */
      "sZeroRecords": "No matching records found"
    },
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     */
    "oSearch": $5.extend({}, DataTable3.models.oSearch),
    /**
     * Table and control layout. This replaces the legacy `dom` option.
     */
    layout: {
      topStart: "pageLength",
      topEnd: "search",
      bottomStart: "info",
      bottomEnd: "paging"
    },
    /**
     * Legacy DOM layout option
     */
    "sDom": null,
    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     */
    "searchDelay": null,
    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     */
    "sPaginationType": "full_numbers",
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     */
    "sScrollX": "",
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     */
    "sScrollXInner": "",
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     */
    "sScrollY": "",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     */
    "sServerMethod": "GET",
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     */
    "renderer": null,
    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     */
    "rowId": "DT_RowId",
    /**
     * Caption value
     */
    "caption": null
  };
  _fnHungarianMap3(DataTable3.defaults);
  DataTable3.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     */
    "aDataSort": null,
    "iDataSort": -1,
    ariaTitle: "",
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     */
    "asSorting": ["asc", "desc", ""],
    /**
     * Enable or disable filtering on the data in this column.
     */
    "bSearchable": true,
    /**
     * Enable or disable ordering on this column.
     */
    "bSortable": true,
    /**
     * Enable or disable the display of this column.
     */
    "bVisible": true,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     */
    "mData": null,
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     */
    "mRender": null,
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     */
    "sCellType": "td",
    /**
     * Class to give to each cell in this column.
     */
    "sClass": "",
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     */
    "sContentPadding": "",
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     */
    "sName": "",
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     */
    "sSortDataType": "std",
    /**
     * The title of this column.
     */
    "sTitle": null,
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     */
    "sType": null,
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     */
    "sWidth": null
  };
  _fnHungarianMap3(DataTable3.defaults.column);
  DataTable3.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bAutoWidth": null,
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all for DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bDeferRender": null,
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bFilter": null,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bInfo": true,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bLengthChange": true,
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bPaginate": null,
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bProcessing": null,
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bServerSide": null,
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSort": null,
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortMulti": null,
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortClasses": null,
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bStateSave": null
    },
    /**
     * Scrolling settings for a table.
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bCollapse": null,
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       */
      "iBarWidth": 0,
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sX": null,
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @deprecated
       */
      "sXInner": null,
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sY": null
    },
    /**
     * Language information for the table.
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       */
      "fnInfoCallback": null
    },
    /**
     * Browser support parameters
     */
    "oBrowser": {
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       */
      "bScrollbarLeft": false,
      /**
       * Browser scrollbar width
       */
      "barWidth": 0
    },
    "ajax": null,
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     */
    "aanFeatures": [],
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     */
    "aoData": [],
    /**
     * Array of indexes which are in the current display (after filtering etc)
     */
    "aiDisplay": [],
    /**
     * Array of indexes for display - no filtering
     */
    "aiDisplayMaster": [],
    /**
     * Map of row ids to data indexes
     */
    "aIds": {},
    /**
     * Store information about each column that is in use
     */
    "aoColumns": [],
    /**
     * Store information about the table's header
     */
    "aoHeader": [],
    /**
     * Store information about the table's footer
     */
    "aoFooter": [],
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "oPreviousSearch": {},
    /**
     * Store for named searches
     */
    searchFixed: {},
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     */
    "aoPreSearchCols": [],
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSorting": null,
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSortingFixed": [],
    /**
     * If restoring a table - we should restore its width
     */
    "sDestroyWidth": 0,
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     */
    "aoRowCallback": [],
    /**
     * Callback functions for the header on each draw.
     */
    "aoHeaderCallback": [],
    /**
     * Callback function for the footer on each draw.
     */
    "aoFooterCallback": [],
    /**
     * Array of callback functions for draw callback functions
     */
    "aoDrawCallback": [],
    /**
     * Array of callback functions for row created function
     */
    "aoRowCreatedCallback": [],
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     */
    "aoPreDrawCallback": [],
    /**
     * Callback functions for when the table has been initialised.
     */
    "aoInitComplete": [],
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     */
    "aoStateSaveParams": [],
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     */
    "aoStateLoadParams": [],
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     */
    "aoStateLoaded": [],
    /**
     * Cache the table ID for quick access
     */
    "sTableId": "",
    /**
     * The TABLE node for the main table
     */
    "nTable": null,
    /**
     * Permanent ref to the thead element
     */
    "nTHead": null,
    /**
     * Permanent ref to the tfoot element - if it exists
     */
    "nTFoot": null,
    /**
     * Permanent ref to the tbody element
     */
    "nTBody": null,
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     */
    "nTableWrapper": null,
    /**
     * Indicate if all required information has been read in
     */
    "bInitialised": false,
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     */
    "aoOpenRows": [],
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sDom": null,
    /**
     * Search delay (in mS)
     */
    "searchDelay": null,
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sPaginationType": "two_button",
    /**
     * Number of paging controls on the page. Only used for backwards compatibility
     */
    pagingControls: 0,
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "iStateDuration": 0,
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateSave": [],
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateLoad": [],
    /**
     * State that was saved. Useful for back reference
     */
    "oSavedState": null,
    /**
     * State that was loaded. Useful for back reference
     */
    "oLoadedState": null,
    /**
     * Note if draw should be blocked while getting data
     */
    "bAjaxDataGet": true,
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     */
    "jqXHR": null,
    /**
     * JSON returned from the server in the last Ajax request
     */
    "json": void 0,
    /**
     * Data submitted as part of the last Ajax request
     */
    "oAjaxData": void 0,
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sServerMethod": null,
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "fnFormatNumber": null,
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aLengthMenu": null,
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     */
    "iDraw": 0,
    /**
     * Indicate if a redraw is being done - useful for Ajax
     */
    "bDrawing": false,
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     */
    "iDrawError": -1,
    /**
     * Paging display length
     */
    "_iDisplayLength": 10,
    /**
     * Paging start point - aiDisplay index
     */
    "_iDisplayStart": 0,
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsTotal": 0,
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsDisplay": 0,
    /**
     * The classes to use for the table
     */
    "oClasses": {},
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bFiltered": false,
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bSorted": false,
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSortCellsTop": null,
    /**
     * Initialisation object that is used for the table
     */
    "oInit": null,
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     */
    "aoDestroyCallback": [],
    /**
     * Get the number of records in the current record set, before filtering
     */
    "fnRecordsTotal": function() {
      return _fnDataSource3(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },
    /**
     * Get the number of records in the current record set, after filtering
     */
    "fnRecordsDisplay": function() {
      return _fnDataSource3(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },
    /**
     * Get the display end point - aiDisplay index
     */
    "fnDisplayEnd": function() {
      var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },
    /**
     * The DataTables object for this table
     */
    "oInstance": null,
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     */
    "sInstance": null,
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
    /**
     * Last applied sort
     */
    "aLastSort": [],
    /**
     * Stored plug-in instances
     */
    "oPlugins": {},
    /**
     * Function used to get a row's id from the row's data
     */
    "rowIdFn": null,
    /**
     * Data location where to store a row's id
     */
    "rowId": null,
    caption: "",
    captionNode: null,
    colgroup: null
  };
  var extPagination3 = DataTable3.ext.pager;
  $5.extend(extPagination3, {
    simple: function() {
      return ["previous", "next"];
    },
    full: function() {
      return ["first", "previous", "next", "last"];
    },
    numbers: function() {
      return ["numbers"];
    },
    simple_numbers: function() {
      return ["previous", "numbers", "next"];
    },
    full_numbers: function() {
      return ["first", "previous", "numbers", "next", "last"];
    },
    first_last: function() {
      return ["first", "last"];
    },
    first_last_numbers: function() {
      return ["first", "numbers", "last"];
    },
    // For testing and plug-ins to use
    _numbers: _pagingNumbers3,
    // Number of number buttons - legacy, use `numbers` option for paging feature
    numbers_length: 7
  });
  $5.extend(true, DataTable3.ext.renderer, {
    pagingButton: {
      _: function(settings, buttonType, content, active, disabled) {
        var classes = settings.oClasses.paging;
        var btnClasses = [classes.button];
        var btn;
        if (active) {
          btnClasses.push(classes.active);
        }
        if (disabled) {
          btnClasses.push(classes.disabled);
        }
        if (buttonType === "ellipsis") {
          btn = $5('<span class="ellipsis"></span>').html(content)[0];
        } else {
          btn = $5("<button>", {
            class: btnClasses.join(" "),
            role: "link",
            type: "button"
          }).html(content);
        }
        return {
          display: btn,
          clicker: btn
        };
      }
    },
    pagingContainer: {
      _: function(settings, buttons) {
        return buttons;
      }
    }
  });
  var _filterString3 = function(stripHtml, normalize) {
    return function(str) {
      if (_empty3(str) || typeof str !== "string") {
        return str;
      }
      str = str.replace(_re_new_lines3, " ");
      if (stripHtml) {
        str = _stripHtml3(str);
      }
      if (normalize) {
        str = _normalize3(str, false);
      }
      return str;
    };
  };
  function __mldFnName2(name) {
    return name.replace(/[\W]/g, "_");
  }
  function __mld3(dt, momentFn, luxonFn, dateFn, arg1) {
    if (window.moment) {
      return dt[momentFn](arg1);
    } else if (window.luxon) {
      return dt[luxonFn](arg1);
    }
    return dateFn ? dt[dateFn](arg1) : dt;
  }
  var __mlWarning3 = false;
  function __mldObj3(d, format, locale) {
    var dt;
    if (window.moment) {
      dt = window.moment.utc(d, format, locale, true);
      if (!dt.isValid()) {
        return null;
      }
    } else if (window.luxon) {
      dt = format && typeof d === "string" ? window.luxon.DateTime.fromFormat(d, format) : window.luxon.DateTime.fromISO(d);
      if (!dt.isValid) {
        return null;
      }
      dt.setLocale(locale);
    } else if (!format) {
      dt = new Date(d);
    } else {
      if (!__mlWarning3) {
        alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
      }
      __mlWarning3 = true;
    }
    return dt;
  }
  function __mlHelper3(localeString) {
    return function(from, to, locale, def) {
      if (arguments.length === 0) {
        locale = "en";
        to = null;
        from = null;
      } else if (arguments.length === 1) {
        locale = "en";
        to = from;
        from = null;
      } else if (arguments.length === 2) {
        locale = to;
        to = from;
        from = null;
      }
      var typeName = "datetime" + (to ? "-" + __mldFnName2(to) : "");
      if (!DataTable3.ext.type.order[typeName]) {
        DataTable3.type(typeName, {
          detect: function(d) {
            return d === typeName ? typeName : false;
          },
          order: {
            pre: function(d) {
              return d.valueOf();
            }
          },
          className: "dt-right"
        });
      }
      return function(d, type) {
        if (d === null || d === void 0) {
          if (def === "--now") {
            var local = /* @__PURE__ */ new Date();
            d = new Date(Date.UTC(
              local.getFullYear(),
              local.getMonth(),
              local.getDate(),
              local.getHours(),
              local.getMinutes(),
              local.getSeconds()
            ));
          } else {
            d = "";
          }
        }
        if (type === "type") {
          return typeName;
        }
        if (d === "") {
          return type !== "sort" ? "" : __mldObj3("0000-01-01 00:00:00", null, locale);
        }
        if (to !== null && from === to && type !== "sort" && type !== "type" && !(d instanceof Date)) {
          return d;
        }
        var dt = __mldObj3(d, from, locale);
        if (dt === null) {
          return d;
        }
        if (type === "sort") {
          return dt;
        }
        var formatted = to === null ? __mld3(dt, "toDate", "toJSDate", "")[localeString]() : __mld3(dt, "format", "toFormat", "toISOString", to);
        return type === "display" ? _escapeHtml3(formatted) : formatted;
      };
    };
  }
  var __thousands3 = ",";
  var __decimal3 = ".";
  if (window.Intl !== void 0) {
    try {
      num = new Intl.NumberFormat().formatToParts(100000.1);
      for (i = 0; i < num.length; i++) {
        if (num[i].type === "group") {
          __thousands3 = num[i].value;
        } else if (num[i].type === "decimal") {
          __decimal3 = num[i].value;
        }
      }
    } catch (e) {
    }
  }
  var num;
  var i;
  DataTable3.datetime = function(format, locale) {
    var typeName = "datetime-detect-" + __mldFnName2(format);
    if (!locale) {
      locale = "en";
    }
    if (!DataTable3.ext.type.order[typeName]) {
      DataTable3.type(typeName, {
        detect: function(d) {
          var dt = __mldObj3(d, format, locale);
          return d === "" || dt ? typeName : false;
        },
        order: {
          pre: function(d) {
            return __mldObj3(d, format, locale) || 0;
          }
        },
        className: "dt-right"
      });
    }
  };
  DataTable3.render = {
    date: __mlHelper3("toLocaleDateString"),
    datetime: __mlHelper3("toLocaleString"),
    time: __mlHelper3("toLocaleTimeString"),
    number: function(thousands, decimal, precision, prefix, postfix) {
      if (thousands === null || thousands === void 0) {
        thousands = __thousands3;
      }
      if (decimal === null || decimal === void 0) {
        decimal = __decimal3;
      }
      return {
        display: function(d) {
          if (typeof d !== "number" && typeof d !== "string") {
            return d;
          }
          if (d === "" || d === null) {
            return d;
          }
          var negative = d < 0 ? "-" : "";
          var flo = parseFloat(d);
          var abs = Math.abs(flo);
          if (abs >= 1e11 || abs < 1e-4 && abs !== 0) {
            var exp = flo.toExponential(precision).split(/e\+?/);
            return exp[0] + " x 10<sup>" + exp[1] + "</sup>";
          }
          if (isNaN(flo)) {
            return _escapeHtml3(d);
          }
          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
          if (intPart === 0 && parseFloat(floatPart) === 0) {
            negative = "";
          }
          return negative + (prefix || "") + intPart.toString().replace(
            /\B(?=(\d{3})+(?!\d))/g,
            thousands
          ) + floatPart + (postfix || "");
        }
      };
    },
    text: function() {
      return {
        display: _escapeHtml3,
        filter: _escapeHtml3
      };
    }
  };
  var _extTypes3 = DataTable3.ext.type;
  DataTable3.type = function(name, prop, val) {
    if (!prop) {
      return {
        className: _extTypes3.className[name],
        detect: _extTypes3.detect.find(function(fn) {
          return fn.name === name;
        }),
        order: {
          pre: _extTypes3.order[name + "-pre"],
          asc: _extTypes3.order[name + "-asc"],
          desc: _extTypes3.order[name + "-desc"]
        },
        render: _extTypes3.render[name],
        search: _extTypes3.search[name]
      };
    }
    var setProp = function(prop2, propVal) {
      _extTypes3[prop2][name] = propVal;
    };
    var setDetect = function(fn) {
      var cb = function(d, s) {
        var ret = fn(d, s);
        return ret === true ? name : ret;
      };
      Object.defineProperty(cb, "name", { value: name });
      var idx = _extTypes3.detect.findIndex(function(fn2) {
        return fn2.name === name;
      });
      if (idx === -1) {
        _extTypes3.detect.unshift(cb);
      } else {
        _extTypes3.detect.splice(idx, 1, cb);
      }
    };
    var setOrder = function(obj) {
      _extTypes3.order[name + "-pre"] = obj.pre;
      _extTypes3.order[name + "-asc"] = obj.asc;
      _extTypes3.order[name + "-desc"] = obj.desc;
    };
    if (val === void 0) {
      val = prop;
      prop = null;
    }
    if (prop === "className") {
      setProp("className", val);
    } else if (prop === "detect") {
      setDetect(val);
    } else if (prop === "order") {
      setOrder(val);
    } else if (prop === "render") {
      setProp("render", val);
    } else if (prop === "search") {
      setProp("search", val);
    } else if (!prop) {
      if (val.className) {
        setProp("className", val.className);
      }
      if (val.detect !== void 0) {
        setDetect(val.detect);
      }
      if (val.order) {
        setOrder(val.order);
      }
      if (val.render !== void 0) {
        setProp("render", val.render);
      }
      if (val.search !== void 0) {
        setProp("search", val.search);
      }
    }
  };
  DataTable3.types = function() {
    return _extTypes3.detect.map(function(fn) {
      return fn.name;
    });
  };
  DataTable3.type("string", {
    detect: function() {
      return "string";
    },
    order: {
      pre: function(a) {
        return _empty3(a) ? "" : typeof a === "string" ? a.toLowerCase() : !a.toString ? "" : a.toString();
      }
    },
    search: _filterString3(false, true)
  });
  DataTable3.type("html", {
    detect: function(d) {
      return _empty3(d) || typeof d === "string" && d.indexOf("<") !== -1 ? "html" : null;
    },
    order: {
      pre: function(a) {
        return _empty3(a) ? "" : a.replace ? _stripHtml3(a).trim().toLowerCase() : a + "";
      }
    },
    search: _filterString3(true, true)
  });
  DataTable3.type("date", {
    className: "dt-type-date",
    detect: function(d) {
      if (d && !(d instanceof Date) && !_re_date3.test(d)) {
        return null;
      }
      var parsed = Date.parse(d);
      return parsed !== null && !isNaN(parsed) || _empty3(d) ? "date" : null;
    },
    order: {
      pre: function(d) {
        var ts = Date.parse(d);
        return isNaN(ts) ? -Infinity : ts;
      }
    }
  });
  DataTable3.type("html-num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric3(d, decimal, true) ? "html-num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace3(d, dp, _re_html3, _re_formatted_numeric3);
      }
    },
    search: _filterString3(true, true)
  });
  DataTable3.type("html-num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric3(d, decimal) ? "html-num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace3(d, dp, _re_html3);
      }
    },
    search: _filterString3(true, true)
  });
  DataTable3.type("num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber3(d, decimal, true) ? "num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace3(d, dp, _re_formatted_numeric3);
      }
    }
  });
  DataTable3.type("num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber3(d, decimal) ? "num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace3(d, dp);
      }
    }
  });
  var __numericReplace3 = function(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === "-")) {
      return -Infinity;
    }
    var type = typeof d;
    if (type === "number" || type === "bigint") {
      return d;
    }
    if (decimalPlace) {
      d = _numToDecimal3(d, decimalPlace);
    }
    if (d.replace) {
      if (re1) {
        d = d.replace(re1, "");
      }
      if (re2) {
        d = d.replace(re2, "");
      }
    }
    return d * 1;
  };
  $5.extend(true, DataTable3.ext.renderer, {
    footer: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.tfoot.cell);
      }
    },
    header: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.thead.cell);
        if (!settings.oFeatures.bSort) {
          cell.addClass(classes.order.none);
        }
        var legacyTop = settings.bSortCellsTop;
        var headerRows = cell.closest("thead").find("tr");
        var rowIdx = cell.parent().index();
        if (
          // Cells and rows which have the attribute to disable the icons
          cell.attr("data-dt-order") === "disable" || cell.parent().attr("data-dt-order") === "disable" || // Legacy support for `orderCellsTop`. If it is set, then cells
          // which are not in the top or bottom row of the header (depending
          // on the value) do not get the sorting classes applied to them
          legacyTop === true && rowIdx !== 0 || legacyTop === false && rowIdx !== headerRows.length - 1
        ) {
          return;
        }
        $5(settings.nTable).on("order.dt.DT", function(e, ctx, sorting) {
          if (settings !== ctx) {
            return;
          }
          var orderClasses = classes.order;
          var columns = ctx.api.columns(cell);
          var col = settings.aoColumns[columns.flatten()[0]];
          var orderable = columns.orderable().includes(true);
          var ariaType = "";
          var indexes = columns.indexes();
          var sortDirs = columns.orderable(true).flatten();
          var orderedColumns = "," + sorting.map(function(val) {
            return val.col;
          }).join(",") + ",";
          cell.removeClass(
            orderClasses.isAsc + " " + orderClasses.isDesc
          ).toggleClass(orderClasses.none, !orderable).toggleClass(orderClasses.canAsc, orderable && sortDirs.includes("asc")).toggleClass(orderClasses.canDesc, orderable && sortDirs.includes("desc"));
          var sortIdx = orderedColumns.indexOf("," + indexes.toArray().join(",") + ",");
          if (sortIdx !== -1) {
            var orderDirs = columns.order();
            cell.addClass(
              orderDirs.includes("asc") ? orderClasses.isAsc : "" + orderDirs.includes("desc") ? orderClasses.isDesc : ""
            );
          }
          if (sortIdx === 0) {
            var firstSort = sorting[0];
            var sortOrder = col.asSorting;
            cell.attr("aria-sort", firstSort.dir === "asc" ? "ascending" : "descending");
            ariaType = !sortOrder[firstSort.index + 1] ? "Remove" : "Reverse";
          } else {
            cell.removeAttr("aria-sort");
          }
          cell.attr(
            "aria-label",
            orderable ? col.ariaTitle + ctx.api.i18n("oAria.orderable" + ariaType) : col.ariaTitle
          );
          if (orderable) {
            cell.find(".dt-column-title").attr("role", "button");
            cell.attr("tabindex", 0);
          }
        });
      }
    },
    layout: {
      _: function(settings, container, items) {
        var row = $5("<div/>").addClass("dt-layout-row").appendTo(container);
        $5.each(items, function(key, val) {
          var klass = !val.table ? "dt-" + key + " " : "";
          if (val.table) {
            row.addClass("dt-layout-table");
          }
          $5("<div/>").attr({
            id: val.id || null,
            "class": "dt-layout-cell " + klass + (val.className || "")
          }).append(val.contents).appendTo(row);
        });
      }
    }
  });
  DataTable3.feature = {};
  DataTable3.feature.register = function(name, cb, legacy) {
    DataTable3.ext.features[name] = cb;
    if (legacy) {
      _ext3.feature.push({
        cFeature: legacy,
        fnInit: cb
      });
    }
  };
  DataTable3.feature.register("info", function(settings, opts) {
    if (!settings.oFeatures.bInfo) {
      return null;
    }
    var lang = settings.oLanguage, tid = settings.sTableId, n = $5("<div/>", {
      "class": settings.oClasses.info.container
    });
    opts = $5.extend({
      callback: lang.fnInfoCallback,
      empty: lang.sInfoEmpty,
      postfix: lang.sInfoPostFix,
      search: lang.sInfoFiltered,
      text: lang.sInfo
    }, opts);
    settings.aoDrawCallback.push(function(s) {
      _fnUpdateInfo3(s, opts, n);
    });
    if (!settings._infoEl) {
      n.attr({
        "aria-live": "polite",
        id: tid + "_info",
        role: "status"
      });
      $5(settings.nTable).attr("aria-describedby", tid + "_info");
      settings._infoEl = n;
    }
    return n;
  }, "i");
  function _fnUpdateInfo3(settings, opts, node) {
    var start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? opts.text : opts.empty;
    if (total !== max) {
      out += " " + opts.search;
    }
    out += opts.postfix;
    out = _fnMacros3(settings, out);
    if (opts.callback) {
      out = opts.callback.call(
        settings.oInstance,
        settings,
        start,
        end,
        max,
        total,
        out
      );
    }
    node.html(out);
    _fnCallbackFire3(settings, null, "info", [settings, node[0], out]);
  }
  var __searchCounter3 = 0;
  DataTable3.feature.register("search", function(settings, opts) {
    if (!settings.oFeatures.bFilter) {
      return null;
    }
    var classes = settings.oClasses.search;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var input = '<input type="search" class="' + classes.input + '"/>';
    opts = $5.extend({
      placeholder: language.sSearchPlaceholder,
      text: language.sSearch
    }, opts);
    if (opts.text.indexOf("_INPUT_") === -1) {
      opts.text += "_INPUT_";
    }
    opts.text = _fnMacros3(settings, opts.text);
    var end = opts.text.match(/_INPUT_$/);
    var start = opts.text.match(/^_INPUT_/);
    var removed = opts.text.replace(/_INPUT_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_INPUT_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_INPUT_";
    }
    var filter = $5("<div>").addClass(classes.container).append(str.replace(/_INPUT_/, input));
    filter.find("label").attr("for", "dt-search-" + __searchCounter3);
    filter.find("input").attr("id", "dt-search-" + __searchCounter3);
    __searchCounter3++;
    var searchFn = function(event) {
      var val = this.value;
      if (previousSearch.return && event.key !== "Enter") {
        return;
      }
      if (val != previousSearch.search) {
        previousSearch.search = val;
        _fnFilterComplete3(settings, previousSearch);
        settings._iDisplayStart = 0;
        _fnDraw3(settings);
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : 0;
    var jqFilter = $5("input", filter).val(previousSearch.search).attr("placeholder", opts.placeholder).on(
      "keyup.DT search.DT input.DT paste.DT cut.DT",
      searchDelay ? DataTable3.util.debounce(searchFn, searchDelay) : searchFn
    ).on("mouseup.DT", function(e) {
      setTimeout(function() {
        searchFn.call(jqFilter[0], e);
      }, 10);
    }).on("keypress.DT", function(e) {
      if (e.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $5(settings.nTable).on("search.dt.DT", function(ev, s) {
      if (settings === s && jqFilter[0] !== document.activeElement) {
        jqFilter.val(
          typeof previousSearch.search !== "function" ? previousSearch.search : ""
        );
      }
    });
    return filter;
  }, "f");
  DataTable3.feature.register("paging", function(settings, opts) {
    if (!settings.oFeatures.bPaginate) {
      return null;
    }
    opts = $5.extend({
      buttons: DataTable3.ext.pager.numbers_length,
      type: settings.sPaginationType,
      boundaryNumbers: true
    }, opts);
    if (opts.numbers) {
      opts.buttons = opts.numbers;
    }
    var host = $5("<div/>").addClass(settings.oClasses.paging.container + " paging_" + opts.type);
    var draw = function() {
      _pagingDraw3(settings, host, opts);
    };
    settings.aoDrawCallback.push(draw);
    $5(settings.nTable).on("column-sizing.dt.DT", draw);
    return host;
  }, "p");
  function _pagingDraw3(settings, host, opts) {
    if (!settings._bInitComplete) {
      return;
    }
    var plugin = DataTable3.ext.pager[opts.type], aria = settings.oLanguage.oAria.paginate || {}, start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin().map(function(val) {
      return val === "numbers" ? _pagingNumbers3(page, pages, opts.buttons, opts.boundaryNumbers) : val;
    }).flat();
    var buttonEls = [];
    for (var i = 0; i < buttons.length; i++) {
      var button = buttons[i];
      var btnInfo = _pagingButtonInfo3(settings, button, page, pages);
      var btn = _fnRenderer3(settings, "pagingButton")(
        settings,
        button,
        btnInfo.display,
        btnInfo.active,
        btnInfo.disabled
      );
      $5(btn.clicker).attr({
        "aria-controls": settings.sTableId,
        "aria-disabled": btnInfo.disabled ? "true" : null,
        "aria-current": btnInfo.active ? "page" : null,
        "aria-label": aria[button],
        "data-dt-idx": button,
        "tabIndex": btnInfo.disabled ? -1 : settings.iTabIndex
      });
      if (typeof button !== "number") {
        $5(btn.clicker).addClass(button);
      }
      _fnBindAction3(
        btn.clicker,
        { action: button },
        function(e) {
          e.preventDefault();
          _fnPageChange3(settings, e.data.action, true);
        }
      );
      buttonEls.push(btn.display);
    }
    var wrapped = _fnRenderer3(settings, "pagingContainer")(
      settings,
      buttonEls
    );
    var activeEl = host.find(document.activeElement).data("dt-idx");
    host.empty().append(wrapped);
    if (activeEl !== void 0) {
      host.find("[data-dt-idx=" + activeEl + "]").trigger("focus");
    }
    if (buttonEls.length && // any buttons
    opts.numbers > 1 && // prevent infinite
    $5(host).height() >= $5(buttonEls[0]).outerHeight() * 2 - 10) {
      _pagingDraw3(settings, host, $5.extend({}, opts, { numbers: opts.numbers - 2 }));
    }
  }
  function _pagingButtonInfo3(settings, button, page, pages) {
    var lang = settings.oLanguage.oPaginate;
    var o = {
      display: "",
      active: false,
      disabled: false
    };
    switch (button) {
      case "ellipsis":
        o.display = "&#x2026;";
        o.disabled = true;
        break;
      case "first":
        o.display = lang.sFirst;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "previous":
        o.display = lang.sPrevious;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "next":
        o.display = lang.sNext;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      case "last":
        o.display = lang.sLast;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      default:
        if (typeof button === "number") {
          o.display = settings.fnFormatNumber(button + 1);
          if (page === button) {
            o.active = true;
          }
        }
        break;
    }
    return o;
  }
  function _pagingNumbers3(page, pages, buttons, addFirstLast) {
    var numbers = [], half = Math.floor(buttons / 2), before = addFirstLast ? 2 : 1, after = addFirstLast ? 1 : 0;
    if (pages <= buttons) {
      numbers = _range3(0, pages);
    } else if (buttons === 1) {
      numbers = [page];
    } else if (buttons === 3) {
      if (page <= 1) {
        numbers = [0, 1, "ellipsis"];
      } else if (page >= pages - 2) {
        numbers = _range3(pages - 2, pages);
        numbers.unshift("ellipsis");
      } else {
        numbers = ["ellipsis", page, "ellipsis"];
      }
    } else if (page <= half) {
      numbers = _range3(0, buttons - before);
      numbers.push("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
      }
    } else if (page >= pages - 1 - half) {
      numbers = _range3(pages - (buttons - before), pages);
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.unshift(0);
      }
    } else {
      numbers = _range3(page - half + before, page + half - after);
      numbers.push("ellipsis");
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
        numbers.unshift(0);
      }
    }
    return numbers;
  }
  var __lengthCounter3 = 0;
  DataTable3.feature.register("pageLength", function(settings, opts) {
    var features = settings.oFeatures;
    if (!features.bPaginate || !features.bLengthChange) {
      return null;
    }
    opts = $5.extend({
      menu: settings.aLengthMenu,
      text: settings.oLanguage.sLengthMenu
    }, opts);
    var classes = settings.oClasses.length, tableId = settings.sTableId, menu = opts.menu, lengths = [], language = [], i;
    if (Array.isArray(menu[0])) {
      lengths = menu[0];
      language = menu[1];
    } else {
      for (i = 0; i < menu.length; i++) {
        if ($5.isPlainObject(menu[i])) {
          lengths.push(menu[i].value);
          language.push(menu[i].label);
        } else {
          lengths.push(menu[i]);
          language.push(menu[i]);
        }
      }
    }
    var end = opts.text.match(/_MENU_$/);
    var start = opts.text.match(/^_MENU_/);
    var removed = opts.text.replace(/_MENU_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_MENU_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_MENU_";
    }
    var div = $5("<div/>").addClass(classes.container).append(
      str.replace("_MENU_", "<span></span>")
    );
    var textNodes = [];
    div.find("label")[0].childNodes.forEach(function(el) {
      if (el.nodeType === Node.TEXT_NODE) {
        textNodes.push({
          el,
          text: el.textContent
        });
      }
    });
    var updateEntries = function(len) {
      textNodes.forEach(function(node) {
        node.el.textContent = _fnMacros3(settings, node.text, len);
      });
    };
    var select = $5("<select/>", {
      "name": tableId + "_length",
      "aria-controls": tableId,
      "class": classes.select
    });
    for (i = 0; i < lengths.length; i++) {
      select[0][i] = new Option(
        typeof language[i] === "number" ? settings.fnFormatNumber(language[i]) : language[i],
        lengths[i]
      );
    }
    div.find("label").attr("for", "dt-length-" + __lengthCounter3);
    select.attr("id", "dt-length-" + __lengthCounter3);
    __lengthCounter3++;
    div.find("span").replaceWith(select);
    $5("select", div).val(settings._iDisplayLength).on("change.DT", function() {
      _fnLengthChange3(settings, $5(this).val());
      _fnDraw3(settings);
    });
    $5(settings.nTable).on("length.dt.DT", function(e, s, len) {
      if (settings === s) {
        $5("select", div).val(len);
        updateEntries(len);
      }
    });
    updateEntries(settings._iDisplayLength);
    return div;
  }, "l");
  $5.fn.dataTable = DataTable3;
  DataTable3.$ = $5;
  $5.fn.dataTableSettings = DataTable3.settings;
  $5.fn.dataTableExt = DataTable3.ext;
  $5.fn.DataTable = function(opts) {
    return $5(this).dataTable(opts).api();
  };
  $5.each(DataTable3, function(prop, val) {
    $5.fn.DataTable[prop] = val;
  });
  var dataTables_default3 = DataTable3;

  // node_modules/datatables.net-fixedcolumns/js/dataTables.fixedColumns.mjs
  var $6 = import_jquery6.default;
  (function() {
    "use strict";
    var $$1;
    var DataTable$1;
    function setJQuery(jq) {
      $$1 = jq;
      DataTable$1 = $$1.fn.dataTable;
    }
    var FixedColumns = (
      /** @class */
      function() {
        function FixedColumns2(settings, opts) {
          var _this = this;
          if (!DataTable$1 || !DataTable$1.versionCheck || !DataTable$1.versionCheck("2")) {
            throw new Error("FixedColumns requires DataTables 2 or newer");
          }
          var table = new DataTable$1.Api(settings);
          this.classes = $$1.extend(true, {}, FixedColumns2.classes);
          this.c = $$1.extend(true, {}, FixedColumns2.defaults, opts);
          this.s = {
            dt: table,
            rtl: $$1(table.table().node()).css("direction") === "rtl"
          };
          if (opts && opts.leftColumns !== void 0) {
            opts.left = opts.leftColumns;
          }
          if (opts && opts.left !== void 0) {
            this.c[this.s.rtl ? "end" : "start"] = opts.left;
          }
          if (opts && opts.rightColumns !== void 0) {
            opts.right = opts.rightColumns;
          }
          if (opts && opts.right !== void 0) {
            this.c[this.s.rtl ? "start" : "end"] = opts.right;
          }
          this.dom = {
            bottomBlocker: $$1("<div>").addClass(this.classes.bottomBlocker),
            topBlocker: $$1("<div>").addClass(this.classes.topBlocker),
            scroller: $$1("div.dt-scroll-body", this.s.dt.table().container())
          };
          if (this.s.dt.settings()[0]._bInitComplete) {
            this._addStyles();
            this._setKeyTableListener();
          } else {
            table.one("init.dt.dtfc", function() {
              _this._addStyles();
              _this._setKeyTableListener();
            });
          }
          table.on("column-sizing.dt.dtfc column-reorder.dt.dtfc draw.dt.dtfc", function() {
            return _this._addStyles();
          });
          var debounced = DataTable$1.util.debounce(function() {
            _this._addStyles();
          }, 50);
          table.on("column-visibility.dt.dtfc", function() {
            debounced();
          });
          this.dom.scroller.on("scroll.dtfc", function() {
            return _this._scroll();
          });
          this._scroll();
          table.settings()[0]._fixedColumns = this;
          table.on("destroy", function() {
            return _this._destroy();
          });
          return this;
        }
        FixedColumns2.prototype.end = function(newVal) {
          if (newVal !== void 0) {
            if (newVal >= 0 && newVal <= this.s.dt.columns().count()) {
              this.c.end = newVal;
              this._addStyles();
            }
            return this;
          }
          return this.c.end;
        };
        FixedColumns2.prototype.left = function(count) {
          return this.s.rtl ? this.end(count) : this.start(count);
        };
        FixedColumns2.prototype.right = function(count) {
          return this.s.rtl ? this.start(count) : this.end(count);
        };
        FixedColumns2.prototype.start = function(newVal) {
          if (newVal !== void 0) {
            if (newVal >= 0 && newVal <= this.s.dt.columns().count()) {
              this.c.start = newVal;
              this._addStyles();
            }
            return this;
          }
          return this.c.start;
        };
        FixedColumns2.prototype._addStyles = function() {
          var dt = this.s.dt;
          var that = this;
          var colCount = this.s.dt.columns(":visible").count();
          var headerStruct = dt.table().header.structure(":visible");
          var footerStruct = dt.table().footer.structure(":visible");
          var widths = dt.columns(":visible").widths().toArray();
          var wrapper = $$1(dt.table().node()).closest("div.dt-scroll");
          var scroller = $$1(dt.table().node()).closest("div.dt-scroll-body")[0];
          var rtl = this.s.rtl;
          var start = this.c.start;
          var end = this.c.end;
          var left = rtl ? end : start;
          var right = rtl ? start : end;
          var barWidth = dt.settings()[0].oBrowser.barWidth;
          if (wrapper.length === 0) {
            return this;
          }
          if (scroller.offsetWidth === scroller.clientWidth) {
            barWidth = 0;
          }
          dt.columns(":visible").every(function(colIdx) {
            var visIdx = dt.column.index("toVisible", colIdx);
            var offset;
            if (visIdx < start) {
              offset = that._sum(widths, visIdx);
              that._fixColumn(visIdx, offset, "start", headerStruct, footerStruct, barWidth);
            } else if (visIdx >= colCount - end) {
              offset = that._sum(widths, colCount - visIdx - 1, true);
              that._fixColumn(visIdx, offset, "end", headerStruct, footerStruct, barWidth);
            } else {
              that._fixColumn(visIdx, 0, "none", headerStruct, footerStruct, barWidth);
            }
          });
          $$1(dt.table().node()).toggleClass(that.classes.tableFixedStart, start > 0).toggleClass(that.classes.tableFixedEnd, end > 0).toggleClass(that.classes.tableFixedLeft, left > 0).toggleClass(that.classes.tableFixedRight, right > 0);
          var headerEl = dt.table().header();
          var footerEl = dt.table().footer();
          var headerHeight = $$1(headerEl).outerHeight();
          var footerHeight = $$1(footerEl).outerHeight();
          this.dom.topBlocker.appendTo(wrapper).css("top", 0).css(this.s.rtl ? "left" : "right", 0).css("height", headerHeight).css("width", barWidth + 1).css("display", barWidth ? "block" : "none");
          if (footerEl) {
            this.dom.bottomBlocker.appendTo(wrapper).css("bottom", 0).css(this.s.rtl ? "left" : "right", 0).css("height", footerHeight).css("width", barWidth + 1).css("display", barWidth ? "block" : "none");
          }
        };
        FixedColumns2.prototype._destroy = function() {
          this.s.dt.off(".dtfc");
          this.dom.scroller.off(".dtfc");
          $$1(this.s.dt.table().node()).removeClass(this.classes.tableScrollingEnd + " " + this.classes.tableScrollingLeft + " " + this.classes.tableScrollingStart + " " + this.classes.tableScrollingRight);
          this.dom.bottomBlocker.remove();
          this.dom.topBlocker.remove();
        };
        FixedColumns2.prototype._fixColumn = function(idx, offset, side, header, footer, barWidth) {
          var _this = this;
          var dt = this.s.dt;
          var applyStyles = function(jq, part) {
            if (side === "none") {
              jq.css("position", "").css("left", "").css("right", "").removeClass(_this.classes.fixedEnd + " " + _this.classes.fixedLeft + " " + _this.classes.fixedRight + " " + _this.classes.fixedStart);
            } else {
              var positionSide = side === "start" ? "left" : "right";
              if (_this.s.rtl) {
                positionSide = side === "start" ? "right" : "left";
              }
              var off = offset;
              if (side === "end" && (part === "header" || part === "footer")) {
                off += barWidth;
              }
              jq.css("position", "sticky").css(positionSide, off).addClass(side === "start" ? _this.classes.fixedStart : _this.classes.fixedEnd).addClass(positionSide === "left" ? _this.classes.fixedLeft : _this.classes.fixedRight);
            }
          };
          header.forEach(function(row) {
            if (row[idx]) {
              applyStyles($$1(row[idx].cell), "header");
            }
          });
          applyStyles(dt.column(idx + ":visible", { page: "current" }).nodes().to$(), "body");
          if (footer) {
            footer.forEach(function(row) {
              if (row[idx]) {
                applyStyles($$1(row[idx].cell), "footer");
              }
            });
          }
        };
        FixedColumns2.prototype._scroll = function() {
          var scroller = this.dom.scroller[0];
          if (!scroller) {
            return;
          }
          var table = $$1(this.s.dt.table().node()).add(this.s.dt.table().header().parentNode).add(this.s.dt.table().footer().parentNode).add("div.dt-scroll-headInner table", this.s.dt.table().container()).add("div.dt-scroll-footInner table", this.s.dt.table().container());
          var scrollLeft = scroller.scrollLeft;
          var ltr = !this.s.rtl;
          var scrollStart = scrollLeft !== 0;
          var scrollEnd = scroller.scrollWidth > scroller.clientWidth + Math.abs(scrollLeft) + 1;
          table.toggleClass(this.classes.tableScrollingStart, scrollStart);
          table.toggleClass(this.classes.tableScrollingEnd, scrollEnd);
          table.toggleClass(this.classes.tableScrollingLeft, scrollStart && ltr || scrollEnd && !ltr);
          table.toggleClass(this.classes.tableScrollingRight, scrollEnd && ltr || scrollStart && !ltr);
        };
        FixedColumns2.prototype._setKeyTableListener = function() {
          var _this = this;
          this.s.dt.on("key-focus.dt.dtfc", function(e, dt, cell) {
            var currScroll;
            var cellPos = $$1(cell.node()).offset();
            var scroller = _this.dom.scroller[0];
            var scroll = $$1($$1(_this.s.dt.table().node()).closest("div.dt-scroll-body"));
            if (_this.c.start > 0) {
              var rightMost = $$1(_this.s.dt.column(_this.c.start - 1).header());
              var rightMostPos = rightMost.offset();
              var rightMostWidth = rightMost.outerWidth();
              if ($$1(cell.node()).hasClass(_this.classes.fixedLeft)) {
                scroll.scrollLeft(0);
              } else if (cellPos.left < rightMostPos.left + rightMostWidth) {
                currScroll = scroll.scrollLeft();
                scroll.scrollLeft(currScroll - (rightMostPos.left + rightMostWidth - cellPos.left));
              }
            }
            if (_this.c.end > 0) {
              var numCols = _this.s.dt.columns().data().toArray().length;
              var cellWidth = $$1(cell.node()).outerWidth();
              var leftMost = $$1(_this.s.dt.column(numCols - _this.c.end).header());
              var leftMostPos = leftMost.offset();
              if ($$1(cell.node()).hasClass(_this.classes.fixedRight)) {
                scroll.scrollLeft(scroller.scrollWidth - scroller.clientWidth);
              } else if (cellPos.left + cellWidth > leftMostPos.left) {
                currScroll = scroll.scrollLeft();
                scroll.scrollLeft(currScroll - (leftMostPos.left - (cellPos.left + cellWidth)));
              }
            }
          });
        };
        FixedColumns2.prototype._sum = function(widths, index, reverse) {
          if (reverse === void 0) {
            reverse = false;
          }
          if (reverse) {
            widths = widths.slice().reverse();
          }
          return widths.slice(0, index).reduce(function(accum, val) {
            return accum + val;
          }, 0);
        };
        FixedColumns2.version = "5.0.0";
        FixedColumns2.classes = {
          bottomBlocker: "dtfc-bottom-blocker",
          fixedEnd: "dtfc-fixed-end",
          fixedLeft: "dtfc-fixed-left",
          fixedRight: "dtfc-fixed-right",
          fixedStart: "dtfc-fixed-start",
          tableFixedEnd: "dtfc-has-end",
          tableFixedLeft: "dtfc-has-left",
          tableFixedRight: "dtfc-has-right",
          tableFixedStart: "dtfc-has-start",
          tableScrollingEnd: "dtfc-scrolling-end",
          tableScrollingLeft: "dtfc-scrolling-left",
          tableScrollingRight: "dtfc-scrolling-right",
          tableScrollingStart: "dtfc-scrolling-start",
          topBlocker: "dtfc-top-blocker"
        };
        FixedColumns2.defaults = {
          i18n: {
            button: "FixedColumns"
          },
          start: 1,
          end: 0
        };
        return FixedColumns2;
      }()
    );
    setJQuery($6);
    $6.fn.dataTable.FixedColumns = FixedColumns;
    $6.fn.DataTable.FixedColumns = FixedColumns;
    var apiRegister2 = dataTables_default3.Api.register;
    apiRegister2("fixedColumns()", function() {
      return this;
    });
    apiRegister2("fixedColumns().start()", function(newVal) {
      var ctx = this.context[0];
      if (newVal !== void 0) {
        ctx._fixedColumns.start(newVal);
        return this;
      } else {
        return ctx._fixedColumns.start();
      }
    });
    apiRegister2("fixedColumns().end()", function(newVal) {
      var ctx = this.context[0];
      if (newVal !== void 0) {
        ctx._fixedColumns.end(newVal);
        return this;
      } else {
        return ctx._fixedColumns.end();
      }
    });
    apiRegister2("fixedColumns().left()", function(newVal) {
      var ctx = this.context[0];
      if (newVal !== void 0) {
        ctx._fixedColumns.left(newVal);
        return this;
      } else {
        return ctx._fixedColumns.left();
      }
    });
    apiRegister2("fixedColumns().right()", function(newVal) {
      var ctx = this.context[0];
      if (newVal !== void 0) {
        ctx._fixedColumns.right(newVal);
        return this;
      } else {
        return ctx._fixedColumns.right();
      }
    });
    dataTables_default3.ext.buttons.fixedColumns = {
      action: function(e, dt, node, config) {
        if ($6(node).attr("active")) {
          $6(node).removeAttr("active").removeClass("active");
          dt.fixedColumns().start(0);
          dt.fixedColumns().end(0);
        } else {
          $6(node).attr("active", "true").addClass("active");
          dt.fixedColumns().start(config.config.start);
          dt.fixedColumns().end(config.config.end);
        }
      },
      config: {
        start: 1,
        end: 0
      },
      init: function(dt, node, config) {
        if (dt.settings()[0]._fixedColumns === void 0) {
          _init2(dt.settings(), config);
        }
        $6(node).attr("active", "true").addClass("active");
        dt.button(node).text(config.text || dt.i18n("buttons.fixedColumns", dt.settings()[0]._fixedColumns.c.i18n.button));
      },
      text: null
    };
    function _init2(settings, options) {
      if (options === void 0) {
        options = null;
      }
      var api = new dataTables_default3.Api(settings);
      var opts = options ? options : api.init().fixedColumns || dataTables_default3.defaults.fixedColumns;
      var fixedColumns = new FixedColumns(api, opts);
      return fixedColumns;
    }
    $6(document).on("plugin-init.dt", function(e, settings) {
      if (e.namespace !== "dt") {
        return;
      }
      if (settings.oInit.fixedColumns || dataTables_default3.defaults.fixedColumns) {
        if (!settings._fixedColumns) {
          _init2(settings, null);
        }
      }
    });
  })();

  // node_modules/datatables.net-fixedheader-bs5/js/fixedHeader.bootstrap5.mjs
  var import_jquery12 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-fixedheader-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs
  var import_jquery9 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-fixedheader-bs5/node_modules/datatables.net-bs5/node_modules/datatables.net/js/dataTables.mjs
  var import_jquery8 = __toESM(require_jquery(), 1);
  var $7 = import_jquery8.default;
  var DataTable4 = function(selector, options) {
    if (DataTable4.factory(selector, options)) {
      return DataTable4;
    }
    if (this instanceof DataTable4) {
      return $7(selector).DataTable(options);
    } else {
      options = selector;
    }
    var _that = this;
    var emptyInit = options === void 0;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.api = function() {
      return new _Api4(this);
    };
    this.each(function() {
      var o = {};
      var oInit = len > 1 ? (
        // optimisation for single table case
        _fnExtend4(o, options, true)
      ) : options;
      var i = 0, iLen;
      var sId = this.getAttribute("id");
      var bInitHandedOff = false;
      var defaults = DataTable4.defaults;
      var $this = $7(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog4(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      $7(this).trigger("options.dt", oInit);
      _fnCompatOpts4(defaults);
      _fnCompatCols4(defaults.column);
      _fnCamelToHungarian4(defaults, defaults, true);
      _fnCamelToHungarian4(defaults.column, defaults.column, true);
      _fnCamelToHungarian4(defaults, $7.extend(oInit, $this.data()), true);
      var allSettings = DataTable4.settings;
      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            new DataTable4.Api(s).destroy();
            break;
          } else {
            _fnLog4(s, 0, "Cannot reinitialise DataTable", 3);
            return;
          }
        }
        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable4.ext._unique++;
        this.id = sId;
      }
      var oSettings = $7.extend(true, {}, DataTable4.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId,
        colgroup: $7("<colgroup>").prependTo(this),
        fastData: function(row, column, type) {
          return _fnGetCellData4(oSettings, row, column, type);
        }
      });
      oSettings.nTable = this;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.api = new _Api4(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts4(oInit);
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : $7.isPlainObject(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0].value : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend4($7.extend(true, {}, defaults), oInit);
      _fnMap4(oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ]);
      _fnMap4(oSettings, oInit, [
        "ajax",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "iStateDuration",
        "bSortCellsTop",
        "iTabIndex",
        "sDom",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        "caption",
        "layout",
        ["iCookieDuration", "iStateDuration"],
        // backwards compat
        ["oSearch", "oPreviousSearch"],
        ["aoSearchCols", "aoPreSearchCols"],
        ["iDisplayLength", "_iDisplayLength"]
      ]);
      _fnMap4(oSettings.oScroll, oInit, [
        ["sScrollX", "sX"],
        ["sScrollXInner", "sXInner"],
        ["sScrollY", "sY"],
        ["bScrollCollapse", "bCollapse"]
      ]);
      _fnMap4(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg4(oSettings, "aoDrawCallback", oInit.fnDrawCallback);
      _fnCallbackReg4(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams);
      _fnCallbackReg4(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams);
      _fnCallbackReg4(oSettings, "aoStateLoaded", oInit.fnStateLoaded);
      _fnCallbackReg4(oSettings, "aoRowCallback", oInit.fnRowCallback);
      _fnCallbackReg4(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow);
      _fnCallbackReg4(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback);
      _fnCallbackReg4(oSettings, "aoFooterCallback", oInit.fnFooterCallback);
      _fnCallbackReg4(oSettings, "aoInitComplete", oInit.fnInitComplete);
      _fnCallbackReg4(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback);
      oSettings.rowIdFn = _fnGetObjectDataFn4(oInit.rowId);
      _fnBrowserDetect4(oSettings);
      var oClasses = oSettings.oClasses;
      $7.extend(oClasses, DataTable4.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.table);
      if (!oSettings.oFeatures.bPaginate) {
        oInit.iDisplayStart = 0;
      }
      if (oSettings.iInitDisplayStart === void 0) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      var oLanguage = oSettings.oLanguage;
      $7.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl) {
        $7.ajax({
          dataType: "json",
          url: oLanguage.sUrl,
          success: function(json) {
            _fnCamelToHungarian4(defaults.oLanguage, json);
            $7.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
            _fnCallbackFire4(oSettings, null, "i18n", [oSettings], true);
            _fnInitialise4(oSettings);
          },
          error: function() {
            _fnLog4(oSettings, 0, "i18n file loading error", 21);
            _fnInitialise4(oSettings);
          }
        });
        bInitHandedOff = true;
      } else {
        _fnCallbackFire4(oSettings, null, "i18n", [oSettings]);
      }
      var columnsInit = [];
      var thead = this.getElementsByTagName("thead");
      var initHeaderLayout = _fnDetectHeader4(oSettings, thead[0]);
      if (oInit.aoColumns) {
        columnsInit = oInit.aoColumns;
      } else if (initHeaderLayout.length) {
        for (i = 0, iLen = initHeaderLayout[0].length; i < iLen; i++) {
          columnsInit.push(null);
        }
      }
      for (i = 0, iLen = columnsInit.length; i < iLen; i++) {
        _fnAddColumn4(oSettings);
      }
      _fnApplyColumnDefs4(oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function(iCol, oDef) {
        _fnColumnOptions4(oSettings, iCol, oDef);
      });
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if (rowOne.length) {
        var a = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $7(rowOne[0]).children("th, td").each(function(i2, cell) {
          var col = oSettings.aoColumns[i2];
          if (!col) {
            _fnLog4(oSettings, 0, "Incorrect column count", 18);
          }
          if (col.mData === i2) {
            var sort = a(cell, "sort") || a(cell, "order");
            var filter = a(cell, "filter") || a(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {
                _: i2 + ".display",
                sort: sort !== null ? i2 + ".@data-" + sort : void 0,
                type: sort !== null ? i2 + ".@data-" + sort : void 0,
                filter: filter !== null ? i2 + ".@data-" + filter : void 0
              };
              col._isArrayHost = true;
              _fnColumnOptions4(oSettings, i2);
            }
          }
        });
      }
      var features = oSettings.oFeatures;
      var loadedInit = function() {
        if (oInit.aaSorting === void 0) {
          var sorting = oSettings.aaSorting;
          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        _fnSortingClasses4(oSettings);
        _fnCallbackReg4(oSettings, "aoDrawCallback", function() {
          if (oSettings.bSorted || _fnDataSource4(oSettings) === "ssp" || features.bDeferRender) {
            _fnSortingClasses4(oSettings);
          }
        });
        var caption = $this.children("caption");
        if (oSettings.caption) {
          if (caption.length === 0) {
            caption = $7("<caption/>").appendTo($this);
          }
          caption.html(oSettings.caption);
        }
        if (caption.length) {
          caption[0]._captionSide = caption.css("caption-side");
          oSettings.captionNode = caption[0];
        }
        if (thead.length === 0) {
          thead = $7("<thead/>").appendTo($this);
        }
        oSettings.nTHead = thead[0];
        $7("tr", thead).addClass(oClasses.thead.row);
        var tbody = $this.children("tbody");
        if (tbody.length === 0) {
          tbody = $7("<tbody/>").insertAfter(thead);
        }
        oSettings.nTBody = tbody[0];
        var tfoot = $this.children("tfoot");
        if (tfoot.length === 0) {
          tfoot = $7("<tfoot/>").appendTo($this);
        }
        oSettings.nTFoot = tfoot[0];
        $7("tr", tfoot).addClass(oClasses.tfoot.row);
        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData4(oSettings, oInit.aaData[i]);
          }
        } else if (_fnDataSource4(oSettings) == "dom") {
          _fnAddTr4(oSettings, $7(oSettings.nTBody).children("tr"));
        }
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        oSettings.bInitialised = true;
        if (bInitHandedOff === false) {
          _fnInitialise4(oSettings);
        }
      };
      _fnCallbackReg4(oSettings, "aoDrawCallback", _fnSaveState4);
      if (oInit.bStateSave) {
        features.bStateSave = true;
        _fnLoadState4(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  DataTable4.ext = _ext4 = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",
    /**
     * Legacy so v1 plug-ins don't throw js errors on load
     */
    feature: [],
    /**
     * Feature plug-ins.
     * 
     * This is an object of callbacks which provide the features for DataTables
     * to be initialised via the `layout` option.
     */
    features: {},
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Automatic column class assignment
       */
      className: {},
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
      /**
       * Automatic renderer assignment
       */
      render: {},
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatibility only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable4.fnVersionCheck,
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable4.version
  };
  $7.extend(_ext4, {
    afnFiltering: _ext4.search,
    aTypes: _ext4.type.detect,
    ofnSearch: _ext4.type.search,
    oSort: _ext4.type.order,
    afnSortData: _ext4.order,
    aoFeatures: _ext4.feature,
    oStdClasses: _ext4.classes,
    oPagination: _ext4.pager
  });
  $7.extend(DataTable4.ext.classes, {
    container: "dt-container",
    empty: {
      row: "dt-empty"
    },
    info: {
      container: "dt-info"
    },
    length: {
      container: "dt-length",
      select: "dt-input"
    },
    order: {
      canAsc: "dt-orderable-asc",
      canDesc: "dt-orderable-desc",
      isAsc: "dt-ordering-asc",
      isDesc: "dt-ordering-desc",
      none: "dt-orderable-none",
      position: "sorting_"
    },
    processing: {
      container: "dt-processing"
    },
    scrolling: {
      body: "dt-scroll-body",
      container: "dt-scroll",
      footer: {
        self: "dt-scroll-foot",
        inner: "dt-scroll-footInner"
      },
      header: {
        self: "dt-scroll-head",
        inner: "dt-scroll-headInner"
      }
    },
    search: {
      container: "dt-search",
      input: "dt-input"
    },
    table: "dataTable",
    tbody: {
      cell: "",
      row: ""
    },
    thead: {
      cell: "",
      row: ""
    },
    tfoot: {
      cell: "",
      row: ""
    },
    paging: {
      active: "current",
      button: "dt-paging-button",
      container: "dt-paging",
      disabled: "disabled"
    }
  });
  var _ext4;
  var _Api4;
  var _api_register4;
  var _api_registerPlural4;
  var _re_dic4 = {};
  var _re_new_lines4 = /[\r\n\u2028]/g;
  var _re_html4 = /<([^>]*>)/g;
  var _max_str_len4 = Math.pow(2, 28);
  var _re_date4 = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;
  var _re_escape_regex4 = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric4 = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty4 = function(d) {
    return !d || d === true || d === "-" ? true : false;
  };
  var _intVal4 = function(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  var _numToDecimal4 = function(num, decimalPoint) {
    if (!_re_dic4[decimalPoint]) {
      _re_dic4[decimalPoint] = new RegExp(_fnEscapeRegex4(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic4[decimalPoint], ".") : num;
  };
  var _isNumber4 = function(d, decimalPoint, formatted) {
    var type = typeof d;
    var strType = type === "string";
    if (type === "number" || type === "bigint") {
      return true;
    }
    if (_empty4(d)) {
      return true;
    }
    if (decimalPoint && strType) {
      d = _numToDecimal4(d, decimalPoint);
    }
    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric4, "");
    }
    return !isNaN(parseFloat(d)) && isFinite(d);
  };
  var _isHtml4 = function(d) {
    return _empty4(d) || typeof d === "string";
  };
  var _htmlNumeric4 = function(d, decimalPoint, formatted) {
    if (_empty4(d)) {
      return true;
    }
    if (typeof d === "string" && d.match(/<(input|select)/i)) {
      return null;
    }
    var html = _isHtml4(d);
    return !html ? null : _isNumber4(_stripHtml4(d), decimalPoint, formatted) ? true : null;
  };
  var _pluck4 = function(a, prop, prop2) {
    var out = [];
    var i = 0, ien = a.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order4 = function(a, order, prop, prop2) {
    var out = [];
    var i = 0, ien = order.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[order[i]]) {
          out.push(a[order[i]][prop]);
        }
      }
    }
    return out;
  };
  var _range4 = function(len, start) {
    var out = [];
    var end;
    if (start === void 0) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }
    for (var i = start; i < end; i++) {
      out.push(i);
    }
    return out;
  };
  var _removeEmpty4 = function(a) {
    var out = [];
    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        out.push(a[i]);
      }
    }
    return out;
  };
  var _stripHtml4 = function(input) {
    if (input.length > _max_str_len4) {
      throw new Error("Exceeded max str len");
    }
    var previous;
    input = input.replace(_re_html4, "");
    do {
      previous = input;
      input = input.replace(/<script/i, "");
    } while (input !== previous);
    return previous;
  };
  var _escapeHtml4 = function(d) {
    if (Array.isArray(d)) {
      d = d.join(",");
    }
    return typeof d === "string" ? d.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d;
  };
  var _normalize4 = function(str, both) {
    if (typeof str !== "string") {
      return str;
    }
    var res = str.normalize("NFD");
    return res.length !== str.length ? (both === true ? str + " " : "") + res.replace(/[\u0300-\u036f]/g, "") : res;
  };
  var _areAllUnique4 = function(src) {
    if (src.length < 2) {
      return true;
    }
    var sorted = src.slice().sort();
    var last = sorted[0];
    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }
      last = sorted[i];
    }
    return true;
  };
  var _unique4 = function(src) {
    if (Array.from && Set) {
      return Array.from(new Set(src));
    }
    if (_areAllUnique4(src)) {
      return src.slice();
    }
    var out = [], val, i, ien = src.length, j, k = 0;
    again: for (i = 0; i < ien; i++) {
      val = src[i];
      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }
      out.push(val);
      k++;
    }
    return out;
  };
  var _flatten4 = function(out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten4(out, val[i]);
      }
    } else {
      out.push(val);
    }
    return out;
  };
  function _addClass4(el, name) {
    if (name) {
      name.split(" ").forEach(function(n) {
        if (n) {
          el.classList.add(n);
        }
      });
    }
  }
  DataTable4.util = {
    /**
     * Return a string with diacritic characters decomposed
     * @param {*} mixed Function or string to normalize
     * @param {*} both Return original string and the normalized string
     * @returns String or undefined
     */
    diacritics: function(mixed, both) {
      var type = typeof mixed;
      if (type !== "function") {
        return _normalize4(mixed, both);
      }
      _normalize4 = mixed;
    },
    /**
     * Debounce a function
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    debounce: function(fn, timeout) {
      var timer;
      return function() {
        var that = this;
        var args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(that, args);
        }, timeout || 250);
      };
    },
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function(fn, freq) {
      var frequency = freq !== void 0 ? freq : 200, last, timer;
      return function() {
        var that = this, now = +/* @__PURE__ */ new Date(), args = arguments;
        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            last = void 0;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },
    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function(val) {
      return val.replace(_re_escape_regex4, "\\$1");
    },
    /**
     * Create a function that will write to a nested object or array
     * @param {*} source JSON notation string
     * @returns Write function
     */
    set: function(source) {
      if ($7.isPlainObject(source)) {
        return DataTable4.util.set(source._);
      } else if (source === null) {
        return function() {
        };
      } else if (typeof source === "function") {
        return function(data, val, meta) {
          source(data, "set", val, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var setData = function(data, val, src) {
          var a = _fnSplitObjNotation4(src), b;
          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;
          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            if (a[i] === "__proto__" || a[i] === "constructor") {
              throw new Error("Cannot set prototype values");
            }
            arrayNotation = a[i].match(__reArray4);
            funcNotation = a[i].match(__reFn4);
            if (arrayNotation) {
              a[i] = a[i].replace(__reArray4, "");
              data[a[i]] = [];
              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join(".");
              if (Array.isArray(val)) {
                for (var j = 0, jLen = val.length; j < jLen; j++) {
                  o = {};
                  setData(o, val[j], innerSrc);
                  data[a[i]].push(o);
                }
              } else {
                data[a[i]] = val;
              }
              return;
            } else if (funcNotation) {
              a[i] = a[i].replace(__reFn4, "");
              data = data[a[i]](val);
            }
            if (data[a[i]] === null || data[a[i]] === void 0) {
              data[a[i]] = {};
            }
            data = data[a[i]];
          }
          if (aLast.match(__reFn4)) {
            data = data[aLast.replace(__reFn4, "")](val);
          } else {
            data[aLast.replace(__reArray4, "")] = val;
          }
        };
        return function(data, val) {
          return setData(data, val, source);
        };
      } else {
        return function(data, val) {
          data[source] = val;
        };
      }
    },
    /**
     * Create a function that will read nested objects from arrays, based on JSON notation
     * @param {*} source JSON notation string
     * @returns Value read
     */
    get: function(source) {
      if ($7.isPlainObject(source)) {
        var o = {};
        $7.each(source, function(key, val) {
          if (val) {
            o[key] = DataTable4.util.get(val);
          }
        });
        return function(data, type, row, meta) {
          var t = o[type] || o._;
          return t !== void 0 ? t(data, type, row, meta) : data;
        };
      } else if (source === null) {
        return function(data) {
          return data;
        };
      } else if (typeof source === "function") {
        return function(data, type, row, meta) {
          return source(data, type, row, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var fetchData = function(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== "") {
            var a = _fnSplitObjNotation4(src);
            for (var i = 0, iLen = a.length; i < iLen; i++) {
              arrayNotation = a[i].match(__reArray4);
              funcNotation = a[i].match(__reFn4);
              if (arrayNotation) {
                a[i] = a[i].replace(__reArray4, "");
                if (a[i] !== "") {
                  data = data[a[i]];
                }
                out = [];
                a.splice(0, i + 1);
                innerSrc = a.join(".");
                if (Array.isArray(data)) {
                  for (var j = 0, jLen = data.length; j < jLen; j++) {
                    out.push(fetchData(data[j], type, innerSrc));
                  }
                }
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join);
                break;
              } else if (funcNotation) {
                a[i] = a[i].replace(__reFn4, "");
                data = data[a[i]]();
                continue;
              }
              if (data === null || data[a[i]] === null) {
                return null;
              } else if (data === void 0 || data[a[i]] === void 0) {
                return void 0;
              }
              data = data[a[i]];
            }
          }
          return data;
        };
        return function(data, type) {
          return fetchData(data, type, source);
        };
      } else {
        return function(data) {
          return data[source];
        };
      }
    },
    stripHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _stripHtml4 = mixed;
        return;
      } else if (type === "string") {
        return _stripHtml4(mixed);
      }
      return mixed;
    },
    escapeHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _escapeHtml4 = mixed;
        return;
      } else if (type === "string" || Array.isArray(mixed)) {
        return _escapeHtml4(mixed);
      }
      return mixed;
    },
    unique: _unique4
  };
  function _fnHungarianMap4(o) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map2 = {};
    $7.each(o, function(key) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map2[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap4(o[key]);
        }
      }
    });
    o._hungarianMap = map2;
  }
  function _fnCamelToHungarian4(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap4(src);
    }
    var hungarianKey;
    $7.each(user, function(key) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $7.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian4(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  var _fnCompatMap4 = function(o, knew, old) {
    if (o[knew] !== void 0) {
      o[old] = o[knew];
    }
  };
  function _fnCompatOpts4(init2) {
    _fnCompatMap4(init2, "ordering", "bSort");
    _fnCompatMap4(init2, "orderMulti", "bSortMulti");
    _fnCompatMap4(init2, "orderClasses", "bSortClasses");
    _fnCompatMap4(init2, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap4(init2, "order", "aaSorting");
    _fnCompatMap4(init2, "orderFixed", "aaSortingFixed");
    _fnCompatMap4(init2, "paging", "bPaginate");
    _fnCompatMap4(init2, "pagingType", "sPaginationType");
    _fnCompatMap4(init2, "pageLength", "iDisplayLength");
    _fnCompatMap4(init2, "searching", "bFilter");
    if (typeof init2.sScrollX === "boolean") {
      init2.sScrollX = init2.sScrollX ? "100%" : "";
    }
    if (typeof init2.scrollX === "boolean") {
      init2.scrollX = init2.scrollX ? "100%" : "";
    }
    var searchCols = init2.aoSearchCols;
    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian4(DataTable4.models.oSearch, searchCols[i]);
        }
      }
    }
    if (init2.serverSide && !init2.searchDelay) {
      init2.searchDelay = 400;
    }
  }
  function _fnCompatCols4(init2) {
    _fnCompatMap4(init2, "orderable", "bSortable");
    _fnCompatMap4(init2, "orderData", "aDataSort");
    _fnCompatMap4(init2, "orderSequence", "asSorting");
    _fnCompatMap4(init2, "orderDataType", "sortDataType");
    var dataSort = init2.aDataSort;
    if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
      init2.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect4(settings) {
    if (!DataTable4.__browser) {
      var browser = {};
      DataTable4.__browser = browser;
      var n = $7("<div/>").css({
        position: "fixed",
        top: 0,
        left: -1 * window.pageXOffset,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(
        $7("<div/>").css({
          position: "absolute",
          top: 1,
          left: 1,
          width: 100,
          overflow: "scroll"
        }).append(
          $7("<div/>").css({
            width: "100%",
            height: 10
          })
        )
      ).appendTo("body");
      var outer = n.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      n.remove();
    }
    $7.extend(settings.oBrowser, DataTable4.__browser);
    settings.oScroll.iBarWidth = DataTable4.__browser.barWidth;
  }
  function _fnAddColumn4(oSettings) {
    var oDefaults = DataTable4.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $7.extend({}, DataTable4.models.oColumn, oDefaults, {
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol,
      searchFixed: {},
      colEl: $7("<col>").attr("data-dt-column", iCol)
    });
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $7.extend({}, DataTable4.models.oSearch, searchCols[iCol]);
  }
  function _fnColumnOptions4(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    if (oOptions !== void 0 && oOptions !== null) {
      _fnCompatCols4(oOptions);
      _fnCamelToHungarian4(DataTable4.defaults.column, oOptions, true);
      if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      var origClass = oCol.sClass;
      $7.extend(oCol, oOptions);
      _fnMap4(oCol, oOptions, "sWidth", "sWidthOrig");
      if (origClass !== oCol.sClass) {
        oCol.sClass = origClass + " " + oCol.sClass;
      }
      if (oOptions.iDataSort !== void 0) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap4(oCol, oOptions, "aDataSort");
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn4(mDataSrc);
    if (oCol.mRender && Array.isArray(oCol.mRender)) {
      var copy = oCol.mRender.slice();
      var name = copy.shift();
      oCol.mRender = DataTable4.render[name].apply(window, copy);
    }
    oCol._render = oCol.mRender ? _fnGetObjectDataFn4(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $7.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, void 0, meta);
      return oCol._render && type ? oCol._render(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn4(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
    }
  }
  function _fnAdjustColumnSizing4(settings) {
    _fnCalculateColumnWidths4(settings);
    _fnColumnSizes4(settings);
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw4(settings);
    }
    _fnCallbackFire4(settings, null, "column-sizing", [settings]);
  }
  function _fnColumnSizes4(settings) {
    var cols = settings.aoColumns;
    for (var i = 0; i < cols.length; i++) {
      var width = _fnColumnsSumWidth4(settings, [i], false, false);
      cols[i].colEl.css("width", width);
    }
  }
  function _fnVisibleToColumnIndex4(oSettings, iMatch) {
    var aiVis = _fnGetColumns4(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible4(oSettings, iMatch) {
    var aiVis = _fnGetColumns4(oSettings, "bVisible");
    var iPos = aiVis.indexOf(iMatch);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns4(settings) {
    var layout = settings.aoHeader;
    var columns = settings.aoColumns;
    var vis = 0;
    if (layout.length) {
      for (var i = 0, ien = layout[0].length; i < ien; i++) {
        if (columns[i].bVisible && $7(layout[0][i].cell).css("display") !== "none") {
          vis++;
        }
      }
    }
    return vis;
  }
  function _fnGetColumns4(oSettings, sParam) {
    var a = [];
    oSettings.aoColumns.map(function(val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  function _fnColumnTypes4(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable4.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, detectedType, cache;
    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            if (!data[k]) {
              continue;
            }
            if (cache[k] === void 0) {
              cache[k] = _fnGetCellData4(settings, k, i, "type");
            }
            detectedType = types[j](cache[k], settings);
            if (!detectedType && j !== types.length - 2) {
              break;
            }
            if (detectedType === "html" && !_empty4(cache[k])) {
              break;
            }
          }
          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        if (!col.sType) {
          col.sType = "string";
        }
      }
      var autoClass = _ext4.type.className[col.sType];
      if (autoClass) {
        _columnAutoClass4(settings.aoHeader, i, autoClass);
        _columnAutoClass4(settings.aoFooter, i, autoClass);
      }
      var renderer = _ext4.type.render[col.sType];
      if (renderer && !col._render) {
        col._render = DataTable4.util.get(renderer);
        _columnAutoRender4(settings, i);
      }
    }
  }
  function _columnAutoRender4(settings, colIdx) {
    var data = settings.aoData;
    for (var i = 0; i < data.length; i++) {
      if (data[i].nTr) {
        var display = _fnGetCellData4(settings, i, colIdx, "display");
        data[i].displayData[colIdx] = display;
        _fnWriteCell4(data[i].anCells[colIdx], display);
      }
    }
  }
  function _columnAutoClass4(container, colIdx, className) {
    container.forEach(function(row) {
      if (row[colIdx] && row[colIdx].unique) {
        _addClass4(row[colIdx].cell, className);
      }
    });
  }
  function _fnApplyColumnDefs4(oSettings, aoColDefs, aoCols, headerLayout, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        if (aoCols[i] && aoCols[i].name) {
          columns[i].sName = aoCols[i].name;
        }
      }
    }
    if (aoColDefs) {
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        var aTargets = def.target !== void 0 ? def.target : def.targets !== void 0 ? def.targets : def.aTargets;
        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          var target = aTargets[j];
          if (typeof target === "number" && target >= 0) {
            while (columns.length <= target) {
              _fnAddColumn4(oSettings);
            }
            fn(target, def);
          } else if (typeof target === "number" && target < 0) {
            fn(columns.length + target, def);
          } else if (typeof target === "string") {
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (target === "_all") {
                fn(k, def);
              } else if (target.indexOf(":name") !== -1) {
                if (columns[k].sName === target.replace(":name", "")) {
                  fn(k, def);
                }
              } else {
                headerLayout.forEach(function(row) {
                  if (row[k]) {
                    var cell = $7(row[k].cell);
                    if (target.match(/^[a-z][\w-]*$/i)) {
                      target = "." + target;
                    }
                    if (cell.is(target)) {
                      fn(k, def);
                    }
                  }
                });
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  function _fnColumnsSumWidth4(settings, targets, original, incVisible) {
    if (!Array.isArray(targets)) {
      targets = _fnColumnsFromHeader4(targets);
    }
    var sum = 0;
    var unit;
    var columns = settings.aoColumns;
    for (var i = 0, ien = targets.length; i < ien; i++) {
      var column = columns[targets[i]];
      var definedWidth = original ? column.sWidthOrig : column.sWidth;
      if (!incVisible && column.bVisible === false) {
        continue;
      }
      if (definedWidth === null || definedWidth === void 0) {
        return null;
      } else if (typeof definedWidth === "number") {
        unit = "px";
        sum += definedWidth;
      } else {
        var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);
        if (matched) {
          sum += matched[1] * 1;
          unit = matched.length === 3 ? matched[2] : "px";
        }
      }
    }
    return sum + unit;
  }
  function _fnColumnsFromHeader4(cell) {
    var attr = $7(cell).closest("[data-dt-column]").attr("data-dt-column");
    if (!attr) {
      return [];
    }
    return attr.split(",").map(function(val) {
      return val * 1;
    });
  }
  function _fnAddData4(settings, dataIn, tr, tds) {
    var rowIdx = settings.aoData.length;
    var rowModel = $7.extend(true, {}, DataTable4.models.oRow, {
      src: tr ? "dom" : "data",
      idx: rowIdx
    });
    rowModel._aData = dataIn;
    settings.aoData.push(rowModel);
    var columns = settings.aoColumns;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    settings.aiDisplayMaster.push(rowIdx);
    var id = settings.rowIdFn(dataIn);
    if (id !== void 0) {
      settings.aIds[id] = rowModel;
    }
    if (tr || !settings.oFeatures.bDeferRender) {
      _fnCreateTr4(settings, rowIdx, tr, tds);
    }
    return rowIdx;
  }
  function _fnAddTr4(settings, trs) {
    var row;
    if (!(trs instanceof $7)) {
      trs = $7(trs);
    }
    return trs.map(function(i, el) {
      row = _fnGetRowElements4(settings, el);
      return _fnAddData4(settings, row.data, el, row.cells);
    });
  }
  function _fnGetCellData4(settings, rowIdx, colIdx, type) {
    if (type === "search") {
      type = "filter";
    } else if (type === "order") {
      type = "sort";
    }
    var row = settings.aoData[rowIdx];
    if (!row) {
      return void 0;
    }
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = row._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings,
      row: rowIdx,
      col: colIdx
    });
    if (type !== "display" && cellData && typeof cellData === "object" && cellData.nodeName) {
      cellData = cellData.innerHTML;
    }
    if (cellData === void 0) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog4(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
      cellData = defaultContent;
    } else if (typeof cellData === "function") {
      return cellData.call(rowData);
    }
    if (cellData === null && type === "display") {
      return "";
    }
    if (type === "filter") {
      var fomatters = DataTable4.ext.type.search;
      if (fomatters[col.sType]) {
        cellData = fomatters[col.sType](cellData);
      }
    }
    return cellData;
  }
  function _fnSetCellData4(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings,
      row: rowIdx,
      col: colIdx
    });
  }
  function _fnWriteCell4(td, val) {
    if (val && typeof val === "object" && val.nodeName) {
      $7(td).empty().append(val);
    } else {
      td.innerHTML = val;
    }
  }
  var __reArray4 = /\[.*?\]$/;
  var __reFn4 = /\(\)$/;
  function _fnSplitObjNotation4(str) {
    var parts = str.match(/(\\.|[^.])+/g) || [""];
    return parts.map(function(s) {
      return s.replace(/\\\./g, ".");
    });
  }
  var _fnGetObjectDataFn4 = DataTable4.util.get;
  var _fnSetObjectDataFn4 = DataTable4.util.set;
  function _fnGetDataMaster4(settings) {
    return _pluck4(settings.aoData, "_aData");
  }
  function _fnClearTable4(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnInvalidate4(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;
    row._aSortData = null;
    row._aFilterData = null;
    row.displayData = null;
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements4(
        settings,
        row,
        colIdx,
        colIdx === void 0 ? void 0 : row._aData
      ).data;
    } else {
      var cells = row.anCells;
      var display = _fnGetRowDisplay4(settings, rowIdx);
      if (cells) {
        if (colIdx !== void 0) {
          _fnWriteCell4(cells[colIdx], display[colIdx]);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            _fnWriteCell4(cells[i], display[i]);
          }
        }
      }
    }
    var cols = settings.aoColumns;
    if (colIdx !== void 0) {
      cols[colIdx].sType = null;
      cols[colIdx].maxLenString = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
        cols[i].maxLenString = null;
      }
      _fnRowAttributes4(settings, row);
    }
  }
  function _fnGetRowElements4(settings, row, colIdx, d) {
    var tds = [], td = row.firstChild, name, col, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d = d !== void 0 ? d : objectRead ? {} : [];
    var attr = function(str, td2) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr2 = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn4(str);
          setter(d, td2.getAttribute(attr2));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === void 0 || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn4(col.mData._);
          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn4(col.mData);
            }
            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }
      i++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn4(settings.rowId)(d, id);
      }
    }
    return {
      data: d,
      cells: tds
    };
  }
  function _fnGetRowDisplay4(settings, rowIdx) {
    let rowModal = settings.aoData[rowIdx];
    let columns = settings.aoColumns;
    if (!rowModal.displayData) {
      rowModal.displayData = [];
      for (var colIdx = 0, len = columns.length; colIdx < len; colIdx++) {
        rowModal.displayData.push(
          _fnGetCellData4(settings, rowIdx, colIdx, "display")
        );
      }
    }
    return rowModal.displayData;
  }
  function _fnCreateTr4(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create, trClass = oSettings.oClasses.tbody.row;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      _addClass4(nTr, trClass);
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes4(oSettings, row);
      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn && anTds[i] ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        if (!nTd) {
          _fnLog4(oSettings, 0, "Incorrect column count", 18);
        }
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd);
        var display = _fnGetRowDisplay4(oSettings, iRow);
        if (create || (oCol.mRender || oCol.mData !== i) && (!$7.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
          _fnWriteCell4(nTd, display[i]);
        }
        if (oCol.bVisible && create) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && !create) {
          nTd.parentNode.removeChild(nTd);
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(
            oSettings.oInstance,
            nTd,
            _fnGetCellData4(oSettings, iRow, i),
            rowData,
            iRow,
            i
          );
        }
      }
      _fnCallbackFire4(oSettings, "aoRowCreatedCallback", "row-created", [nTr, rowData, iRow, cells]);
    } else {
      _addClass4(row.nTr, trClass);
    }
  }
  function _fnRowAttributes4(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique4(row.__rowc.concat(a)) : a;
        $7(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $7(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $7(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead4(settings, side) {
    var classes = settings.oClasses;
    var columns = settings.aoColumns;
    var i, ien, row;
    var target = side === "header" ? settings.nTHead : settings.nTFoot;
    var titleProp = side === "header" ? "sTitle" : side;
    if (!target) {
      return;
    }
    if (side === "header" || _pluck4(settings.aoColumns, titleProp).join("")) {
      row = $7("tr", target);
      if (!row.length) {
        row = $7("<tr/>").appendTo(target);
      }
      if (row.length === 1) {
        var cells = $7("td, th", row);
        for (i = cells.length, ien = columns.length; i < ien; i++) {
          $7("<th/>").html(columns[i][titleProp] || "").appendTo(row);
        }
      }
    }
    var detected = _fnDetectHeader4(settings, target, true);
    if (side === "header") {
      settings.aoHeader = detected;
    } else {
      settings.aoFooter = detected;
    }
    $7(target).children("tr").attr("role", "row");
    $7(target).children("tr").children("th, td").each(function() {
      _fnRenderer4(settings, side)(
        settings,
        $7(this),
        classes
      );
    });
  }
  function _fnHeaderLayout4(settings, source, incColumns) {
    var row, column, cell;
    var local = [];
    var structure = [];
    var columns = settings.aoColumns;
    var columnCount = columns.length;
    var rowspan, colspan;
    if (!source) {
      return;
    }
    if (!incColumns) {
      incColumns = _range4(columnCount).filter(function(idx) {
        return columns[idx].bVisible;
      });
    }
    for (row = 0; row < source.length; row++) {
      local[row] = source[row].slice().filter(function(cell2, i) {
        return incColumns.includes(i);
      });
      structure.push([]);
    }
    for (row = 0; row < local.length; row++) {
      for (column = 0; column < local[row].length; column++) {
        rowspan = 1;
        colspan = 1;
        if (structure[row][column] === void 0) {
          cell = local[row][column].cell;
          while (local[row + rowspan] !== void 0 && local[row][column].cell == local[row + rowspan][column].cell) {
            structure[row + rowspan][column] = null;
            rowspan++;
          }
          while (local[row][column + colspan] !== void 0 && local[row][column].cell == local[row][column + colspan].cell) {
            for (var k = 0; k < rowspan; k++) {
              structure[row + k][column + colspan] = null;
            }
            colspan++;
          }
          var titleSpan = $7("span.dt-column-title", cell);
          structure[row][column] = {
            cell,
            colspan,
            rowspan,
            title: titleSpan.length ? titleSpan.html() : $7(cell).html()
          };
        }
      }
    }
    return structure;
  }
  function _fnDrawHead4(settings, source) {
    var layout = _fnHeaderLayout4(settings, source);
    var tr, n;
    for (var row = 0; row < source.length; row++) {
      tr = source[row].row;
      if (tr) {
        while (n = tr.firstChild) {
          tr.removeChild(n);
        }
      }
      for (var column = 0; column < layout[row].length; column++) {
        var point = layout[row][column];
        if (point) {
          $7(point.cell).appendTo(tr).attr("rowspan", point.rowspan).attr("colspan", point.colspan);
        }
      }
    }
  }
  function _fnDraw4(oSettings, ajaxComplete) {
    _fnStart4(oSettings);
    var aPreDraw = _fnCallbackFire4(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if (aPreDraw.indexOf(false) !== -1) {
      _fnProcessingDisplay4(oSettings, false);
      return;
    }
    var anRows = [];
    var iRowCount = 0;
    var bServerSide = _fnDataSource4(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    var columns = oSettings.aoColumns;
    var body = $7(oSettings.nTBody);
    oSettings.bDrawing = true;
    if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !ajaxComplete) {
      if (oSettings.iDraw === 0) {
        body.empty().append(_emptyRow4(oSettings));
      }
      _fnAjaxUpdate4(oSettings);
      return;
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr4(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        for (var i = 0; i < columns.length; i++) {
          var col = columns[i];
          var td = aoData.anCells[i];
          _addClass4(td, _ext4.type.className[col.sType]);
          _addClass4(td, col.sClass);
          _addClass4(td, oSettings.oClasses.tbody.cell);
        }
        _fnCallbackFire4(
          oSettings,
          "aoRowCallback",
          null,
          [nRow, aoData._aData, iRowCount, j, iDataIndex]
        );
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      anRows[0] = _emptyRow4(oSettings);
    }
    _fnCallbackFire4(oSettings, "aoHeaderCallback", "header", [
      $7(oSettings.nTHead).children("tr")[0],
      _fnGetDataMaster4(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    _fnCallbackFire4(oSettings, "aoFooterCallback", "footer", [
      $7(oSettings.nTFoot).children("tr")[0],
      _fnGetDataMaster4(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    if (body[0].replaceChildren) {
      body[0].replaceChildren.apply(body[0], anRows);
    } else {
      body.children().detach();
      body.append($7(anRows));
    }
    $7(oSettings.nTableWrapper).toggleClass("dt-empty-footer", $7("tr", oSettings.nTFoot).length === 0);
    _fnCallbackFire4(oSettings, "aoDrawCallback", "draw", [oSettings], true);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw4(settings, holdPosition, recompute) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (recompute === void 0 || recompute === true) {
      if (sort) {
        _fnSort4(settings);
      }
      if (filter) {
        _fnFilterComplete4(settings, settings.oPreviousSearch);
      } else {
        settings.aiDisplay = settings.aiDisplayMaster.slice();
      }
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw4(settings);
    settings._drawHold = false;
  }
  function _emptyRow4(settings) {
    var oLang = settings.oLanguage;
    var zero = oLang.sZeroRecords;
    var dataSrc = _fnDataSource4(settings);
    if (settings.iDraw < 1 && dataSrc === "ssp" || settings.iDraw <= 1 && dataSrc === "ajax") {
      zero = oLang.sLoadingRecords;
    } else if (oLang.sEmptyTable && settings.fnRecordsTotal() === 0) {
      zero = oLang.sEmptyTable;
    }
    return $7("<tr/>").append($7("<td />", {
      "colSpan": _fnVisbleColumns4(settings),
      "class": settings.oClasses.empty.row
    }).html(zero))[0];
  }
  function _layoutArray4(settings, layout, side) {
    var groups = {};
    $7.each(layout, function(pos, val) {
      if (val === null) {
        return;
      }
      var splitPos = pos.replace(/([A-Z])/g, " $1").split(" ");
      if (!groups[splitPos[0]]) {
        groups[splitPos[0]] = {};
      }
      var align = splitPos.length === 1 ? "full" : splitPos[1].toLowerCase();
      var group = groups[splitPos[0]];
      var groupRun = function(contents, innerVal) {
        if ($7.isPlainObject(innerVal)) {
          Object.keys(innerVal).map(function(key) {
            contents.push({
              feature: key,
              opts: innerVal[key]
            });
          });
        } else {
          contents.push(innerVal);
        }
      };
      if (!group[align] || !group[align].contents) {
        group[align] = { contents: [] };
      }
      if (Array.isArray(val)) {
        for (var i2 = 0; i2 < val.length; i2++) {
          groupRun(group[align].contents, val[i2]);
        }
      } else {
        groupRun(group[align].contents, val);
      }
      if (!Array.isArray(group[align].contents)) {
        group[align].contents = [group[align].contents];
      }
    });
    var filtered = Object.keys(groups).map(function(pos) {
      if (pos.indexOf(side) !== 0) {
        return null;
      }
      return {
        name: pos,
        val: groups[pos]
      };
    }).filter(function(item) {
      return item !== null;
    });
    filtered.sort(function(a, b) {
      var order1 = a.name.replace(/[^0-9]/g, "") * 1;
      var order2 = b.name.replace(/[^0-9]/g, "") * 1;
      return order2 - order1;
    });
    if (side === "bottom") {
      filtered.reverse();
    }
    var rows = [];
    for (var i = 0, ien = filtered.length; i < ien; i++) {
      if (filtered[i].val.full) {
        rows.push({ full: filtered[i].val.full });
        _layoutResolve4(settings, rows[rows.length - 1]);
        delete filtered[i].val.full;
      }
      if (Object.keys(filtered[i].val).length) {
        rows.push(filtered[i].val);
        _layoutResolve4(settings, rows[rows.length - 1]);
      }
    }
    return rows;
  }
  function _layoutResolve4(settings, row) {
    var getFeature = function(feature, opts) {
      if (!_ext4.features[feature]) {
        _fnLog4(settings, 0, "Unknown feature: " + feature);
      }
      return _ext4.features[feature].apply(this, [settings, opts]);
    };
    var resolve = function(item) {
      var line = row[item].contents;
      for (var i = 0, ien = line.length; i < ien; i++) {
        if (!line[i]) {
          continue;
        } else if (typeof line[i] === "string") {
          line[i] = getFeature(line[i], null);
        } else if ($7.isPlainObject(line[i])) {
          line[i] = getFeature(line[i].feature, line[i].opts);
        } else if (typeof line[i].node === "function") {
          line[i] = line[i].node(settings);
        } else if (typeof line[i] === "function") {
          var inst = line[i](settings);
          line[i] = typeof inst.node === "function" ? inst.node() : inst;
        }
      }
    };
    $7.each(row, function(key) {
      resolve(key);
    });
  }
  function _fnAddOptionsHtml4(settings) {
    var classes = settings.oClasses;
    var table = $7(settings.nTable);
    var insert = $7("<div/>").attr({
      id: settings.sTableId + "_wrapper",
      "class": classes.container
    }).insertBefore(table);
    settings.nTableWrapper = insert[0];
    if (settings.sDom) {
      _fnLayoutDom4(settings, settings.sDom, insert);
    } else {
      var top = _layoutArray4(settings, settings.layout, "top");
      var bottom = _layoutArray4(settings, settings.layout, "bottom");
      var renderer = _fnRenderer4(settings, "layout");
      top.forEach(function(item) {
        renderer(settings, insert, item);
      });
      renderer(settings, insert, {
        full: {
          table: true,
          contents: [_fnFeatureHtmlTable4(settings)]
        }
      });
      bottom.forEach(function(item) {
        renderer(settings, insert, item);
      });
    }
    _processingHtml4(settings);
  }
  function _fnLayoutDom4(settings, dom, insert) {
    var parts = dom.match(/(".*?")|('.*?')|./g);
    var featureNode, option, newNode, next, attr;
    for (var i = 0; i < parts.length; i++) {
      featureNode = null;
      option = parts[i];
      if (option == "<") {
        newNode = $7("<div/>");
        next = parts[i + 1];
        if (next[0] == "'" || next[0] == '"') {
          attr = next.replace(/['"]/g, "");
          var id = "", className;
          if (attr.indexOf(".") != -1) {
            var split = attr.split(".");
            id = split[0];
            className = split[1];
          } else if (attr[0] == "#") {
            id = attr;
          } else {
            className = attr;
          }
          newNode.attr("id", id.substring(1)).addClass(className);
          i++;
        }
        insert.append(newNode);
        insert = newNode;
      } else if (option == ">") {
        insert = insert.parent();
      } else if (option == "t") {
        featureNode = _fnFeatureHtmlTable4(settings);
      } else {
        DataTable4.ext.feature.forEach(function(feature) {
          if (option == feature.cFeature) {
            featureNode = feature.fnInit(settings);
          }
        });
      }
      if (featureNode) {
        insert.append(featureNode);
      }
    }
  }
  function _fnDetectHeader4(settings, thead, write) {
    var columns = settings.aoColumns;
    var rows = $7(thead).children("tr");
    var row, cell;
    var i, k, l, iLen, shifted, column, colspan, rowspan;
    var isHeader = thead && thead.nodeName.toLowerCase() === "thead";
    var layout = [];
    var unique;
    var shift = function(a, i2, j) {
      var k2 = a[i2];
      while (k2[j]) {
        j++;
      }
      return j;
    };
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      layout.push([]);
    }
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      row = rows[i];
      column = 0;
      cell = row.firstChild;
      while (cell) {
        if (cell.nodeName.toUpperCase() == "TD" || cell.nodeName.toUpperCase() == "TH") {
          var cols = [];
          colspan = cell.getAttribute("colspan") * 1;
          rowspan = cell.getAttribute("rowspan") * 1;
          colspan = !colspan || colspan === 0 || colspan === 1 ? 1 : colspan;
          rowspan = !rowspan || rowspan === 0 || rowspan === 1 ? 1 : rowspan;
          shifted = shift(layout, i, column);
          unique = colspan === 1 ? true : false;
          if (write) {
            if (unique) {
              _fnColumnOptions4(settings, shifted, $7(cell).data());
              var columnDef = columns[shifted];
              var width = cell.getAttribute("width") || null;
              var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
              if (t) {
                width = t[1];
              }
              columnDef.sWidthOrig = columnDef.sWidth || width;
              if (isHeader) {
                if (columnDef.sTitle !== null && !columnDef.autoTitle) {
                  cell.innerHTML = columnDef.sTitle;
                }
                if (!columnDef.sTitle && unique) {
                  columnDef.sTitle = _stripHtml4(cell.innerHTML);
                  columnDef.autoTitle = true;
                }
              } else {
                if (columnDef.footer) {
                  cell.innerHTML = columnDef.footer;
                }
              }
              if (!columnDef.ariaTitle) {
                columnDef.ariaTitle = $7(cell).attr("aria-label") || columnDef.sTitle;
              }
              if (columnDef.className) {
                $7(cell).addClass(columnDef.className);
              }
            }
            if ($7("span.dt-column-title", cell).length === 0) {
              $7("<span>").addClass("dt-column-title").append(cell.childNodes).appendTo(cell);
            }
            if (isHeader && $7("span.dt-column-order", cell).length === 0) {
              $7("<span>").addClass("dt-column-order").appendTo(cell);
            }
          }
          for (l = 0; l < colspan; l++) {
            for (k = 0; k < rowspan; k++) {
              layout[i + k][shifted + l] = {
                cell,
                unique
              };
              layout[i + k].row = row;
            }
            cols.push(shifted + l);
          }
          cell.setAttribute("data-dt-column", _unique4(cols).join(","));
        }
        cell = cell.nextSibling;
      }
    }
    return layout;
  }
  function _fnStart4(oSettings) {
    var bServerSide = _fnDataSource4(oSettings) == "ssp";
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
  }
  function _fnBuildAjax4(oSettings, data, fn) {
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
      if (json === null || typeof status === "number" && status == 204) {
        json = {};
        _fnAjaxDataSrc4(oSettings, json, []);
      }
      var error = json.error || json.sError;
      if (error) {
        _fnLog4(oSettings, 0, error);
      }
      oSettings.json = json;
      _fnCallbackFire4(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR], true);
      fn(json);
    };
    if ($7.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === "function" ? ajaxData(data, oSettings) : (
        // fn can manipulate data or return
        ajaxData
      );
      data = typeof ajaxData === "function" && newData ? newData : $7.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {
      "url": typeof ajax === "string" ? ajax : "",
      "data": data,
      "success": callback,
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function(xhr, error) {
        var ret = _fnCallbackFire4(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR], true);
        if (ret.indexOf(true) === -1) {
          if (error == "parsererror") {
            _fnLog4(oSettings, 0, "Invalid JSON response", 1);
          } else if (xhr.readyState === 4) {
            _fnLog4(oSettings, 0, "Ajax error", 7);
          }
        }
        _fnProcessingDisplay4(oSettings, false);
      }
    };
    if ($7.isPlainObject(ajax)) {
      $7.extend(baseAjax, ajax);
    }
    oSettings.oAjaxData = data;
    _fnCallbackFire4(oSettings, null, "preXhr", [oSettings, data, baseAjax], true);
    if (typeof ajax === "function") {
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else if (ajax.url === "") {
      var empty = {};
      DataTable4.util.set(ajax.dataSrc)(empty, []);
      callback(empty);
    } else {
      oSettings.jqXHR = $7.ajax(baseAjax);
      if (ajaxData) {
        ajax.data = ajaxData;
      }
    }
  }
  function _fnAjaxUpdate4(settings) {
    settings.iDraw++;
    _fnProcessingDisplay4(settings, true);
    _fnBuildAjax4(
      settings,
      _fnAjaxParameters4(settings),
      function(json) {
        _fnAjaxUpdateDraw4(settings, json);
      }
    );
  }
  function _fnAjaxParameters4(settings) {
    var columns = settings.aoColumns, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, colData = function(idx, prop) {
      return typeof columns[idx][prop] === "function" ? "function" : columns[idx][prop];
    };
    return {
      draw: settings.iDraw,
      columns: columns.map(function(column, i) {
        return {
          data: colData(i, "mData"),
          name: column.sName,
          searchable: column.bSearchable,
          orderable: column.bSortable,
          search: {
            value: preColSearch[i].search,
            regex: preColSearch[i].regex,
            fixed: Object.keys(column.searchFixed).map(function(name) {
              return {
                name,
                term: column.searchFixed[name].toString()
              };
            })
          }
        };
      }),
      order: _fnSortFlatten4(settings).map(function(val) {
        return {
          column: val.col,
          dir: val.dir,
          name: colData(val.col, "sName")
        };
      }),
      start: settings._iDisplayStart,
      length: features.bPaginate ? settings._iDisplayLength : -1,
      search: {
        value: preSearch.search,
        regex: preSearch.regex,
        fixed: Object.keys(settings.searchFixed).map(function(name) {
          return {
            name,
            term: settings.searchFixed[name].toString()
          };
        })
      }
    };
  }
  function _fnAjaxUpdateDraw4(settings, json) {
    var data = _fnAjaxDataSrc4(settings, json);
    var draw = _fnAjaxDataSrcParam4(settings, "draw", json);
    var recordsTotal = _fnAjaxDataSrcParam4(settings, "recordsTotal", json);
    var recordsFiltered = _fnAjaxDataSrcParam4(settings, "recordsFiltered", json);
    if (draw !== void 0) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    if (!data) {
      data = [];
    }
    _fnClearTable4(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData4(settings, data[i]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnDraw4(settings, true);
    _fnInitComplete4(settings);
    _fnProcessingDisplay4(settings, false);
  }
  function _fnAjaxDataSrc4(settings, json, write) {
    var dataProp = "data";
    if ($7.isPlainObject(settings.ajax) && settings.ajax.dataSrc !== void 0) {
      var dataSrc = settings.ajax.dataSrc;
      if (typeof dataSrc === "string" || typeof dataSrc === "function") {
        dataProp = dataSrc;
      } else if (dataSrc.data !== void 0) {
        dataProp = dataSrc.data;
      }
    }
    if (!write) {
      if (dataProp === "data") {
        return json.aaData || json[dataProp];
      }
      return dataProp !== "" ? _fnGetObjectDataFn4(dataProp)(json) : json;
    }
    _fnSetObjectDataFn4(dataProp)(json, write);
  }
  function _fnAjaxDataSrcParam4(settings, param, json) {
    var dataSrc = $7.isPlainObject(settings.ajax) ? settings.ajax.dataSrc : null;
    if (dataSrc && dataSrc[param]) {
      return _fnGetObjectDataFn4(dataSrc[param])(json);
    }
    var old = "";
    if (param === "draw") {
      old = "sEcho";
    } else if (param === "recordsTotal") {
      old = "iTotalRecords";
    } else if (param === "recordsFiltered") {
      old = "iTotalDisplayRecords";
    }
    return json[old] !== void 0 ? json[old] : json[param];
  }
  function _fnFilterComplete4(settings, input) {
    var columnsSearch = settings.aoPreSearchCols;
    _fnColumnTypes4(settings);
    if (_fnDataSource4(settings) != "ssp") {
      _fnFilterData4(settings);
      settings.aiDisplay = settings.aiDisplayMaster.slice();
      _fnFilter4(settings.aiDisplay, settings, input.search, input);
      $7.each(settings.searchFixed, function(name, term) {
        _fnFilter4(settings.aiDisplay, settings, term, {});
      });
      for (var i = 0; i < columnsSearch.length; i++) {
        var col = columnsSearch[i];
        _fnFilter4(
          settings.aiDisplay,
          settings,
          col.search,
          col,
          i
        );
        $7.each(settings.aoColumns[i].searchFixed, function(name, term) {
          _fnFilter4(settings.aiDisplay, settings, term, {}, i);
        });
      }
      _fnFilterCustom4(settings);
    }
    settings.bFiltered = true;
    _fnCallbackFire4(settings, null, "search", [settings]);
  }
  function _fnFilterCustom4(settings) {
    var filters = DataTable4.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = [];
      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];
        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      displayRows.push.apply(displayRows, rows);
    }
  }
  function _fnFilter4(searchRows, settings, input, options, column) {
    if (input === "") {
      return;
    }
    var i = 0;
    var searchFunc = typeof input === "function" ? input : null;
    var rpSearch = input instanceof RegExp ? input : searchFunc ? null : _fnFilterCreateSearch4(input, options);
    while (i < searchRows.length) {
      var row = settings.aoData[searchRows[i]];
      var data = column === void 0 ? row._sFilterRow : row._aFilterData[column];
      if (searchFunc && !searchFunc(data, row._aData, searchRows[i], column) || rpSearch && !rpSearch.test(data)) {
        searchRows.splice(i, 1);
        i--;
      }
      i++;
    }
  }
  function _fnFilterCreateSearch4(search, inOpts) {
    var not = [];
    var options = $7.extend({}, {
      boundary: false,
      caseInsensitive: true,
      exact: false,
      regex: false,
      smart: true
    }, inOpts);
    if (typeof search !== "string") {
      search = search.toString();
    }
    search = _normalize4(search);
    if (options.exact) {
      return new RegExp(
        "^" + _fnEscapeRegex4(search) + "$",
        options.caseInsensitive ? "i" : ""
      );
    }
    search = options.regex ? search : _fnEscapeRegex4(search);
    if (options.smart) {
      var parts = search.match(/!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""];
      var a = parts.map(function(word) {
        var negative = false;
        var m2;
        if (word.charAt(0) === "!") {
          negative = true;
          word = word.substring(1);
        }
        if (word.charAt(0) === '"') {
          m2 = word.match(/^"(.*)"$/);
          word = m2 ? m2[1] : word;
        } else if (word.charAt(0) === "\u201C") {
          m2 = word.match(/^\u201C(.*)\u201D$/);
          word = m2 ? m2[1] : word;
        }
        if (negative) {
          if (word.length > 1) {
            not.push("(?!" + word + ")");
          }
          word = "";
        }
        return word.replace(/"/g, "");
      });
      var match = not.length ? not.join("") : "";
      var boundary = options.boundary ? "\\b" : "";
      search = "^(?=.*?" + boundary + a.join(")(?=.*?" + boundary) + ")(" + match + ".)*$";
    }
    return new RegExp(search, options.caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex4 = DataTable4.util.escapeRegex;
  var __filter_div4 = $7("<div>")[0];
  var __filter_div_textContent4 = __filter_div4.textContent !== void 0;
  function _fnFilterData4(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var column;
    var j, jen, filterData, cellData, row;
    var wasInvalidated = false;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aFilterData) {
        filterData = [];
        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];
          if (column.bSearchable) {
            cellData = _fnGetCellData4(settings, rowIdx, j, "filter");
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div4.innerHTML = cellData;
            cellData = __filter_div_textContent4 ? __filter_div4.textContent : __filter_div4.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnInitialise4(settings) {
    var i, iAjaxStart = settings.iInitDisplayStart;
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise4(settings);
      }, 200);
      return;
    }
    _fnBuildHead4(settings, "header");
    _fnBuildHead4(settings, "footer");
    _fnDrawHead4(settings, settings.aoHeader);
    _fnDrawHead4(settings, settings.aoFooter);
    _fnAddOptionsHtml4(settings);
    _fnSortInit4(settings);
    _colGroup4(settings);
    _fnProcessingDisplay4(settings, true);
    _fnCallbackFire4(settings, null, "preInit", [settings], true);
    _fnReDraw4(settings);
    var dataSrc = _fnDataSource4(settings);
    if (dataSrc != "ssp") {
      if (dataSrc == "ajax") {
        _fnBuildAjax4(settings, {}, function(json) {
          var aData = _fnAjaxDataSrc4(settings, json);
          for (i = 0; i < aData.length; i++) {
            _fnAddData4(settings, aData[i]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw4(settings);
          _fnProcessingDisplay4(settings, false);
          _fnInitComplete4(settings);
        }, settings);
      } else {
        _fnInitComplete4(settings);
        _fnProcessingDisplay4(settings, false);
      }
    }
  }
  function _fnInitComplete4(settings) {
    if (settings._bInitComplete) {
      return;
    }
    var args = [settings, settings.json];
    settings._bInitComplete = true;
    _fnAdjustColumnSizing4(settings);
    _fnCallbackFire4(settings, null, "plugin-init", args, true);
    _fnCallbackFire4(settings, "aoInitComplete", "init", args, true);
  }
  function _fnLengthChange4(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow4(settings);
    _fnCallbackFire4(settings, null, "length", [settings, len]);
  }
  function _fnPageChange4(settings, action, redraw) {
    var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;
      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;
      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else if (action === "ellipsis") {
      return;
    } else {
      _fnLog4(settings, 0, "Unknown paging action: " + action, 5);
    }
    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;
    _fnCallbackFire4(settings, null, changed ? "page" : "page-nc", [settings]);
    if (changed && redraw) {
      _fnDraw4(settings);
    }
    return changed;
  }
  function _processingHtml4(settings) {
    var table = settings.nTable;
    if (settings.oFeatures.bProcessing) {
      var n = $7("<div/>", {
        "id": settings.sTableId + "_processing",
        "class": settings.oClasses.processing.container,
        "role": "status"
      }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>").insertBefore(table);
      $7(table).on("processing.dt.DT", function(e, s, show) {
        n.css("display", show ? "block" : "none");
      });
    }
  }
  function _fnProcessingDisplay4(settings, show) {
    _fnCallbackFire4(settings, null, "processing", [settings, show]);
  }
  function _fnFeatureHtmlTable4(settings) {
    var table = $7(settings.nTable);
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses.scrolling;
    var caption = settings.captionNode;
    var captionSide = caption ? caption._captionSide : null;
    var headerClone = $7(table[0].cloneNode(false));
    var footerClone = $7(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size = function(s) {
      return !s ? null : _fnStringToCss4(s);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $7(_div, { "class": classes.container }).append(
      $7(_div, { "class": classes.header.self }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: scrollX ? size(scrollX) : "100%"
      }).append(
        $7(_div, { "class": classes.header.inner }).css({
          "box-sizing": "content-box",
          width: scroll.sXInner || "100%"
        }).append(
          headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
            table.children("thead")
          )
        )
      )
    ).append(
      $7(_div, { "class": classes.body }).css({
        position: "relative",
        overflow: "auto",
        width: size(scrollX)
      }).append(table)
    );
    if (footer) {
      scroller.append(
        $7(_div, { "class": classes.footer.self }).css({
          overflow: "hidden",
          border: 0,
          width: scrollX ? size(scrollX) : "100%"
        }).append(
          $7(_div, { "class": classes.footer.inner }).append(
            footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
              table.children("tfoot")
            )
          )
        )
      );
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    $7(scrollBody).on("scroll.DT", function() {
      var scrollLeft = this.scrollLeft;
      scrollHead.scrollLeft = scrollLeft;
      if (footer) {
        scrollFoot.scrollLeft = scrollLeft;
      }
    });
    $7("th, td", scrollHead).on("focus", function() {
      var scrollLeft = scrollHead.scrollLeft;
      scrollBody.scrollLeft = scrollLeft;
      if (footer) {
        scrollBody.scrollLeft = scrollLeft;
      }
    });
    $7(scrollBody).css("max-height", scrollY);
    if (!scroll.bCollapse) {
      $7(scrollBody).css("height", scrollY);
    }
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push(_fnScrollDraw4);
    return scroller[0];
  }
  function _fnScrollDraw4(settings) {
    var scroll = settings.oScroll, barWidth = scroll.iBarWidth, divHeader = $7(settings.nScrollHead), divHeaderInner = divHeader.children("div"), divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $7(divBodyEl), divFooter = $7(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $7(settings.nTHead), table = $7(settings.nTable), footer = settings.nTFoot && $7("th, td", settings.nTFoot).length ? $7(settings.nTFoot) : null, browser = settings.oBrowser, headerCopy, footerCopy;
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing4(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    headerCopy = header.clone().prependTo(table);
    headerCopy.find("th, td").removeAttr("tabindex");
    headerCopy.find("[id]").removeAttr("id");
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerCopy.find("[id]").removeAttr("id");
    }
    if (settings.aiDisplay.length) {
      var colSizes = table.find("tbody tr").eq(0).find("th, td").map(function(vis) {
        return {
          idx: _fnVisibleToColumnIndex4(settings, vis),
          width: $7(this).outerWidth()
        };
      });
      for (var i = 0; i < colSizes.length; i++) {
        var colEl = settings.aoColumns[colSizes[i].idx].colEl[0];
        var colWidth = colEl.style.width.replace("px", "");
        if (colWidth !== colSizes[i].width) {
          colEl.style.width = colSizes[i].width + "px";
        }
      }
    }
    divHeaderTable.find("colgroup").remove();
    divHeaderTable.append(settings.colgroup.clone());
    if (footer) {
      divFooterTable.find("colgroup").remove();
      divFooterTable.append(settings.colgroup.clone());
    }
    $7("th, td", headerCopy).each(function() {
      $7(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
    });
    if (footer) {
      $7("th, td", footerCopy).each(function() {
        $7(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
      });
    }
    var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var paddingSide = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    var outerWidth = table.outerWidth();
    divHeaderTable.css("width", _fnStringToCss4(outerWidth));
    divHeaderInner.css("width", _fnStringToCss4(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    if (footer) {
      divFooterTable.css("width", _fnStringToCss4(outerWidth));
      divFooterInner.css("width", _fnStringToCss4(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    }
    table.children("colgroup").prependTo(table);
    divBody.trigger("scroll");
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnCalculateColumnWidths4(settings) {
    if (!settings.oFeatures.bAutoWidth) {
      return;
    }
    var table = settings.nTable, columns = settings.aoColumns, scroll = settings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, visibleColumns = _fnGetColumns4(settings, "bVisible"), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, i, column, columnIdx;
    var styleWidth = table.style.width;
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    _fnCallbackFire4(
      settings,
      null,
      "column-calc",
      { visible: visibleColumns },
      false
    );
    var tmpTable = $7(table.cloneNode()).css("visibility", "hidden").removeAttr("id");
    tmpTable.append("<tbody>");
    var tr = $7("<tr/>").appendTo(tmpTable.find("tbody"));
    tmpTable.append($7(settings.nTHead).clone()).append($7(settings.nTFoot).clone());
    tmpTable.find("tfoot th, tfoot td").css("width", "");
    tmpTable.find("thead th, thead td").each(function() {
      var width = _fnColumnsSumWidth4(settings, this, true, false);
      if (width) {
        this.style.width = width;
        if (scrollX) {
          $7(this).append($7("<div/>").css({
            width,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } else {
        this.style.width = "";
      }
    });
    for (i = 0; i < visibleColumns.length; i++) {
      columnIdx = visibleColumns[i];
      column = columns[columnIdx];
      var longest = _fnGetMaxLenString4(settings, columnIdx);
      var autoClass = _ext4.type.className[column.sType];
      var text = longest + column.sContentPadding;
      var insert = longest.indexOf("<") === -1 ? document.createTextNode(text) : text;
      $7("<td/>").addClass(autoClass).addClass(column.sClass).append(insert).appendTo(tr);
    }
    $7("[name]", tmpTable).removeAttr("name");
    var holder = $7("<div/>").css(
      scrollX || scrollY ? {
        position: "absolute",
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: "hidden"
      } : {}
    ).append(tmpTable).appendTo(tableContainer);
    if (scrollX && scrollXInner) {
      tmpTable.width(scrollXInner);
    } else if (scrollX) {
      tmpTable.css("width", "auto");
      tmpTable.removeAttr("width");
      if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
        tmpTable.width(tableContainer.clientWidth);
      }
    } else if (scrollY) {
      tmpTable.width(tableContainer.clientWidth);
    } else if (tableWidthAttr) {
      tmpTable.width(tableWidthAttr);
    }
    var total = 0;
    var bodyCells = tmpTable.find("tbody tr").eq(0).children();
    for (i = 0; i < visibleColumns.length; i++) {
      var bounding = bodyCells[i].getBoundingClientRect().width;
      total += bounding;
      columns[visibleColumns[i]].sWidth = _fnStringToCss4(bounding);
    }
    table.style.width = _fnStringToCss4(total);
    holder.remove();
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss4(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !settings._reszEvt) {
      var bindResize = function() {
        $7(window).on("resize.DT-" + settings.sInstance, DataTable4.util.throttle(function() {
          if (!settings.bDestroying) {
            _fnAdjustColumnSizing4(settings);
          }
        }));
      };
      bindResize();
      settings._reszEvt = true;
    }
  }
  function _fnGetMaxLenString4(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    if (!column.maxLenString) {
      var s, max = "", maxLen = -1;
      for (var i = 0, ien = settings.aiDisplayMaster.length; i < ien; i++) {
        var rowIdx = settings.aiDisplayMaster[i];
        var data = _fnGetRowDisplay4(settings, rowIdx)[colIdx];
        var cellString = data && typeof data === "object" && data.nodeType ? data.innerHTML : data + "";
        cellString = cellString.replace(/id=".*?"/g, "").replace(/name=".*?"/g, "");
        s = _stripHtml4(cellString).replace(/&nbsp;/g, " ");
        if (s.length > maxLen) {
          max = cellString;
          maxLen = s.length;
        }
      }
      column.maxLenString = max;
    }
    return column.maxLenString;
  }
  function _fnStringToCss4(s) {
    if (s === null) {
      return "0px";
    }
    if (typeof s == "number") {
      return s < 0 ? "0px" : s + "px";
    }
    return s.match(/\d$/) ? s + "px" : s;
  }
  function _colGroup4(settings) {
    var cols = settings.aoColumns;
    settings.colgroup.empty();
    for (i = 0; i < cols.length; i++) {
      if (cols[i].bVisible) {
        settings.colgroup.append(cols[i].colEl);
      }
    }
  }
  function _fnSortInit4(settings) {
    var target = settings.nTHead;
    var headerRows = target.querySelectorAll("tr");
    var legacyTop = settings.bSortCellsTop;
    var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
    if (legacyTop === true) {
      target = headerRows[0];
    } else if (legacyTop === false) {
      target = headerRows[headerRows.length - 1];
    }
    _fnSortAttachListener4(
      settings,
      target,
      target === settings.nTHead ? "tr" + notSelector + " th" + notSelector + ", tr" + notSelector + " td" + notSelector : "th" + notSelector + ", td" + notSelector
    );
    var order = [];
    _fnSortResolve4(settings, order, settings.aaSorting);
    settings.aaSorting = order;
  }
  function _fnSortAttachListener4(settings, node, selector, column, callback) {
    _fnBindAction4(node, selector, function(e) {
      var run = false;
      var columns = column === void 0 ? _fnColumnsFromHeader4(e.target) : [column];
      if (columns.length) {
        for (var i = 0, ien = columns.length; i < ien; i++) {
          var ret = _fnSortAdd4(settings, columns[i], i, e.shiftKey);
          if (ret !== false) {
            run = true;
          }
          if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === "") {
            break;
          }
        }
        if (run) {
          _fnProcessingDisplay4(settings, true);
          setTimeout(function() {
            _fnSort4(settings);
            _fnSortDisplay4(settings, settings.aiDisplay);
            _fnProcessingDisplay4(settings, false);
            _fnReDraw4(settings, false, false);
            if (callback) {
              callback();
            }
          }, 0);
        }
      }
    });
  }
  function _fnSortDisplay4(settings, display) {
    var master = settings.aiDisplayMaster;
    var masterMap = {};
    var map2 = {};
    var i;
    for (i = 0; i < master.length; i++) {
      masterMap[master[i]] = i;
    }
    for (i = 0; i < display.length; i++) {
      map2[display[i]] = masterMap[display[i]];
    }
    display.sort(function(a, b) {
      return map2[a] - map2[b];
    });
  }
  function _fnSortResolve4(settings, nestedSort, sort) {
    var push = function(a) {
      if ($7.isPlainObject(a)) {
        if (a.idx !== void 0) {
          nestedSort.push([a.idx, a.dir]);
        } else if (a.name) {
          var cols = _pluck4(settings.aoColumns, "sName");
          var idx = cols.indexOf(a.name);
          if (idx !== -1) {
            nestedSort.push([idx, a.dir]);
          }
        }
      } else {
        nestedSort.push(a);
      }
    };
    if ($7.isPlainObject(sort)) {
      push(sort);
    } else if (sort.length && typeof sort[0] === "number") {
      push(sort);
    } else if (sort.length) {
      for (var z = 0; z < sort.length; z++) {
        push(sort[z]);
      }
    }
  }
  function _fnSortFlatten4(settings) {
    var i, k, kLen, aSort = [], extSort = DataTable4.ext.type.order, aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $7.isPlainObject(fixed), nestedSort = [];
    if (!settings.oFeatures.bSort) {
      return aSort;
    }
    if (Array.isArray(fixed)) {
      _fnSortResolve4(settings, nestedSort, fixed);
    }
    if (fixedObj && fixed.pre) {
      _fnSortResolve4(settings, nestedSort, fixed.pre);
    }
    _fnSortResolve4(settings, nestedSort, settings.aaSorting);
    if (fixedObj && fixed.post) {
      _fnSortResolve4(settings, nestedSort, fixed.post);
    }
    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      if (aoColumns[srcCol]) {
        aDataSort = aoColumns[srcCol].aDataSort;
        for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
          iCol = aDataSort[k];
          sType = aoColumns[iCol].sType || "string";
          if (nestedSort[i]._idx === void 0) {
            nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
          }
          if (nestedSort[i][1]) {
            aSort.push({
              src: srcCol,
              col: iCol,
              dir: nestedSort[i][1],
              index: nestedSort[i]._idx,
              type: sType,
              formatter: extSort[sType + "-pre"],
              sorter: extSort[sType + "-" + nestedSort[i][1]]
            });
          }
        }
      }
    }
    return aSort;
  }
  function _fnSort4(oSettings, col, dir) {
    var i, ien, iLen, aiOrig = [], extSort = DataTable4.ext.type.order, aoData = oSettings.aoData, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    _fnColumnTypes4(oSettings);
    if (col !== void 0) {
      var srcCol = oSettings.aoColumns[col];
      aSort = [{
        src: col,
        col,
        dir,
        index: 0,
        type: srcCol.sType,
        formatter: extSort[srcCol.sType + "-pre"],
        sorter: extSort[srcCol.sType + "-" + dir]
      }];
      displayMaster = displayMaster.slice();
    } else {
      aSort = _fnSortFlatten4(oSettings);
    }
    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i];
      _fnSortData4(oSettings, sortCol.col);
    }
    if (_fnDataSource4(oSettings) != "ssp" && aSort.length !== 0) {
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[i] = i;
      }
      if (aSort.length && aSort[0].dir === "desc") {
        aiOrig.reverse();
      }
      displayMaster.sort(function(a, b) {
        var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
        for (k = 0; k < len; k++) {
          sort = aSort[k];
          x = dataA[sort.col];
          y = dataB[sort.col];
          if (sort.sorter) {
            test = sort.sorter(x, y);
            if (test !== 0) {
              return test;
            }
          } else {
            test = x < y ? -1 : x > y ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
        }
        x = aiOrig[a];
        y = aiOrig[b];
        return x < y ? -1 : x > y ? 1 : 0;
      });
    } else if (aSort.length === 0) {
      displayMaster.sort(function(x, y) {
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    if (col === void 0) {
      oSettings.bSorted = true;
      _fnCallbackFire4(oSettings, null, "order", [oSettings, aSort]);
    }
    return displayMaster;
  }
  function _fnSortAdd4(settings, colIdx, addIndex, shift) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a, overflow) {
      var idx = a._idx;
      if (idx === void 0) {
        idx = asSorting.indexOf(a[1]);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (!col.bSortable) {
      return false;
    }
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if ((shift || addIndex) && settings.oFeatures.bSortMulti) {
      var sortIdx = _pluck4(sorting, "0").indexOf(colIdx);
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else if (shift) {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      } else {
        sorting.push([colIdx, sorting[0][1], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    }
  }
  function _fnSortingClasses4(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.order.position;
    var sort = _fnSortFlatten4(settings);
    var features = settings.oFeatures;
    var i, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src;
        $7(_pluck4(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      }
      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $7(_pluck4(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData4(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    var customSort = DataTable4.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(
        settings.oInstance,
        settings,
        colIdx,
        _fnColumnIndexToVisible4(settings, colIdx)
      );
    }
    var row, cellData;
    var formatter = DataTable4.ext.type.order[column.sType + "-pre"];
    var data = settings.aoData;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[colIdx] || customSort) {
        cellData = customSort ? customData[rowIdx] : (
          // If there was a custom sort function, use data from there
          _fnGetCellData4(settings, rowIdx, colIdx, "sort")
        );
        row._aSortData[colIdx] = formatter ? formatter(cellData, settings) : cellData;
      }
    }
  }
  function _fnSaveState4(settings) {
    if (settings._bLoadingState) {
      return;
    }
    var state = {
      time: +/* @__PURE__ */ new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $7.extend(true, [], settings.aaSorting),
      search: $7.extend({}, settings.oPreviousSearch),
      columns: settings.aoColumns.map(function(col, i) {
        return {
          visible: col.bVisible,
          search: $7.extend({}, settings.aoPreSearchCols[i])
        };
      })
    };
    settings.oSavedState = state;
    _fnCallbackFire4(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
  }
  function _fnLoadState4(settings, init2, callback) {
    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }
    var loaded = function(state2) {
      _fnImplementState4(settings, state2, callback);
    };
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
    if (state !== void 0) {
      _fnImplementState4(settings, state, callback);
    }
    return true;
  }
  function _fnImplementState4(settings, s, callback) {
    var i, ien;
    var columns = settings.aoColumns;
    settings._bLoadingState = true;
    var api = settings._bInitComplete ? new DataTable4.Api(settings) : null;
    if (!s || !s.time) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && s.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var abStateLoad = _fnCallbackFire4(settings, "aoStateLoadParams", "stateLoadParams", [settings, s]);
    if (abStateLoad.indexOf(false) !== -1) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    if (s.columns && columns.length !== s.columns.length) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    settings.oLoadedState = $7.extend(true, {}, s);
    _fnCallbackFire4(settings, null, "stateLoadInit", [settings, s], true);
    if (s.length !== void 0) {
      if (api) {
        api.page.len(s.length);
      } else {
        settings._iDisplayLength = s.length;
      }
    }
    if (s.start !== void 0) {
      if (api === null) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      } else {
        _fnPageChange4(settings, s.start / settings._iDisplayLength);
      }
    }
    if (s.order !== void 0) {
      settings.aaSorting = [];
      $7.each(s.order, function(i2, col2) {
        settings.aaSorting.push(
          col2[0] >= columns.length ? [0, col2[1]] : col2
        );
      });
    }
    if (s.search !== void 0) {
      $7.extend(settings.oPreviousSearch, s.search);
    }
    if (s.columns) {
      for (i = 0, ien = s.columns.length; i < ien; i++) {
        var col = s.columns[i];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i).visible(col.visible, false);
          } else {
            columns[i].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $7.extend(settings.aoPreSearchCols[i], col.search);
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
    settings._bLoadingState = false;
    _fnCallbackFire4(settings, "aoStateLoaded", "stateLoaded", [settings, s]);
    callback();
  }
  function _fnLog4(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable4.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire4(settings, null, "dt-error", [settings, tn, msg], true);
      }
      if (type == "alert") {
        alert(msg);
      } else if (type == "throw") {
        throw new Error(msg);
      } else if (typeof type == "function") {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  function _fnMap4(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $7.each(name, function(i, val) {
        if (Array.isArray(val)) {
          _fnMap4(ret, src, val[0], val[1]);
        } else {
          _fnMap4(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === void 0) {
      mappedName = name;
    }
    if (src[name] !== void 0) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend4(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, prop)) {
        val = extender[prop];
        if ($7.isPlainObject(val)) {
          if (!$7.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $7.extend(true, out[prop], val);
        } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }
    return out;
  }
  function _fnBindAction4(n, selector, fn) {
    $7(n).on("click.DT", selector, function(e) {
      fn(e);
    }).on("keypress.DT", selector, function(e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on("selectstart.DT", selector, function() {
      return false;
    });
  }
  function _fnCallbackReg4(settings, store, fn) {
    if (fn) {
      settings[store].push(fn);
    }
  }
  function _fnCallbackFire4(settings, callbackArr, eventName, args, bubbles) {
    var ret = [];
    if (callbackArr) {
      ret = settings[callbackArr].slice().reverse().map(function(val) {
        return val.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e = $7.Event(eventName + ".dt");
      var table = $7(settings.nTable);
      e.dt = settings.api;
      table[bubbles ? "trigger" : "triggerHandler"](e, args);
      if (bubbles && table.parents("body").length === 0) {
        $7("body").trigger(e, args);
      }
      ret.push(e.result);
    }
    return ret;
  }
  function _fnLengthOverflow4(settings) {
    var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start >= end) {
      start = end - len;
    }
    start -= start % len;
    if (len === -1 || start < 0) {
      start = 0;
    }
    settings._iDisplayStart = start;
  }
  function _fnRenderer4(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable4.ext.renderer[type];
    if ($7.isPlainObject(renderer) && renderer[type]) {
      return host[renderer[type]] || host._;
    } else if (typeof renderer === "string") {
      return host[renderer] || host._;
    }
    return host._;
  }
  function _fnDataSource4(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else if (settings.ajax) {
      return "ajax";
    }
    return "dom";
  }
  function _fnMacros4(settings, str, entries) {
    var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), max = settings.fnRecordsTotal(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, max)).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len))).replace(/_ENTRIES_/g, settings.api.i18n("entries", "", entries)).replace(/_ENTRIES-MAX_/g, settings.api.i18n("entries", "", max)).replace(/_ENTRIES-TOTAL_/g, settings.api.i18n("entries", "", vis));
  }
  var __apiStruct4 = [];
  var __arrayProto4 = Array.prototype;
  var _toSettings4 = function(mixed) {
    var idx, jq;
    var settings = DataTable4.settings;
    var tables = _pluck4(settings, "nTable");
    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oFeatures) {
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
      idx = tables.indexOf(mixed);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === "function") {
      return mixed.settings().toArray();
    } else if (typeof mixed === "string") {
      jq = $7(mixed).get();
    } else if (mixed instanceof $7) {
      jq = mixed.get();
    }
    if (jq) {
      return settings.filter(function(v, idx2) {
        return jq.includes(tables[idx2]);
      });
    }
  };
  _Api4 = function(context, data) {
    if (!(this instanceof _Api4)) {
      return new _Api4(context, data);
    }
    var settings = [];
    var ctxSettings = function(o) {
      var a = _toSettings4(o);
      if (a) {
        settings.push.apply(settings, a);
      }
    };
    if (Array.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = settings.length > 1 ? _unique4(settings) : settings;
    if (data) {
      this.push.apply(this, data);
    }
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
    _Api4.extend(this, this, __apiStruct4);
  };
  DataTable4.Api = _Api4;
  $7.extend(_Api4.prototype, {
    any: function() {
      return this.count() !== 0;
    },
    context: [],
    // array of table settings objects
    count: function() {
      return this.flatten().length;
    },
    each: function(fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }
      return this;
    },
    eq: function(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api4(ctx[idx], this[idx]) : null;
    },
    filter: function(fn) {
      var a = __arrayProto4.filter.call(this, fn, this);
      return new _Api4(this.context, a);
    },
    flatten: function() {
      var a = [];
      return new _Api4(this.context, a.concat.apply(a, this.toArray()));
    },
    get: function(idx) {
      return this[idx];
    },
    join: __arrayProto4.join,
    includes: function(find) {
      return this.indexOf(find) === -1 ? false : true;
    },
    indexOf: __arrayProto4.indexOf,
    iterator: function(flatten, type, fn, alwaysNew) {
      var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
      if (typeof flatten === "string") {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }
      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api4(context[i]);
        if (type === "table") {
          ret = fn.call(apiInst, context[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "columns" || type === "rows") {
          ret = fn.call(apiInst, context[i], this[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "every" || type === "column" || type === "column-rows" || type === "row" || type === "cell") {
          items = this[i];
          if (type === "column-rows") {
            rows = _selector_row_indexes4(context[i], selector.opts);
          }
          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];
            if (type === "cell") {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }
            if (ret !== void 0) {
              a.push(ret);
            }
          }
        }
      }
      if (a.length || alwaysNew) {
        var api = new _Api4(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
    lastIndexOf: __arrayProto4.lastIndexOf,
    length: 0,
    map: function(fn) {
      var a = __arrayProto4.map.call(this, fn, this);
      return new _Api4(this.context, a);
    },
    pluck: function(prop) {
      var fn = DataTable4.util.get(prop);
      return this.map(function(el) {
        return fn(el);
      });
    },
    pop: __arrayProto4.pop,
    push: __arrayProto4.push,
    reduce: __arrayProto4.reduce,
    reduceRight: __arrayProto4.reduceRight,
    reverse: __arrayProto4.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto4.shift,
    slice: function() {
      return new _Api4(this.context, this);
    },
    sort: __arrayProto4.sort,
    splice: __arrayProto4.splice,
    toArray: function() {
      return __arrayProto4.slice.call(this);
    },
    to$: function() {
      return $7(this);
    },
    toJQuery: function() {
      return $7(this);
    },
    unique: function() {
      return new _Api4(this.context, _unique4(this.toArray()));
    },
    unshift: __arrayProto4.unshift
  });
  function _api_scope4(scope, fn, struc) {
    return function() {
      var ret = fn.apply(scope || this, arguments);
      _Api4.extend(ret, ret, struc.methodExt);
      return ret;
    };
  }
  function _api_find4(src, name) {
    for (var i = 0, ien = src.length; i < ien; i++) {
      if (src[i].name === name) {
        return src[i];
      }
    }
    return null;
  }
  window.__apiStruct = __apiStruct4;
  _Api4.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api4) && !obj.__dt_wrapper) {
      return;
    }
    var i, ien, struct;
    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i];
      if (struct.name === "__proto__") {
        continue;
      }
      obj[struct.name] = struct.type === "function" ? _api_scope4(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api4.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api4.register = _api_register4 = function(name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api4.register(name[j], val);
      }
      return;
    }
    var i, ien, heir = name.split("."), struct = __apiStruct4, key, method;
    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf("()") !== -1;
      key = method ? heir[i].replace("()", "") : heir[i];
      var src = _api_find4(struct, key);
      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: "object"
        };
        struct.push(src);
      }
      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === "function" ? "function" : $7.isPlainObject(val) ? "object" : "other";
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api4.registerPlural = _api_registerPlural4 = function(pluralName, singularName, val) {
    _Api4.register(pluralName, val);
    _Api4.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else if (ret instanceof _Api4) {
        return ret.length ? Array.isArray(ret[0]) ? new _Api4(ret.context, ret[0]) : (
          // Array results are 'enhanced'
          ret[0]
        ) : void 0;
      }
      return ret;
    });
  };
  var __table_selector4 = function(selector, a) {
    if (Array.isArray(selector)) {
      var result = [];
      selector.forEach(function(sel) {
        var inner = __table_selector4(sel, a);
        result.push.apply(result, inner);
      });
      return result.filter(function(item) {
        return item;
      });
    }
    if (typeof selector === "number") {
      return [a[selector]];
    }
    var nodes = a.map(function(el) {
      return el.nTable;
    });
    return $7(nodes).filter(selector).map(function() {
      var idx = nodes.indexOf(this);
      return a[idx];
    }).toArray();
  };
  _api_register4("tables()", function(selector) {
    return selector !== void 0 && selector !== null ? new _Api4(__table_selector4(selector, this.context)) : this;
  });
  _api_register4("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api4(ctx[0]) : tables;
  });
  [
    ["nodes", "node", "nTable"],
    ["body", "body", "nTBody"],
    ["header", "header", "nTHead"],
    ["footer", "footer", "nTFoot"]
  ].forEach(function(item) {
    _api_registerPlural4(
      "tables()." + item[0] + "()",
      "table()." + item[1] + "()",
      function() {
        return this.iterator("table", function(ctx) {
          return ctx[item[2]];
        }, 1);
      }
    );
  });
  [
    ["header", "aoHeader"],
    ["footer", "aoFooter"]
  ].forEach(function(item) {
    _api_register4("table()." + item[0] + ".structure()", function(selector) {
      var indexes = this.columns(selector).indexes().flatten();
      var ctx = this.context[0];
      return _fnHeaderLayout4(ctx, ctx[item[1]], indexes);
    });
  });
  _api_registerPlural4("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register4("tables().every()", function(fn) {
    var that = this;
    return this.iterator("table", function(s, i) {
      fn.call(that.table(i), i);
    });
  });
  _api_register4("caption()", function(value, side) {
    var context = this.context;
    if (value === void 0) {
      var caption = context[0].captionNode;
      return caption && context.length ? caption.innerHTML : null;
    }
    return this.iterator("table", function(ctx) {
      var table = $7(ctx.nTable);
      var caption2 = $7(ctx.captionNode);
      var container = $7(ctx.nTableWrapper);
      if (!caption2.length) {
        caption2 = $7("<caption/>").html(value);
        ctx.captionNode = caption2[0];
        if (!side) {
          table.prepend(caption2);
          side = caption2.css("caption-side");
        }
      }
      caption2.html(value);
      if (side) {
        caption2.css("caption-side", side);
        caption2[0]._captionSide = side;
      }
      if (container.find("div.dataTables_scroll").length) {
        var selector = side === "top" ? "Head" : "Foot";
        container.find("div.dataTables_scroll" + selector + " table").prepend(caption2);
      } else {
        table.prepend(caption2);
      }
    }, 1);
  });
  _api_register4("caption.node()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].captionNode : null;
  });
  _api_register4("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw4(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw4(settings, paging === false);
      }
    });
  });
  _api_register4("page()", function(action) {
    if (action === void 0) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange4(settings, action);
    });
  });
  _api_register4("page.info()", function() {
    if (this.context.length === 0) {
      return void 0;
    }
    var settings = this.context[0], start = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource4(settings) === "ssp"
    };
  });
  _api_register4("page.len()", function(len) {
    if (len === void 0) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange4(settings, len);
    });
  });
  var __reload4 = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api4(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource4(settings) == "ssp") {
      _fnReDraw4(settings, holdPosition);
    } else {
      _fnProcessingDisplay4(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax4(settings, {}, function(json) {
        _fnClearTable4(settings);
        var data = _fnAjaxDataSrc4(settings, json);
        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData4(settings, data[i]);
        }
        _fnReDraw4(settings, holdPosition);
        _fnInitComplete4(settings);
        _fnProcessingDisplay4(settings, false);
      });
    }
  };
  _api_register4("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register4("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register4("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload4(settings, resetPaging === false, callback);
    });
  });
  _api_register4("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === void 0) {
      if (ctx.length === 0) {
        return void 0;
      }
      ctx = ctx[0];
      return $7.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax;
    }
    return this.iterator("table", function(settings) {
      if ($7.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register4("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload4(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run4 = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
      selector = [selector];
    }
    for (i = 0, ien = selector.length; i < ien; i++) {
      a = selector[i] && selector[i].split && !selector[i].match(/[[(:]/) ? selector[i].split(",") : [selector[i]];
      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === "string" ? a[j].trim() : a[j]);
        res = res.filter(function(item) {
          return item !== null && item !== void 0;
        });
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext4.selector[type];
    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }
    return _unique4(out);
  };
  var _selector_opts4 = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === void 0) {
      opts.search = opts.filter;
    }
    return $7.extend({
      search: "none",
      order: "current",
      page: "all"
    }, opts);
  };
  var _selector_first4 = function(old) {
    let inst = new _Api4(old.context[0]);
    if (old.length) {
      inst.push(old[0]);
    }
    inst.selector = old.selector;
    if (inst.length && inst[0].length > 1) {
      inst[0].splice(1);
    }
    return inst;
  };
  var _selector_row_indexes4 = function(settings, opts) {
    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order = opts.order, page = opts.page;
    if (page == "current") {
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == "current" || order == "applied") {
      if (search == "none") {
        a = displayMaster.slice();
      } else if (search == "applied") {
        a = displayFiltered.slice();
      } else if (search == "removed") {
        var displayFilteredMap = {};
        for (i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }
        displayMaster.forEach(function(item) {
          if (!Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
            a.push(item);
          }
        });
      }
    } else if (order == "index" || order == "original") {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (!settings.aoData[i]) {
          continue;
        }
        if (search == "none") {
          a.push(i);
        } else {
          tmp = displayFiltered.indexOf(i);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(i);
          }
        }
      }
    } else if (typeof order === "number") {
      var ordered = _fnSort4(settings, order, "asc");
      if (search === "none") {
        a = ordered;
      } else {
        for (i = 0; i < ordered.length; i++) {
          tmp = displayFiltered.indexOf(ordered[i]);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(ordered[i]);
          }
        }
      }
    }
    return a;
  };
  var __row_selector4 = function(settings, selector, opts) {
    var rows;
    var run = function(sel) {
      var selInt = _intVal4(sel);
      var aoData = settings.aoData;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      if (!rows) {
        rows = _selector_row_indexes4(settings, opts);
      }
      if (selInt !== null && rows.indexOf(selInt) !== -1) {
        return [selInt];
      } else if (sel === null || sel === void 0 || sel === "") {
        return rows;
      }
      if (typeof sel === "function") {
        return rows.map(function(idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex;
        var cellIdx = sel._DT_CellIndex;
        if (rowIdx !== void 0) {
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $7(sel).closest("*[data-dt-row]");
          return host.length ? [host.data("dt-row")] : [];
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== void 0) {
          return [rowObj.idx];
        }
      }
      var nodes = _removeEmpty4(
        _pluck_order4(settings.aoData, rows, "nTr")
      );
      return $7(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    var matched = _selector_run4("row", selector, run, settings, opts);
    if (opts.order === "current" || opts.order === "applied") {
      _fnSortDisplay4(settings, matched);
    }
    return matched;
  };
  _api_register4("rows()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($7.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts4(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector4(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register4("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || void 0;
    }, 1);
  });
  _api_register4("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order4(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural4("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r = settings.aoData[row];
      return type === "search" ? r._aFilterData : r._aSortData;
    }, 1);
  });
  _api_registerPlural4("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate4(settings, row, src);
    });
  });
  _api_registerPlural4("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural4("rows().ids()", "row().id()", function(hash) {
    var a = [];
    var context = this.context;
    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? "#" : "") + id);
      }
    }
    return new _Api4(context, a);
  });
  _api_registerPlural4("rows().remove()", "row().remove()", function() {
    this.iterator("row", function(settings, row) {
      var data = settings.aoData;
      var rowData = data[row];
      var idx = settings.aiDisplayMaster.indexOf(row);
      if (idx !== -1) {
        settings.aiDisplayMaster.splice(idx, 1);
      }
      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      }
      _fnLengthOverflow4(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== void 0) {
        delete settings.aIds[id];
      }
      data[row] = null;
    });
    return this;
  });
  _api_register4("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i, ien;
      var out = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr4(settings, row)[0]);
        } else {
          out.push(_fnAddData4(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    modRows.push.apply(modRows, newRows);
    return modRows;
  });
  _api_register4("row()", function(selector, opts) {
    return _selector_first4(this.rows(selector, opts));
  });
  _api_register4("row().data()", function(data) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]]._aData : void 0;
    }
    var row = ctx[0].aoData[this[0]];
    row._aData = data;
    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn4(ctx[0].rowId)(data, row.nTr.id);
    }
    _fnInvalidate4(ctx[0], this[0], "data");
    return this;
  });
  _api_register4("row().node()", function() {
    var ctx = this.context;
    return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]].nTr || null : null;
  });
  _api_register4("row.add()", function(row) {
    if (row instanceof $7 && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr4(settings, row)[0];
      }
      return _fnAddData4(settings, row);
    });
    return this.row(rows[0]);
  });
  $7(document).on("plugin-init.dt", function(e, context) {
    var api = new _Api4(context);
    api.on("stateSaveParams.DT", function(e2, settings, d) {
      var idFn = settings.rowIdFn;
      var rows = settings.aiDisplayMaster;
      var ids = [];
      for (var i = 0; i < rows.length; i++) {
        var rowIdx = rows[i];
        var data = settings.aoData[rowIdx];
        if (data._detailsShow) {
          ids.push("#" + idFn(data._aData));
        }
      }
      d.childRows = ids;
    });
    api.on("stateLoaded.DT", function(e2, settings, state) {
      __details_state_load4(api, state);
    });
    __details_state_load4(api, api.state.loaded());
  });
  var __details_state_load4 = function(api, state) {
    if (state && state.childRows) {
      api.rows(state.childRows.map(function(id) {
        return id.replace(/(?<!\\):/g, "\\:");
      })).every(function() {
        _fnCallbackFire4(api.settings()[0], null, "requestChild", [this]);
      });
    }
  };
  var __details_add4 = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r, k) {
      if (Array.isArray(r) || r instanceof $7) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }
        return;
      }
      if (r.nodeName && r.nodeName.toLowerCase() === "tr") {
        r.setAttribute("data-dt-row", row.idx);
        rows.push(r);
      } else {
        var created = $7("<tr><td></td></tr>").attr("data-dt-row", row.idx).addClass(k);
        $7("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns4(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.detach();
    }
    row._details = $7(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_state4 = DataTable4.util.throttle(
    function(ctx) {
      _fnSaveState4(ctx[0]);
    },
    500
  );
  var __details_remove4 = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = void 0;
        row._details = void 0;
        $7(row.nTr).removeClass("dt-hasChild");
        __details_state4(ctx);
      }
    }
  };
  var __details_display4 = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
          $7(row.nTr).addClass("dt-hasChild");
        } else {
          row._details.detach();
          $7(row.nTr).removeClass("dt-hasChild");
        }
        _fnCallbackFire4(ctx[0], null, "childRow", [show, api.row(api[0])]);
        __details_events4(ctx[0]);
        __details_state4(ctx);
      }
    }
  };
  var __details_events4 = function(settings) {
    var api = new _Api4(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-sizing" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck4(data, "_details").length > 0) {
      api.on(drawEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({ page: "current" }).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns4(ctx);
        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];
          if (row && row._details) {
            row._details.each(function() {
              var el = $7(this).children("td");
              if (el.length == 1) {
                el.attr("colspan", visible);
              }
            });
          }
        }
      });
      api.on(destroyEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i] && data[i]._details) {
            __details_remove4(api, i);
          }
        }
      });
    }
  };
  var _emp4 = "";
  var _child_obj4 = _emp4 + "row().child";
  var _child_mth4 = _child_obj4 + "()";
  _api_register4(_child_mth4, function(data, klass) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && ctx[0].aoData[this[0]] ? ctx[0].aoData[this[0]]._details : void 0;
    } else if (data === true) {
      this.child.show();
    } else if (data === false) {
      __details_remove4(this);
    } else if (ctx.length && this.length) {
      __details_add4(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }
    return this;
  });
  _api_register4([
    _child_obj4 + ".show()",
    _child_mth4 + ".show()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display4(this, true);
    return this;
  });
  _api_register4([
    _child_obj4 + ".hide()",
    _child_mth4 + ".hide()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display4(this, false);
    return this;
  });
  _api_register4([
    _child_obj4 + ".remove()",
    _child_mth4 + ".remove()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_remove4(this);
    return this;
  });
  _api_register4(_child_obj4 + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector4 = /^([^:]+):(name|title|visIdx|visible)$/;
  var __columnData4 = function(settings, column, r1, r2, rows, type) {
    var a = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData4(settings, rows[row], column, type));
    }
    return a;
  };
  var __column_header4 = function(settings, column, row) {
    var header = settings.aoHeader;
    var target = row !== void 0 ? row : settings.bSortCellsTop ? 0 : header.length - 1;
    return header[target][column].cell;
  };
  var __column_selector4 = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck4(columns, "sName"), titles = _pluck4(columns, "sTitle"), cells = DataTable4.util.get("[].[].cell")(settings.aoHeader), nodes = _unique4(_flatten4([], cells));
    var run = function(s) {
      var selInt = _intVal4(s);
      if (s === "") {
        return _range4(columns.length);
      }
      if (selInt !== null) {
        return [
          selInt >= 0 ? selInt : (
            // Count from left
            columns.length + selInt
          )
          // Count from right (+ because its a negative value)
        ];
      }
      if (typeof s === "function") {
        var rows = _selector_row_indexes4(settings, opts);
        return columns.map(function(col, idx2) {
          return s(
            idx2,
            __columnData4(settings, idx2, 0, 0, rows),
            __column_header4(settings, idx2)
          ) ? idx2 : null;
        });
      }
      var match = typeof s === "string" ? s.match(__re_column_selector4) : "";
      if (match) {
        switch (match[2]) {
          case "visIdx":
          case "visible":
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = columns.map(function(col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex4(settings, idx)];
          case "name":
            return names.map(function(name, i) {
              return name === match[1] ? i : null;
            });
          case "title":
            return titles.map(function(title, i) {
              return title === match[1] ? i : null;
            });
          default:
            return [];
        }
      }
      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      }
      var jqResult = $7(nodes).filter(s).map(function() {
        return _fnColumnsFromHeader4(this);
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      var host = $7(s).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run4("column", selector, run, settings, opts);
  };
  var __setColumnVis4 = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, cells, i, ien, tr;
    if (vis === void 0) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return false;
    }
    if (vis) {
      var insertBefore = _pluck4(cols, "bVisible").indexOf(true, column + 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        if (data[i]) {
          tr = data[i].nTr;
          cells = data[i].anCells;
          if (tr) {
            tr.insertBefore(cells[column], cells[insertBefore] || null);
          }
        }
      }
    } else {
      $7(_pluck4(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
    _colGroup4(settings);
    return true;
  };
  _api_register4("columns()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($7.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts4(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector4(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural4("columns().header()", "column().header()", function(row) {
    return this.iterator("column", function(settings, column) {
      return __column_header4(settings, column, row);
    }, 1);
  });
  _api_registerPlural4("columns().footer()", "column().footer()", function(row) {
    return this.iterator("column", function(settings, column) {
      var footer = settings.aoFooter;
      if (!footer.length) {
        return null;
      }
      return settings.aoFooter[row !== void 0 ? row : 0][column].cell;
    }, 1);
  });
  _api_registerPlural4("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData4, 1);
  });
  _api_registerPlural4("columns().render()", "column().render()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return __columnData4(settings, column, i, j, rows, type);
    }, 1);
  });
  _api_registerPlural4("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural4("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order4(
        settings.aoData,
        rows,
        type === "search" ? "_aFilterData" : "_aSortData",
        column
      );
    }, 1);
  });
  _api_registerPlural4("columns().init()", "column().init()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column];
    }, 1);
  });
  _api_registerPlural4("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order4(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural4("columns().titles()", "column().title()", function(title, row) {
    return this.iterator("column", function(settings, column) {
      if (typeof title === "number") {
        row = title;
        title = void 0;
      }
      var span = $7("span.dt-column-title", this.column(column).header(row));
      if (title !== void 0) {
        span.html(title);
        return this;
      }
      return span.html();
    }, 1);
  });
  _api_registerPlural4("columns().types()", "column().type()", function() {
    return this.iterator("column", function(settings, column) {
      var type = settings.aoColumns[column].sType;
      if (!type) {
        _fnColumnTypes4(settings);
      }
      return type;
    }, 1);
  });
  _api_registerPlural4("columns().visible()", "column().visible()", function(vis, calc) {
    var that = this;
    var changed = [];
    var ret = this.iterator("column", function(settings, column) {
      if (vis === void 0) {
        return settings.aoColumns[column].bVisible;
      }
      if (__setColumnVis4(settings, column, vis)) {
        changed.push(column);
      }
    });
    if (vis !== void 0) {
      this.iterator("table", function(settings) {
        _fnDrawHead4(settings, settings.aoHeader);
        _fnDrawHead4(settings, settings.aoFooter);
        if (!settings.aiDisplay.length) {
          $7(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns4(settings));
        }
        _fnSaveState4(settings);
        that.iterator("column", function(settings2, column) {
          if (changed.includes(column)) {
            _fnCallbackFire4(settings2, null, "column-visibility", [settings2, column, vis, calc]);
          }
        });
        if (changed.length && (calc === void 0 || calc)) {
          that.columns.adjust();
        }
      });
    }
    return ret;
  });
  _api_registerPlural4("columns().widths()", "column().width()", function() {
    var columns = this.columns(":visible").count();
    var row = $7("<tr>").html("<td>" + Array(columns).join("</td><td>") + "</td>");
    $7(this.table().body()).append(row);
    var widths = row.children().map(function() {
      return $7(this).outerWidth();
    });
    row.remove();
    return this.iterator("column", function(settings, column) {
      var visIdx = _fnColumnIndexToVisible4(settings, column);
      return visIdx !== null ? widths[visIdx] : 0;
    }, 1);
  });
  _api_registerPlural4("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible4(settings, column) : column;
    }, 1);
  });
  _api_register4("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing4(settings);
    }, 1);
  });
  _api_register4("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex4(ctx, idx);
      } else if (type === "fromData" || type === "toVisible") {
        return _fnColumnIndexToVisible4(ctx, idx);
      }
    }
  });
  _api_register4("column()", function(selector, opts) {
    return _selector_first4(this.columns(selector, opts));
  });
  var __cell_selector4 = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes4(settings, opts);
    var cells = _removeEmpty4(_pluck_order4(data, rows, "anCells"));
    var allCells = $7(_flatten4([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;
    var run = function(s) {
      var fnSelector = typeof s === "function";
      if (s === null || s === void 0 || fnSelector) {
        a = [];
        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];
          for (j = 0; j < columns; j++) {
            o = {
              row,
              column: j
            };
            if (fnSelector) {
              host = data[row];
              if (s(o, _fnGetCellData4(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              a.push(o);
            }
          }
        }
        return a;
      }
      if ($7.isPlainObject(s)) {
        return s.column !== void 0 && s.row !== void 0 && rows.indexOf(s.row) !== -1 ? [s] : [];
      }
      var jqResult = allCells.filter(s).map(function(i2, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      host = $7(s).closest("*[data-dt-row]");
      return host.length ? [{
        row: host.data("dt-row"),
        column: host.data("dt-column")
      }] : [];
    };
    return _selector_run4("cell", selector, run, settings, opts);
  };
  _api_register4("cells()", function(rowSelector, columnSelector, opts) {
    if ($7.isPlainObject(rowSelector)) {
      if (rowSelector.row === void 0) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($7.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === void 0) {
      return this.iterator("table", function(settings) {
        return __cell_selector4(settings, rowSelector, _selector_opts4(opts));
      });
    }
    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {};
    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator("table", function(settings, idx) {
      var a = [];
      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }
      return a;
    }, 1);
    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $7.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts
    });
    return cells;
  });
  _api_registerPlural4("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : void 0;
    }, 1);
  });
  _api_register4("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData4(settings, row, column);
    }, 1);
  });
  _api_registerPlural4("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural4("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData4(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural4("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {
        row,
        column,
        columnVisible: _fnColumnIndexToVisible4(settings, column)
      };
    }, 1);
  });
  _api_registerPlural4("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate4(settings, row, src, column);
    });
  });
  _api_register4("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first4(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register4("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === void 0) {
      return ctx.length && cell.length ? _fnGetCellData4(ctx[0], cell[0].row, cell[0].column) : void 0;
    }
    _fnSetCellData4(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate4(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register4("order()", function(order, dir) {
    var ctx = this.context;
    var args = Array.prototype.slice.call(arguments);
    if (order === void 0) {
      return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
    }
    if (typeof order === "number") {
      order = [[order, dir]];
    } else if (args.length > 1) {
      order = args;
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = Array.isArray(order) ? order.slice() : order;
    });
  });
  _api_register4("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener4(settings, node, {}, column, callback);
    });
  });
  _api_register4("order.fixed()", function(set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
      return Array.isArray(fixed) ? { pre: fixed } : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $7.extend(true, {}, set);
    });
  });
  _api_register4([
    "columns().order()",
    "column().order()"
  ], function(dir) {
    var that = this;
    if (!dir) {
      return this.iterator("column", function(settings, idx) {
        var sort = _fnSortFlatten4(settings);
        for (var i = 0, ien = sort.length; i < ien; i++) {
          if (sort[i].col === idx) {
            return sort[i].dir;
          }
        }
        return null;
      }, 1);
    } else {
      return this.iterator("table", function(settings, i) {
        settings.aaSorting = that[i].map(function(col) {
          return [col, dir];
        });
      });
    }
  });
  _api_registerPlural4("columns().orderable()", "column().orderable()", function(directions) {
    return this.iterator("column", function(settings, idx) {
      var col = settings.aoColumns[idx];
      return directions ? col.asSorting : col.bSortable;
    }, 1);
  });
  _api_register4("processing()", function(show) {
    return this.iterator("table", function(ctx) {
      _fnProcessingDisplay4(ctx, show);
    });
  });
  _api_register4("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === void 0) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.search : void 0;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      if (typeof regex === "object") {
        _fnFilterComplete4(settings, $7.extend(settings.oPreviousSearch, regex, {
          search: input
        }));
      } else {
        _fnFilterComplete4(settings, $7.extend(settings.oPreviousSearch, {
          search: input,
          regex: regex === null ? false : regex,
          smart: smart === null ? true : smart,
          caseInsensitive: caseInsen === null ? true : caseInsen
        }));
      }
    });
  });
  _api_register4("search.fixed()", function(name, search) {
    var ret = this.iterator(true, "table", function(settings) {
      var fixed = settings.searchFixed;
      if (!name) {
        return Object.keys(fixed);
      } else if (search === void 0) {
        return fixed[name];
      } else if (search === null) {
        delete fixed[name];
      } else {
        fixed[name] = search;
      }
      return this;
    });
    return name !== void 0 && search === void 0 ? ret[0] : ret;
  });
  _api_registerPlural4(
    "columns().search()",
    "column().search()",
    function(input, regex, smart, caseInsen) {
      return this.iterator("column", function(settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === void 0) {
          return preSearch[column].search;
        }
        if (!settings.oFeatures.bFilter) {
          return;
        }
        if (typeof regex === "object") {
          $7.extend(preSearch[column], regex, {
            search: input
          });
        } else {
          $7.extend(preSearch[column], {
            search: input,
            regex: regex === null ? false : regex,
            smart: smart === null ? true : smart,
            caseInsensitive: caseInsen === null ? true : caseInsen
          });
        }
        _fnFilterComplete4(settings, settings.oPreviousSearch);
      });
    }
  );
  _api_register4(
    [
      "columns().search.fixed()",
      "column().search.fixed()"
    ],
    function(name, search) {
      var ret = this.iterator(true, "column", function(settings, colIdx) {
        var fixed = settings.aoColumns[colIdx].searchFixed;
        if (!name) {
          return Object.keys(fixed);
        } else if (search === void 0) {
          return fixed[name];
        } else if (search === null) {
          delete fixed[name];
        } else {
          fixed[name] = search;
        }
        return this;
      });
      return name !== void 0 && search === void 0 ? ret[0] : ret;
    }
  );
  _api_register4("state()", function(set, ignoreTime) {
    if (!set) {
      return this.context.length ? this.context[0].oSavedState : null;
    }
    var setMutate = $7.extend(true, {}, set);
    return this.iterator("table", function(settings) {
      if (ignoreTime !== false) {
        setMutate.time = +/* @__PURE__ */ new Date() + 100;
      }
      _fnImplementState4(settings, setMutate, function() {
      });
    });
  });
  _api_register4("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register4("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register4("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState4(settings);
    });
  });
  DataTable4.use = function(module, type) {
    if (type === "lib" || module.fn) {
      $7 = module;
    } else if (type == "win" || module.document) {
      window = module;
      document = module.document;
    } else if (type === "datetime" || module.type === "DateTime") {
      DataTable4.DateTime = module;
    }
  };
  DataTable4.factory = function(root, jq) {
    var is = false;
    if (root && root.document) {
      window = root;
      document = root.document;
    }
    if (jq && jq.fn && jq.fn.jquery) {
      $7 = jq;
      is = true;
    }
    return is;
  };
  DataTable4.versionCheck = function(version, version2) {
    var aThis = version2 ? version2.split(".") : DataTable4.version.split(".");
    var aThat = version.split(".");
    var iThis, iThat;
    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable4.isDataTable = function(table) {
    var t = $7(table).get(0);
    var is = false;
    if (table instanceof DataTable4.Api) {
      return true;
    }
    $7.each(DataTable4.settings, function(i, o) {
      var head = o.nScrollHead ? $7("table", o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $7("table", o.nScrollFoot)[0] : null;
      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  DataTable4.tables = function(visible) {
    var api = false;
    if ($7.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a = DataTable4.settings.filter(function(o) {
      return !visible || visible && $7(o.nTable).is(":visible") ? true : false;
    }).map(function(o) {
      return o.nTable;
    });
    return api ? new _Api4(a) : a;
  };
  DataTable4.camelToHungarian = _fnCamelToHungarian4;
  _api_register4("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $7(rows);
    return $7([].concat(
      jqRows.filter(selector).toArray(),
      jqRows.find(selector).toArray()
    ));
  });
  $7.each(["on", "one", "off"], function(i, key) {
    _api_register4(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      args[0] = args[0].split(/\s/).map(function(e) {
        return !e.match(/\.dt\b/) ? e + ".dt" : e;
      }).join(" ");
      var inst = $7(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register4("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable4(settings);
    });
  });
  _api_register4("error()", function(msg) {
    return this.iterator("table", function(settings) {
      _fnLog4(settings, 0, msg);
    });
  });
  _api_register4("settings()", function() {
    return new _Api4(this.context, this.context);
  });
  _api_register4("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register4("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck4(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register4("trigger()", function(name, args, bubbles) {
    return this.iterator("table", function(settings) {
      return _fnCallbackFire4(settings, null, name, args, bubbles);
    }).flatten();
  });
  _api_register4("ready()", function(fn) {
    var ctx = this.context;
    if (!fn) {
      return ctx.length ? ctx[0]._bInitComplete || false : null;
    }
    return this.tables().every(function() {
      if (this.context[0]._bInitComplete) {
        fn.call(this);
      } else {
        this.on("init", function() {
          fn.call(this);
        });
      }
    });
  });
  _api_register4("destroy()", function(remove) {
    remove = remove || false;
    return this.iterator("table", function(settings) {
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $7(table);
      var jqTbody = $7(tbody);
      var jqWrapper = $7(settings.nTableWrapper);
      var rows = settings.aoData.map(function(r) {
        return r ? r.nTr : null;
      });
      var orderClasses = classes.order;
      settings.bDestroying = true;
      _fnCallbackFire4(settings, "aoDestroyCallback", "destroy", [settings], true);
      if (!remove) {
        new _Api4(settings).columns().visible(true);
      }
      jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
      $7(window).off(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.colgroup.remove();
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses4(settings);
      $7("th, td", thead).removeClass(
        orderClasses.canAsc + " " + orderClasses.canDesc + " " + orderClasses.isAsc + " " + orderClasses.isDesc
      ).css("width", "");
      jqTbody.children().detach();
      jqTbody.append(rows);
      var orig = settings.nTableWrapper.parentNode;
      var insertBefore = settings.nTableWrapper.nextSibling;
      var removedMethod = remove ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove && orig) {
        orig.insertBefore(table, insertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.table);
      }
      var idx = DataTable4.settings.indexOf(settings);
      if (idx !== -1) {
        DataTable4.settings.splice(idx, 1);
      }
    });
  });
  $7.each(["column", "row", "cell"], function(i, type) {
    _api_register4(type + "s().every()", function(fn) {
      var opts = this.selector.opts;
      var api = this;
      var inst;
      var counter = 0;
      return this.iterator("every", function(settings, selectedIdx, tableIdx) {
        inst = api[type](selectedIdx, opts);
        if (type === "cell") {
          fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
        } else {
          fn.call(inst, selectedIdx, tableIdx, counter);
        }
        counter++;
      });
    });
  });
  _api_register4("i18n()", function(token, def, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn4(token)(ctx.oLanguage);
    if (resolved === void 0) {
      resolved = def;
    }
    if ($7.isPlainObject(resolved)) {
      resolved = plural !== void 0 && resolved[plural] !== void 0 ? resolved[plural] : resolved._;
    }
    return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
  });
  DataTable4.version = "2.0.5";
  DataTable4.settings = [];
  DataTable4.models = {};
  DataTable4.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     */
    "caseInsensitive": true,
    /**
     * Applied search term
     */
    "search": "",
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     */
    "regex": false,
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     */
    "smart": true,
    /**
     * Flag to indicate if DataTables should only trigger a search when
     * the return key is pressed.
     */
    "return": false
  };
  DataTable4.models.oRow = {
    /**
     * TR element for the row
     */
    "nTr": null,
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     */
    "anCells": null,
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     */
    "_aData": [],
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     */
    "_aSortData": null,
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     */
    "_aFilterData": null,
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     */
    "_sFilterRow": null,
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     */
    "src": null,
    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     */
    "idx": -1,
    /**
     * Cached display value
     */
    displayData: null
  };
  DataTable4.models.oColumn = {
    /**
     * Column index.
     */
    "idx": null,
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     */
    "aDataSort": null,
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     */
    "asSorting": null,
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     */
    "bSearchable": null,
    /**
     * Flag to indicate if the column is sortable or not.
     */
    "bSortable": null,
    /**
     * Flag to indicate if the column is currently visible in the table or not
     */
    "bVisible": null,
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     */
    "_sManualType": null,
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     */
    "_bAttrSrc": false,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     */
    "fnGetData": null,
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     */
    "fnSetData": null,
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     */
    "mData": null,
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     */
    "mRender": null,
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     */
    "sClass": null,
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     */
    "sContentPadding": null,
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     */
    "sName": null,
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     */
    "sSortDataType": "std",
    /**
     * Class to be applied to the header element when sorting on this column
     */
    "sSortingClass": null,
    /**
     * Title of the column - what is seen in the TH element (nTh).
     */
    "sTitle": null,
    /**
     * Column sorting and filtering type
     */
    "sType": null,
    /**
     * Width of the column
     */
    "sWidth": null,
    /**
     * Width of the column when it was first "encountered"
     */
    "sWidthOrig": null,
    /** Cached string which is the longest in the column */
    maxLenString: null,
    /**
     * Store for named searches
     */
    searchFixed: null
  };
  DataTable4.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     */
    "aaData": null,
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     */
    "aaSorting": [[0, "asc"]],
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     */
    "aaSortingFixed": [],
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     */
    "ajax": null,
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     */
    "aLengthMenu": [10, 25, 50, 100],
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     */
    "aoColumns": null,
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     */
    "aoColumnDefs": null,
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     */
    "aoSearchCols": [],
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     */
    "bAutoWidth": true,
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     */
    "bDeferRender": true,
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     */
    "bDestroy": false,
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     */
    "bFilter": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bInfo": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bLengthChange": true,
    /**
     * Enable or disable pagination.
     */
    "bPaginate": true,
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     */
    "bProcessing": false,
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     */
    "bRetrieve": false,
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     */
    "bScrollCollapse": false,
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     */
    "bServerSide": false,
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     */
    "bSort": true,
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     */
    "bSortMulti": true,
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     */
    "bSortCellsTop": null,
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     */
    "bSortClasses": true,
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     */
    "bStateSave": false,
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     */
    "fnCreatedRow": null,
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     */
    "fnDrawCallback": null,
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     */
    "fnFooterCallback": null,
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     */
    "fnFormatNumber": function(toFormat) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     */
    "fnHeaderCallback": null,
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     */
    "fnInfoCallback": null,
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     */
    "fnInitComplete": null,
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     */
    "fnPreDrawCallback": null,
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     */
    "fnRowCallback": null,
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateLoadCallback": function(settings) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            "DataTables_" + settings.sInstance + "_" + location.pathname
          )
        );
      } catch (e) {
        return {};
      }
    },
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     */
    "fnStateLoadParams": null,
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     */
    "fnStateLoaded": null,
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateSaveCallback": function(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname,
          JSON.stringify(data)
        );
      } catch (e) {
      }
    },
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     */
    "fnStateSaveParams": null,
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     */
    "iStateDuration": 7200,
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     */
    "iDisplayLength": 10,
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     */
    "iDisplayStart": 0,
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     */
    "iTabIndex": 0,
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     */
    "oClasses": {},
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be sorted
         */
        "orderable": ": Activate to sort",
        /**
         * ARIA label that is added to the table headers when the column is currently being sorted
         */
        "orderableReverse": ": Activate to invert sorting",
        /**
         * ARIA label that is added to the table headers when the column is currently being 
         * sorted and next step is to remove sorting
         */
        "orderableRemove": ": Activate to remove sorting",
        paginate: {
          first: "First",
          last: "Last",
          next: "Next",
          previous: "Previous"
        }
      },
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       */
      "oPaginate": {
        /**
         * Label and character for first page button ()
         */
        "sFirst": "\xAB",
        /**
         * Last page button ()
         */
        "sLast": "\xBB",
        /**
         * Next page button ()
         */
        "sNext": "\u203A",
        /**
         * Previous page button ()
         */
        "sPrevious": "\u2039"
      },
      /**
       * Plural object for the data type the table is showing
       */
      entries: {
        _: "entries",
        1: "entry"
      },
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       */
      "sEmptyTable": "No data available in table",
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       */
      "sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       */
      "sInfoPostFix": "",
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       */
      "sDecimal": "",
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       */
      "sThousands": ",",
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       */
      "sLengthMenu": "_MENU_ _ENTRIES_ per page",
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       */
      "sLoadingRecords": "Loading...",
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       */
      "sProcessing": "",
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       */
      "sSearch": "Search:",
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       */
      "sUrl": "",
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       */
      "sZeroRecords": "No matching records found"
    },
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     */
    "oSearch": $7.extend({}, DataTable4.models.oSearch),
    /**
     * Table and control layout. This replaces the legacy `dom` option.
     */
    layout: {
      topStart: "pageLength",
      topEnd: "search",
      bottomStart: "info",
      bottomEnd: "paging"
    },
    /**
     * Legacy DOM layout option
     */
    "sDom": null,
    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     */
    "searchDelay": null,
    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     */
    "sPaginationType": "full_numbers",
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     */
    "sScrollX": "",
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     */
    "sScrollXInner": "",
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     */
    "sScrollY": "",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     */
    "sServerMethod": "GET",
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     */
    "renderer": null,
    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     */
    "rowId": "DT_RowId",
    /**
     * Caption value
     */
    "caption": null
  };
  _fnHungarianMap4(DataTable4.defaults);
  DataTable4.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     */
    "aDataSort": null,
    "iDataSort": -1,
    ariaTitle: "",
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     */
    "asSorting": ["asc", "desc", ""],
    /**
     * Enable or disable filtering on the data in this column.
     */
    "bSearchable": true,
    /**
     * Enable or disable ordering on this column.
     */
    "bSortable": true,
    /**
     * Enable or disable the display of this column.
     */
    "bVisible": true,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     */
    "mData": null,
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     */
    "mRender": null,
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     */
    "sCellType": "td",
    /**
     * Class to give to each cell in this column.
     */
    "sClass": "",
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     */
    "sContentPadding": "",
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     */
    "sName": "",
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     */
    "sSortDataType": "std",
    /**
     * The title of this column.
     */
    "sTitle": null,
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     */
    "sType": null,
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     */
    "sWidth": null
  };
  _fnHungarianMap4(DataTable4.defaults.column);
  DataTable4.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bAutoWidth": null,
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all for DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bDeferRender": null,
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bFilter": null,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bInfo": true,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bLengthChange": true,
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bPaginate": null,
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bProcessing": null,
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bServerSide": null,
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSort": null,
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortMulti": null,
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortClasses": null,
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bStateSave": null
    },
    /**
     * Scrolling settings for a table.
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bCollapse": null,
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       */
      "iBarWidth": 0,
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sX": null,
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @deprecated
       */
      "sXInner": null,
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sY": null
    },
    /**
     * Language information for the table.
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       */
      "fnInfoCallback": null
    },
    /**
     * Browser support parameters
     */
    "oBrowser": {
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       */
      "bScrollbarLeft": false,
      /**
       * Browser scrollbar width
       */
      "barWidth": 0
    },
    "ajax": null,
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     */
    "aanFeatures": [],
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     */
    "aoData": [],
    /**
     * Array of indexes which are in the current display (after filtering etc)
     */
    "aiDisplay": [],
    /**
     * Array of indexes for display - no filtering
     */
    "aiDisplayMaster": [],
    /**
     * Map of row ids to data indexes
     */
    "aIds": {},
    /**
     * Store information about each column that is in use
     */
    "aoColumns": [],
    /**
     * Store information about the table's header
     */
    "aoHeader": [],
    /**
     * Store information about the table's footer
     */
    "aoFooter": [],
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "oPreviousSearch": {},
    /**
     * Store for named searches
     */
    searchFixed: {},
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     */
    "aoPreSearchCols": [],
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSorting": null,
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSortingFixed": [],
    /**
     * If restoring a table - we should restore its width
     */
    "sDestroyWidth": 0,
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     */
    "aoRowCallback": [],
    /**
     * Callback functions for the header on each draw.
     */
    "aoHeaderCallback": [],
    /**
     * Callback function for the footer on each draw.
     */
    "aoFooterCallback": [],
    /**
     * Array of callback functions for draw callback functions
     */
    "aoDrawCallback": [],
    /**
     * Array of callback functions for row created function
     */
    "aoRowCreatedCallback": [],
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     */
    "aoPreDrawCallback": [],
    /**
     * Callback functions for when the table has been initialised.
     */
    "aoInitComplete": [],
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     */
    "aoStateSaveParams": [],
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     */
    "aoStateLoadParams": [],
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     */
    "aoStateLoaded": [],
    /**
     * Cache the table ID for quick access
     */
    "sTableId": "",
    /**
     * The TABLE node for the main table
     */
    "nTable": null,
    /**
     * Permanent ref to the thead element
     */
    "nTHead": null,
    /**
     * Permanent ref to the tfoot element - if it exists
     */
    "nTFoot": null,
    /**
     * Permanent ref to the tbody element
     */
    "nTBody": null,
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     */
    "nTableWrapper": null,
    /**
     * Indicate if all required information has been read in
     */
    "bInitialised": false,
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     */
    "aoOpenRows": [],
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sDom": null,
    /**
     * Search delay (in mS)
     */
    "searchDelay": null,
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sPaginationType": "two_button",
    /**
     * Number of paging controls on the page. Only used for backwards compatibility
     */
    pagingControls: 0,
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "iStateDuration": 0,
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateSave": [],
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateLoad": [],
    /**
     * State that was saved. Useful for back reference
     */
    "oSavedState": null,
    /**
     * State that was loaded. Useful for back reference
     */
    "oLoadedState": null,
    /**
     * Note if draw should be blocked while getting data
     */
    "bAjaxDataGet": true,
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     */
    "jqXHR": null,
    /**
     * JSON returned from the server in the last Ajax request
     */
    "json": void 0,
    /**
     * Data submitted as part of the last Ajax request
     */
    "oAjaxData": void 0,
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sServerMethod": null,
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "fnFormatNumber": null,
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aLengthMenu": null,
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     */
    "iDraw": 0,
    /**
     * Indicate if a redraw is being done - useful for Ajax
     */
    "bDrawing": false,
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     */
    "iDrawError": -1,
    /**
     * Paging display length
     */
    "_iDisplayLength": 10,
    /**
     * Paging start point - aiDisplay index
     */
    "_iDisplayStart": 0,
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsTotal": 0,
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsDisplay": 0,
    /**
     * The classes to use for the table
     */
    "oClasses": {},
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bFiltered": false,
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bSorted": false,
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSortCellsTop": null,
    /**
     * Initialisation object that is used for the table
     */
    "oInit": null,
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     */
    "aoDestroyCallback": [],
    /**
     * Get the number of records in the current record set, before filtering
     */
    "fnRecordsTotal": function() {
      return _fnDataSource4(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },
    /**
     * Get the number of records in the current record set, after filtering
     */
    "fnRecordsDisplay": function() {
      return _fnDataSource4(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },
    /**
     * Get the display end point - aiDisplay index
     */
    "fnDisplayEnd": function() {
      var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },
    /**
     * The DataTables object for this table
     */
    "oInstance": null,
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     */
    "sInstance": null,
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
    /**
     * Last applied sort
     */
    "aLastSort": [],
    /**
     * Stored plug-in instances
     */
    "oPlugins": {},
    /**
     * Function used to get a row's id from the row's data
     */
    "rowIdFn": null,
    /**
     * Data location where to store a row's id
     */
    "rowId": null,
    caption: "",
    captionNode: null,
    colgroup: null
  };
  var extPagination4 = DataTable4.ext.pager;
  $7.extend(extPagination4, {
    simple: function() {
      return ["previous", "next"];
    },
    full: function() {
      return ["first", "previous", "next", "last"];
    },
    numbers: function() {
      return ["numbers"];
    },
    simple_numbers: function() {
      return ["previous", "numbers", "next"];
    },
    full_numbers: function() {
      return ["first", "previous", "numbers", "next", "last"];
    },
    first_last: function() {
      return ["first", "last"];
    },
    first_last_numbers: function() {
      return ["first", "numbers", "last"];
    },
    // For testing and plug-ins to use
    _numbers: _pagingNumbers4,
    // Number of number buttons - legacy, use `numbers` option for paging feature
    numbers_length: 7
  });
  $7.extend(true, DataTable4.ext.renderer, {
    pagingButton: {
      _: function(settings, buttonType, content, active, disabled) {
        var classes = settings.oClasses.paging;
        var btnClasses = [classes.button];
        var btn;
        if (active) {
          btnClasses.push(classes.active);
        }
        if (disabled) {
          btnClasses.push(classes.disabled);
        }
        if (buttonType === "ellipsis") {
          btn = $7('<span class="ellipsis"></span>').html(content)[0];
        } else {
          btn = $7("<button>", {
            class: btnClasses.join(" "),
            role: "link",
            type: "button"
          }).html(content);
        }
        return {
          display: btn,
          clicker: btn
        };
      }
    },
    pagingContainer: {
      _: function(settings, buttons) {
        return buttons;
      }
    }
  });
  var _filterString4 = function(stripHtml, normalize) {
    return function(str) {
      if (_empty4(str) || typeof str !== "string") {
        return str;
      }
      str = str.replace(_re_new_lines4, " ");
      if (stripHtml) {
        str = _stripHtml4(str);
      }
      if (normalize) {
        str = _normalize4(str, false);
      }
      return str;
    };
  };
  function __mldFnName3(name) {
    return name.replace(/[\W]/g, "_");
  }
  function __mld4(dt, momentFn, luxonFn, dateFn, arg1) {
    if (window.moment) {
      return dt[momentFn](arg1);
    } else if (window.luxon) {
      return dt[luxonFn](arg1);
    }
    return dateFn ? dt[dateFn](arg1) : dt;
  }
  var __mlWarning4 = false;
  function __mldObj4(d, format, locale) {
    var dt;
    if (window.moment) {
      dt = window.moment.utc(d, format, locale, true);
      if (!dt.isValid()) {
        return null;
      }
    } else if (window.luxon) {
      dt = format && typeof d === "string" ? window.luxon.DateTime.fromFormat(d, format) : window.luxon.DateTime.fromISO(d);
      if (!dt.isValid) {
        return null;
      }
      dt.setLocale(locale);
    } else if (!format) {
      dt = new Date(d);
    } else {
      if (!__mlWarning4) {
        alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
      }
      __mlWarning4 = true;
    }
    return dt;
  }
  function __mlHelper4(localeString) {
    return function(from, to, locale, def) {
      if (arguments.length === 0) {
        locale = "en";
        to = null;
        from = null;
      } else if (arguments.length === 1) {
        locale = "en";
        to = from;
        from = null;
      } else if (arguments.length === 2) {
        locale = to;
        to = from;
        from = null;
      }
      var typeName = "datetime" + (to ? "-" + __mldFnName3(to) : "");
      if (!DataTable4.ext.type.order[typeName]) {
        DataTable4.type(typeName, {
          detect: function(d) {
            return d === typeName ? typeName : false;
          },
          order: {
            pre: function(d) {
              return d.valueOf();
            }
          },
          className: "dt-right"
        });
      }
      return function(d, type) {
        if (d === null || d === void 0) {
          if (def === "--now") {
            var local = /* @__PURE__ */ new Date();
            d = new Date(Date.UTC(
              local.getFullYear(),
              local.getMonth(),
              local.getDate(),
              local.getHours(),
              local.getMinutes(),
              local.getSeconds()
            ));
          } else {
            d = "";
          }
        }
        if (type === "type") {
          return typeName;
        }
        if (d === "") {
          return type !== "sort" ? "" : __mldObj4("0000-01-01 00:00:00", null, locale);
        }
        if (to !== null && from === to && type !== "sort" && type !== "type" && !(d instanceof Date)) {
          return d;
        }
        var dt = __mldObj4(d, from, locale);
        if (dt === null) {
          return d;
        }
        if (type === "sort") {
          return dt;
        }
        var formatted = to === null ? __mld4(dt, "toDate", "toJSDate", "")[localeString]() : __mld4(dt, "format", "toFormat", "toISOString", to);
        return type === "display" ? _escapeHtml4(formatted) : formatted;
      };
    };
  }
  var __thousands4 = ",";
  var __decimal4 = ".";
  if (window.Intl !== void 0) {
    try {
      num = new Intl.NumberFormat().formatToParts(100000.1);
      for (i = 0; i < num.length; i++) {
        if (num[i].type === "group") {
          __thousands4 = num[i].value;
        } else if (num[i].type === "decimal") {
          __decimal4 = num[i].value;
        }
      }
    } catch (e) {
    }
  }
  var num;
  var i;
  DataTable4.datetime = function(format, locale) {
    var typeName = "datetime-detect-" + __mldFnName3(format);
    if (!locale) {
      locale = "en";
    }
    if (!DataTable4.ext.type.order[typeName]) {
      DataTable4.type(typeName, {
        detect: function(d) {
          var dt = __mldObj4(d, format, locale);
          return d === "" || dt ? typeName : false;
        },
        order: {
          pre: function(d) {
            return __mldObj4(d, format, locale) || 0;
          }
        },
        className: "dt-right"
      });
    }
  };
  DataTable4.render = {
    date: __mlHelper4("toLocaleDateString"),
    datetime: __mlHelper4("toLocaleString"),
    time: __mlHelper4("toLocaleTimeString"),
    number: function(thousands, decimal, precision, prefix, postfix) {
      if (thousands === null || thousands === void 0) {
        thousands = __thousands4;
      }
      if (decimal === null || decimal === void 0) {
        decimal = __decimal4;
      }
      return {
        display: function(d) {
          if (typeof d !== "number" && typeof d !== "string") {
            return d;
          }
          if (d === "" || d === null) {
            return d;
          }
          var negative = d < 0 ? "-" : "";
          var flo = parseFloat(d);
          var abs = Math.abs(flo);
          if (abs >= 1e11 || abs < 1e-4 && abs !== 0) {
            var exp = flo.toExponential(precision).split(/e\+?/);
            return exp[0] + " x 10<sup>" + exp[1] + "</sup>";
          }
          if (isNaN(flo)) {
            return _escapeHtml4(d);
          }
          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
          if (intPart === 0 && parseFloat(floatPart) === 0) {
            negative = "";
          }
          return negative + (prefix || "") + intPart.toString().replace(
            /\B(?=(\d{3})+(?!\d))/g,
            thousands
          ) + floatPart + (postfix || "");
        }
      };
    },
    text: function() {
      return {
        display: _escapeHtml4,
        filter: _escapeHtml4
      };
    }
  };
  var _extTypes4 = DataTable4.ext.type;
  DataTable4.type = function(name, prop, val) {
    if (!prop) {
      return {
        className: _extTypes4.className[name],
        detect: _extTypes4.detect.find(function(fn) {
          return fn.name === name;
        }),
        order: {
          pre: _extTypes4.order[name + "-pre"],
          asc: _extTypes4.order[name + "-asc"],
          desc: _extTypes4.order[name + "-desc"]
        },
        render: _extTypes4.render[name],
        search: _extTypes4.search[name]
      };
    }
    var setProp = function(prop2, propVal) {
      _extTypes4[prop2][name] = propVal;
    };
    var setDetect = function(fn) {
      var cb = function(d, s) {
        var ret = fn(d, s);
        return ret === true ? name : ret;
      };
      Object.defineProperty(cb, "name", { value: name });
      var idx = _extTypes4.detect.findIndex(function(fn2) {
        return fn2.name === name;
      });
      if (idx === -1) {
        _extTypes4.detect.unshift(cb);
      } else {
        _extTypes4.detect.splice(idx, 1, cb);
      }
    };
    var setOrder = function(obj) {
      _extTypes4.order[name + "-pre"] = obj.pre;
      _extTypes4.order[name + "-asc"] = obj.asc;
      _extTypes4.order[name + "-desc"] = obj.desc;
    };
    if (val === void 0) {
      val = prop;
      prop = null;
    }
    if (prop === "className") {
      setProp("className", val);
    } else if (prop === "detect") {
      setDetect(val);
    } else if (prop === "order") {
      setOrder(val);
    } else if (prop === "render") {
      setProp("render", val);
    } else if (prop === "search") {
      setProp("search", val);
    } else if (!prop) {
      if (val.className) {
        setProp("className", val.className);
      }
      if (val.detect !== void 0) {
        setDetect(val.detect);
      }
      if (val.order) {
        setOrder(val.order);
      }
      if (val.render !== void 0) {
        setProp("render", val.render);
      }
      if (val.search !== void 0) {
        setProp("search", val.search);
      }
    }
  };
  DataTable4.types = function() {
    return _extTypes4.detect.map(function(fn) {
      return fn.name;
    });
  };
  DataTable4.type("string", {
    detect: function() {
      return "string";
    },
    order: {
      pre: function(a) {
        return _empty4(a) ? "" : typeof a === "string" ? a.toLowerCase() : !a.toString ? "" : a.toString();
      }
    },
    search: _filterString4(false, true)
  });
  DataTable4.type("html", {
    detect: function(d) {
      return _empty4(d) || typeof d === "string" && d.indexOf("<") !== -1 ? "html" : null;
    },
    order: {
      pre: function(a) {
        return _empty4(a) ? "" : a.replace ? _stripHtml4(a).trim().toLowerCase() : a + "";
      }
    },
    search: _filterString4(true, true)
  });
  DataTable4.type("date", {
    className: "dt-type-date",
    detect: function(d) {
      if (d && !(d instanceof Date) && !_re_date4.test(d)) {
        return null;
      }
      var parsed = Date.parse(d);
      return parsed !== null && !isNaN(parsed) || _empty4(d) ? "date" : null;
    },
    order: {
      pre: function(d) {
        var ts = Date.parse(d);
        return isNaN(ts) ? -Infinity : ts;
      }
    }
  });
  DataTable4.type("html-num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric4(d, decimal, true) ? "html-num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace4(d, dp, _re_html4, _re_formatted_numeric4);
      }
    },
    search: _filterString4(true, true)
  });
  DataTable4.type("html-num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric4(d, decimal) ? "html-num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace4(d, dp, _re_html4);
      }
    },
    search: _filterString4(true, true)
  });
  DataTable4.type("num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber4(d, decimal, true) ? "num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace4(d, dp, _re_formatted_numeric4);
      }
    }
  });
  DataTable4.type("num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber4(d, decimal) ? "num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace4(d, dp);
      }
    }
  });
  var __numericReplace4 = function(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === "-")) {
      return -Infinity;
    }
    var type = typeof d;
    if (type === "number" || type === "bigint") {
      return d;
    }
    if (decimalPlace) {
      d = _numToDecimal4(d, decimalPlace);
    }
    if (d.replace) {
      if (re1) {
        d = d.replace(re1, "");
      }
      if (re2) {
        d = d.replace(re2, "");
      }
    }
    return d * 1;
  };
  $7.extend(true, DataTable4.ext.renderer, {
    footer: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.tfoot.cell);
      }
    },
    header: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.thead.cell);
        if (!settings.oFeatures.bSort) {
          cell.addClass(classes.order.none);
        }
        var legacyTop = settings.bSortCellsTop;
        var headerRows = cell.closest("thead").find("tr");
        var rowIdx = cell.parent().index();
        if (
          // Cells and rows which have the attribute to disable the icons
          cell.attr("data-dt-order") === "disable" || cell.parent().attr("data-dt-order") === "disable" || // Legacy support for `orderCellsTop`. If it is set, then cells
          // which are not in the top or bottom row of the header (depending
          // on the value) do not get the sorting classes applied to them
          legacyTop === true && rowIdx !== 0 || legacyTop === false && rowIdx !== headerRows.length - 1
        ) {
          return;
        }
        $7(settings.nTable).on("order.dt.DT", function(e, ctx, sorting) {
          if (settings !== ctx) {
            return;
          }
          var orderClasses = classes.order;
          var columns = ctx.api.columns(cell);
          var col = settings.aoColumns[columns.flatten()[0]];
          var orderable = columns.orderable().includes(true);
          var ariaType = "";
          var indexes = columns.indexes();
          var sortDirs = columns.orderable(true).flatten();
          var orderedColumns = "," + sorting.map(function(val) {
            return val.col;
          }).join(",") + ",";
          cell.removeClass(
            orderClasses.isAsc + " " + orderClasses.isDesc
          ).toggleClass(orderClasses.none, !orderable).toggleClass(orderClasses.canAsc, orderable && sortDirs.includes("asc")).toggleClass(orderClasses.canDesc, orderable && sortDirs.includes("desc"));
          var sortIdx = orderedColumns.indexOf("," + indexes.toArray().join(",") + ",");
          if (sortIdx !== -1) {
            var orderDirs = columns.order();
            cell.addClass(
              orderDirs.includes("asc") ? orderClasses.isAsc : "" + orderDirs.includes("desc") ? orderClasses.isDesc : ""
            );
          }
          if (sortIdx === 0) {
            var firstSort = sorting[0];
            var sortOrder = col.asSorting;
            cell.attr("aria-sort", firstSort.dir === "asc" ? "ascending" : "descending");
            ariaType = !sortOrder[firstSort.index + 1] ? "Remove" : "Reverse";
          } else {
            cell.removeAttr("aria-sort");
          }
          cell.attr(
            "aria-label",
            orderable ? col.ariaTitle + ctx.api.i18n("oAria.orderable" + ariaType) : col.ariaTitle
          );
          if (orderable) {
            cell.find(".dt-column-title").attr("role", "button");
            cell.attr("tabindex", 0);
          }
        });
      }
    },
    layout: {
      _: function(settings, container, items) {
        var row = $7("<div/>").addClass("dt-layout-row").appendTo(container);
        $7.each(items, function(key, val) {
          var klass = !val.table ? "dt-" + key + " " : "";
          if (val.table) {
            row.addClass("dt-layout-table");
          }
          $7("<div/>").attr({
            id: val.id || null,
            "class": "dt-layout-cell " + klass + (val.className || "")
          }).append(val.contents).appendTo(row);
        });
      }
    }
  });
  DataTable4.feature = {};
  DataTable4.feature.register = function(name, cb, legacy) {
    DataTable4.ext.features[name] = cb;
    if (legacy) {
      _ext4.feature.push({
        cFeature: legacy,
        fnInit: cb
      });
    }
  };
  DataTable4.feature.register("info", function(settings, opts) {
    if (!settings.oFeatures.bInfo) {
      return null;
    }
    var lang = settings.oLanguage, tid = settings.sTableId, n = $7("<div/>", {
      "class": settings.oClasses.info.container
    });
    opts = $7.extend({
      callback: lang.fnInfoCallback,
      empty: lang.sInfoEmpty,
      postfix: lang.sInfoPostFix,
      search: lang.sInfoFiltered,
      text: lang.sInfo
    }, opts);
    settings.aoDrawCallback.push(function(s) {
      _fnUpdateInfo4(s, opts, n);
    });
    if (!settings._infoEl) {
      n.attr({
        "aria-live": "polite",
        id: tid + "_info",
        role: "status"
      });
      $7(settings.nTable).attr("aria-describedby", tid + "_info");
      settings._infoEl = n;
    }
    return n;
  }, "i");
  function _fnUpdateInfo4(settings, opts, node) {
    var start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? opts.text : opts.empty;
    if (total !== max) {
      out += " " + opts.search;
    }
    out += opts.postfix;
    out = _fnMacros4(settings, out);
    if (opts.callback) {
      out = opts.callback.call(
        settings.oInstance,
        settings,
        start,
        end,
        max,
        total,
        out
      );
    }
    node.html(out);
    _fnCallbackFire4(settings, null, "info", [settings, node[0], out]);
  }
  var __searchCounter4 = 0;
  DataTable4.feature.register("search", function(settings, opts) {
    if (!settings.oFeatures.bFilter) {
      return null;
    }
    var classes = settings.oClasses.search;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var input = '<input type="search" class="' + classes.input + '"/>';
    opts = $7.extend({
      placeholder: language.sSearchPlaceholder,
      text: language.sSearch
    }, opts);
    if (opts.text.indexOf("_INPUT_") === -1) {
      opts.text += "_INPUT_";
    }
    opts.text = _fnMacros4(settings, opts.text);
    var end = opts.text.match(/_INPUT_$/);
    var start = opts.text.match(/^_INPUT_/);
    var removed = opts.text.replace(/_INPUT_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_INPUT_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_INPUT_";
    }
    var filter = $7("<div>").addClass(classes.container).append(str.replace(/_INPUT_/, input));
    filter.find("label").attr("for", "dt-search-" + __searchCounter4);
    filter.find("input").attr("id", "dt-search-" + __searchCounter4);
    __searchCounter4++;
    var searchFn = function(event) {
      var val = this.value;
      if (previousSearch.return && event.key !== "Enter") {
        return;
      }
      if (val != previousSearch.search) {
        previousSearch.search = val;
        _fnFilterComplete4(settings, previousSearch);
        settings._iDisplayStart = 0;
        _fnDraw4(settings);
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : 0;
    var jqFilter = $7("input", filter).val(previousSearch.search).attr("placeholder", opts.placeholder).on(
      "keyup.DT search.DT input.DT paste.DT cut.DT",
      searchDelay ? DataTable4.util.debounce(searchFn, searchDelay) : searchFn
    ).on("mouseup.DT", function(e) {
      setTimeout(function() {
        searchFn.call(jqFilter[0], e);
      }, 10);
    }).on("keypress.DT", function(e) {
      if (e.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $7(settings.nTable).on("search.dt.DT", function(ev, s) {
      if (settings === s && jqFilter[0] !== document.activeElement) {
        jqFilter.val(
          typeof previousSearch.search !== "function" ? previousSearch.search : ""
        );
      }
    });
    return filter;
  }, "f");
  DataTable4.feature.register("paging", function(settings, opts) {
    if (!settings.oFeatures.bPaginate) {
      return null;
    }
    opts = $7.extend({
      buttons: DataTable4.ext.pager.numbers_length,
      type: settings.sPaginationType,
      boundaryNumbers: true
    }, opts);
    if (opts.numbers) {
      opts.buttons = opts.numbers;
    }
    var host = $7("<div/>").addClass(settings.oClasses.paging.container + " paging_" + opts.type);
    var draw = function() {
      _pagingDraw4(settings, host, opts);
    };
    settings.aoDrawCallback.push(draw);
    $7(settings.nTable).on("column-sizing.dt.DT", draw);
    return host;
  }, "p");
  function _pagingDraw4(settings, host, opts) {
    if (!settings._bInitComplete) {
      return;
    }
    var plugin = DataTable4.ext.pager[opts.type], aria = settings.oLanguage.oAria.paginate || {}, start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin().map(function(val) {
      return val === "numbers" ? _pagingNumbers4(page, pages, opts.buttons, opts.boundaryNumbers) : val;
    }).flat();
    var buttonEls = [];
    for (var i = 0; i < buttons.length; i++) {
      var button = buttons[i];
      var btnInfo = _pagingButtonInfo4(settings, button, page, pages);
      var btn = _fnRenderer4(settings, "pagingButton")(
        settings,
        button,
        btnInfo.display,
        btnInfo.active,
        btnInfo.disabled
      );
      $7(btn.clicker).attr({
        "aria-controls": settings.sTableId,
        "aria-disabled": btnInfo.disabled ? "true" : null,
        "aria-current": btnInfo.active ? "page" : null,
        "aria-label": aria[button],
        "data-dt-idx": button,
        "tabIndex": btnInfo.disabled ? -1 : settings.iTabIndex
      });
      if (typeof button !== "number") {
        $7(btn.clicker).addClass(button);
      }
      _fnBindAction4(
        btn.clicker,
        { action: button },
        function(e) {
          e.preventDefault();
          _fnPageChange4(settings, e.data.action, true);
        }
      );
      buttonEls.push(btn.display);
    }
    var wrapped = _fnRenderer4(settings, "pagingContainer")(
      settings,
      buttonEls
    );
    var activeEl = host.find(document.activeElement).data("dt-idx");
    host.empty().append(wrapped);
    if (activeEl !== void 0) {
      host.find("[data-dt-idx=" + activeEl + "]").trigger("focus");
    }
    if (buttonEls.length && // any buttons
    opts.numbers > 1 && // prevent infinite
    $7(host).height() >= $7(buttonEls[0]).outerHeight() * 2 - 10) {
      _pagingDraw4(settings, host, $7.extend({}, opts, { numbers: opts.numbers - 2 }));
    }
  }
  function _pagingButtonInfo4(settings, button, page, pages) {
    var lang = settings.oLanguage.oPaginate;
    var o = {
      display: "",
      active: false,
      disabled: false
    };
    switch (button) {
      case "ellipsis":
        o.display = "&#x2026;";
        o.disabled = true;
        break;
      case "first":
        o.display = lang.sFirst;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "previous":
        o.display = lang.sPrevious;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "next":
        o.display = lang.sNext;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      case "last":
        o.display = lang.sLast;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      default:
        if (typeof button === "number") {
          o.display = settings.fnFormatNumber(button + 1);
          if (page === button) {
            o.active = true;
          }
        }
        break;
    }
    return o;
  }
  function _pagingNumbers4(page, pages, buttons, addFirstLast) {
    var numbers = [], half = Math.floor(buttons / 2), before = addFirstLast ? 2 : 1, after = addFirstLast ? 1 : 0;
    if (pages <= buttons) {
      numbers = _range4(0, pages);
    } else if (buttons === 1) {
      numbers = [page];
    } else if (buttons === 3) {
      if (page <= 1) {
        numbers = [0, 1, "ellipsis"];
      } else if (page >= pages - 2) {
        numbers = _range4(pages - 2, pages);
        numbers.unshift("ellipsis");
      } else {
        numbers = ["ellipsis", page, "ellipsis"];
      }
    } else if (page <= half) {
      numbers = _range4(0, buttons - before);
      numbers.push("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
      }
    } else if (page >= pages - 1 - half) {
      numbers = _range4(pages - (buttons - before), pages);
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.unshift(0);
      }
    } else {
      numbers = _range4(page - half + before, page + half - after);
      numbers.push("ellipsis");
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
        numbers.unshift(0);
      }
    }
    return numbers;
  }
  var __lengthCounter4 = 0;
  DataTable4.feature.register("pageLength", function(settings, opts) {
    var features = settings.oFeatures;
    if (!features.bPaginate || !features.bLengthChange) {
      return null;
    }
    opts = $7.extend({
      menu: settings.aLengthMenu,
      text: settings.oLanguage.sLengthMenu
    }, opts);
    var classes = settings.oClasses.length, tableId = settings.sTableId, menu = opts.menu, lengths = [], language = [], i;
    if (Array.isArray(menu[0])) {
      lengths = menu[0];
      language = menu[1];
    } else {
      for (i = 0; i < menu.length; i++) {
        if ($7.isPlainObject(menu[i])) {
          lengths.push(menu[i].value);
          language.push(menu[i].label);
        } else {
          lengths.push(menu[i]);
          language.push(menu[i]);
        }
      }
    }
    var end = opts.text.match(/_MENU_$/);
    var start = opts.text.match(/^_MENU_/);
    var removed = opts.text.replace(/_MENU_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_MENU_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_MENU_";
    }
    var div = $7("<div/>").addClass(classes.container).append(
      str.replace("_MENU_", "<span></span>")
    );
    var textNodes = [];
    div.find("label")[0].childNodes.forEach(function(el) {
      if (el.nodeType === Node.TEXT_NODE) {
        textNodes.push({
          el,
          text: el.textContent
        });
      }
    });
    var updateEntries = function(len) {
      textNodes.forEach(function(node) {
        node.el.textContent = _fnMacros4(settings, node.text, len);
      });
    };
    var select = $7("<select/>", {
      "name": tableId + "_length",
      "aria-controls": tableId,
      "class": classes.select
    });
    for (i = 0; i < lengths.length; i++) {
      select[0][i] = new Option(
        typeof language[i] === "number" ? settings.fnFormatNumber(language[i]) : language[i],
        lengths[i]
      );
    }
    div.find("label").attr("for", "dt-length-" + __lengthCounter4);
    select.attr("id", "dt-length-" + __lengthCounter4);
    __lengthCounter4++;
    div.find("span").replaceWith(select);
    $7("select", div).val(settings._iDisplayLength).on("change.DT", function() {
      _fnLengthChange4(settings, $7(this).val());
      _fnDraw4(settings);
    });
    $7(settings.nTable).on("length.dt.DT", function(e, s, len) {
      if (settings === s) {
        $7("select", div).val(len);
        updateEntries(len);
      }
    });
    updateEntries(settings._iDisplayLength);
    return div;
  }, "l");
  $7.fn.dataTable = DataTable4;
  DataTable4.$ = $7;
  $7.fn.dataTableSettings = DataTable4.settings;
  $7.fn.dataTableExt = DataTable4.ext;
  $7.fn.DataTable = function(opts) {
    return $7(this).dataTable(opts).api();
  };
  $7.each(DataTable4, function(prop, val) {
    $7.fn.DataTable[prop] = val;
  });
  var dataTables_default4 = DataTable4;

  // node_modules/datatables.net-fixedheader-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs
  var $8 = import_jquery9.default;
  $8.extend(true, dataTables_default4.defaults, {
    renderer: "bootstrap"
  });
  $8.extend(true, dataTables_default4.ext.classes, {
    container: "dt-container dt-bootstrap5",
    search: {
      input: "form-control form-control-sm"
    },
    length: {
      select: "form-select form-select-sm"
    },
    processing: {
      container: "dt-processing card"
    }
  });
  dataTables_default4.ext.renderer.pagingButton.bootstrap = function(settings, buttonType, content, active, disabled) {
    var btnClasses = ["dt-paging-button", "page-item"];
    if (active) {
      btnClasses.push("active");
    }
    if (disabled) {
      btnClasses.push("disabled");
    }
    var li = $8("<li>").addClass(btnClasses.join(" "));
    var a = $8("<a>", {
      "href": disabled ? null : "#",
      "class": "page-link"
    }).html(content).appendTo(li);
    return {
      display: li,
      clicker: a
    };
  };
  dataTables_default4.ext.renderer.pagingContainer.bootstrap = function(settings, buttonEls) {
    return $8("<ul/>").addClass("pagination").append(buttonEls);
  };
  dataTables_default4.ext.renderer.layout.bootstrap = function(settings, container, items) {
    var row = $8("<div/>", {
      "class": items.full ? "row mt-2 justify-content-md-center" : "row mt-2 justify-content-between"
    }).appendTo(container);
    $8.each(items, function(key, val) {
      var klass;
      if (val.table) {
        klass = "col-12";
      } else if (key === "start") {
        klass = "col-md-auto me-auto";
      } else if (key === "end") {
        klass = "col-md-auto ms-auto";
      } else {
        klass = "col-md";
      }
      $8("<div/>", {
        id: val.id || null,
        "class": klass + " " + (val.className || "")
      }).append(val.contents).appendTo(row);
    });
  };

  // node_modules/datatables.net-fixedheader/js/dataTables.fixedHeader.mjs
  var import_jquery11 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-fixedheader/node_modules/datatables.net/js/dataTables.mjs
  var import_jquery10 = __toESM(require_jquery(), 1);
  var $9 = import_jquery10.default;
  var DataTable5 = function(selector, options) {
    if (DataTable5.factory(selector, options)) {
      return DataTable5;
    }
    if (this instanceof DataTable5) {
      return $9(selector).DataTable(options);
    } else {
      options = selector;
    }
    var _that = this;
    var emptyInit = options === void 0;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.api = function() {
      return new _Api5(this);
    };
    this.each(function() {
      var o = {};
      var oInit = len > 1 ? (
        // optimisation for single table case
        _fnExtend5(o, options, true)
      ) : options;
      var i = 0, iLen;
      var sId = this.getAttribute("id");
      var bInitHandedOff = false;
      var defaults = DataTable5.defaults;
      var $this = $9(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog5(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      $9(this).trigger("options.dt", oInit);
      _fnCompatOpts5(defaults);
      _fnCompatCols5(defaults.column);
      _fnCamelToHungarian5(defaults, defaults, true);
      _fnCamelToHungarian5(defaults.column, defaults.column, true);
      _fnCamelToHungarian5(defaults, $9.extend(oInit, $this.data()), true);
      var allSettings = DataTable5.settings;
      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            new DataTable5.Api(s).destroy();
            break;
          } else {
            _fnLog5(s, 0, "Cannot reinitialise DataTable", 3);
            return;
          }
        }
        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable5.ext._unique++;
        this.id = sId;
      }
      var oSettings = $9.extend(true, {}, DataTable5.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId,
        colgroup: $9("<colgroup>").prependTo(this),
        fastData: function(row, column, type) {
          return _fnGetCellData5(oSettings, row, column, type);
        }
      });
      oSettings.nTable = this;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.api = new _Api5(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts5(oInit);
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : $9.isPlainObject(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0].value : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend5($9.extend(true, {}, defaults), oInit);
      _fnMap5(oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ]);
      _fnMap5(oSettings, oInit, [
        "ajax",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "iStateDuration",
        "bSortCellsTop",
        "iTabIndex",
        "sDom",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        "caption",
        "layout",
        ["iCookieDuration", "iStateDuration"],
        // backwards compat
        ["oSearch", "oPreviousSearch"],
        ["aoSearchCols", "aoPreSearchCols"],
        ["iDisplayLength", "_iDisplayLength"]
      ]);
      _fnMap5(oSettings.oScroll, oInit, [
        ["sScrollX", "sX"],
        ["sScrollXInner", "sXInner"],
        ["sScrollY", "sY"],
        ["bScrollCollapse", "bCollapse"]
      ]);
      _fnMap5(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg5(oSettings, "aoDrawCallback", oInit.fnDrawCallback);
      _fnCallbackReg5(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams);
      _fnCallbackReg5(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams);
      _fnCallbackReg5(oSettings, "aoStateLoaded", oInit.fnStateLoaded);
      _fnCallbackReg5(oSettings, "aoRowCallback", oInit.fnRowCallback);
      _fnCallbackReg5(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow);
      _fnCallbackReg5(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback);
      _fnCallbackReg5(oSettings, "aoFooterCallback", oInit.fnFooterCallback);
      _fnCallbackReg5(oSettings, "aoInitComplete", oInit.fnInitComplete);
      _fnCallbackReg5(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback);
      oSettings.rowIdFn = _fnGetObjectDataFn5(oInit.rowId);
      _fnBrowserDetect5(oSettings);
      var oClasses = oSettings.oClasses;
      $9.extend(oClasses, DataTable5.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.table);
      if (!oSettings.oFeatures.bPaginate) {
        oInit.iDisplayStart = 0;
      }
      if (oSettings.iInitDisplayStart === void 0) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      var oLanguage = oSettings.oLanguage;
      $9.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl) {
        $9.ajax({
          dataType: "json",
          url: oLanguage.sUrl,
          success: function(json) {
            _fnCamelToHungarian5(defaults.oLanguage, json);
            $9.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
            _fnCallbackFire5(oSettings, null, "i18n", [oSettings], true);
            _fnInitialise5(oSettings);
          },
          error: function() {
            _fnLog5(oSettings, 0, "i18n file loading error", 21);
            _fnInitialise5(oSettings);
          }
        });
        bInitHandedOff = true;
      } else {
        _fnCallbackFire5(oSettings, null, "i18n", [oSettings]);
      }
      var columnsInit = [];
      var thead = this.getElementsByTagName("thead");
      var initHeaderLayout = _fnDetectHeader5(oSettings, thead[0]);
      if (oInit.aoColumns) {
        columnsInit = oInit.aoColumns;
      } else if (initHeaderLayout.length) {
        for (i = 0, iLen = initHeaderLayout[0].length; i < iLen; i++) {
          columnsInit.push(null);
        }
      }
      for (i = 0, iLen = columnsInit.length; i < iLen; i++) {
        _fnAddColumn5(oSettings);
      }
      _fnApplyColumnDefs5(oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function(iCol, oDef) {
        _fnColumnOptions5(oSettings, iCol, oDef);
      });
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if (rowOne.length) {
        var a = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $9(rowOne[0]).children("th, td").each(function(i2, cell) {
          var col = oSettings.aoColumns[i2];
          if (!col) {
            _fnLog5(oSettings, 0, "Incorrect column count", 18);
          }
          if (col.mData === i2) {
            var sort = a(cell, "sort") || a(cell, "order");
            var filter = a(cell, "filter") || a(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {
                _: i2 + ".display",
                sort: sort !== null ? i2 + ".@data-" + sort : void 0,
                type: sort !== null ? i2 + ".@data-" + sort : void 0,
                filter: filter !== null ? i2 + ".@data-" + filter : void 0
              };
              col._isArrayHost = true;
              _fnColumnOptions5(oSettings, i2);
            }
          }
        });
      }
      var features = oSettings.oFeatures;
      var loadedInit = function() {
        if (oInit.aaSorting === void 0) {
          var sorting = oSettings.aaSorting;
          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        _fnSortingClasses5(oSettings);
        _fnCallbackReg5(oSettings, "aoDrawCallback", function() {
          if (oSettings.bSorted || _fnDataSource5(oSettings) === "ssp" || features.bDeferRender) {
            _fnSortingClasses5(oSettings);
          }
        });
        var caption = $this.children("caption");
        if (oSettings.caption) {
          if (caption.length === 0) {
            caption = $9("<caption/>").appendTo($this);
          }
          caption.html(oSettings.caption);
        }
        if (caption.length) {
          caption[0]._captionSide = caption.css("caption-side");
          oSettings.captionNode = caption[0];
        }
        if (thead.length === 0) {
          thead = $9("<thead/>").appendTo($this);
        }
        oSettings.nTHead = thead[0];
        $9("tr", thead).addClass(oClasses.thead.row);
        var tbody = $this.children("tbody");
        if (tbody.length === 0) {
          tbody = $9("<tbody/>").insertAfter(thead);
        }
        oSettings.nTBody = tbody[0];
        var tfoot = $this.children("tfoot");
        if (tfoot.length === 0) {
          tfoot = $9("<tfoot/>").appendTo($this);
        }
        oSettings.nTFoot = tfoot[0];
        $9("tr", tfoot).addClass(oClasses.tfoot.row);
        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData5(oSettings, oInit.aaData[i]);
          }
        } else if (_fnDataSource5(oSettings) == "dom") {
          _fnAddTr5(oSettings, $9(oSettings.nTBody).children("tr"));
        }
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        oSettings.bInitialised = true;
        if (bInitHandedOff === false) {
          _fnInitialise5(oSettings);
        }
      };
      _fnCallbackReg5(oSettings, "aoDrawCallback", _fnSaveState5);
      if (oInit.bStateSave) {
        features.bStateSave = true;
        _fnLoadState5(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  DataTable5.ext = _ext5 = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",
    /**
     * Legacy so v1 plug-ins don't throw js errors on load
     */
    feature: [],
    /**
     * Feature plug-ins.
     * 
     * This is an object of callbacks which provide the features for DataTables
     * to be initialised via the `layout` option.
     */
    features: {},
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Automatic column class assignment
       */
      className: {},
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
      /**
       * Automatic renderer assignment
       */
      render: {},
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatibility only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable5.fnVersionCheck,
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable5.version
  };
  $9.extend(_ext5, {
    afnFiltering: _ext5.search,
    aTypes: _ext5.type.detect,
    ofnSearch: _ext5.type.search,
    oSort: _ext5.type.order,
    afnSortData: _ext5.order,
    aoFeatures: _ext5.feature,
    oStdClasses: _ext5.classes,
    oPagination: _ext5.pager
  });
  $9.extend(DataTable5.ext.classes, {
    container: "dt-container",
    empty: {
      row: "dt-empty"
    },
    info: {
      container: "dt-info"
    },
    length: {
      container: "dt-length",
      select: "dt-input"
    },
    order: {
      canAsc: "dt-orderable-asc",
      canDesc: "dt-orderable-desc",
      isAsc: "dt-ordering-asc",
      isDesc: "dt-ordering-desc",
      none: "dt-orderable-none",
      position: "sorting_"
    },
    processing: {
      container: "dt-processing"
    },
    scrolling: {
      body: "dt-scroll-body",
      container: "dt-scroll",
      footer: {
        self: "dt-scroll-foot",
        inner: "dt-scroll-footInner"
      },
      header: {
        self: "dt-scroll-head",
        inner: "dt-scroll-headInner"
      }
    },
    search: {
      container: "dt-search",
      input: "dt-input"
    },
    table: "dataTable",
    tbody: {
      cell: "",
      row: ""
    },
    thead: {
      cell: "",
      row: ""
    },
    tfoot: {
      cell: "",
      row: ""
    },
    paging: {
      active: "current",
      button: "dt-paging-button",
      container: "dt-paging",
      disabled: "disabled"
    }
  });
  var _ext5;
  var _Api5;
  var _api_register5;
  var _api_registerPlural5;
  var _re_dic5 = {};
  var _re_new_lines5 = /[\r\n\u2028]/g;
  var _re_html5 = /<([^>]*>)/g;
  var _max_str_len5 = Math.pow(2, 28);
  var _re_date5 = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;
  var _re_escape_regex5 = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric5 = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty5 = function(d) {
    return !d || d === true || d === "-" ? true : false;
  };
  var _intVal5 = function(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  var _numToDecimal5 = function(num, decimalPoint) {
    if (!_re_dic5[decimalPoint]) {
      _re_dic5[decimalPoint] = new RegExp(_fnEscapeRegex5(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic5[decimalPoint], ".") : num;
  };
  var _isNumber5 = function(d, decimalPoint, formatted) {
    var type = typeof d;
    var strType = type === "string";
    if (type === "number" || type === "bigint") {
      return true;
    }
    if (_empty5(d)) {
      return true;
    }
    if (decimalPoint && strType) {
      d = _numToDecimal5(d, decimalPoint);
    }
    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric5, "");
    }
    return !isNaN(parseFloat(d)) && isFinite(d);
  };
  var _isHtml5 = function(d) {
    return _empty5(d) || typeof d === "string";
  };
  var _htmlNumeric5 = function(d, decimalPoint, formatted) {
    if (_empty5(d)) {
      return true;
    }
    if (typeof d === "string" && d.match(/<(input|select)/i)) {
      return null;
    }
    var html = _isHtml5(d);
    return !html ? null : _isNumber5(_stripHtml5(d), decimalPoint, formatted) ? true : null;
  };
  var _pluck5 = function(a, prop, prop2) {
    var out = [];
    var i = 0, ien = a.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order5 = function(a, order, prop, prop2) {
    var out = [];
    var i = 0, ien = order.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[order[i]]) {
          out.push(a[order[i]][prop]);
        }
      }
    }
    return out;
  };
  var _range5 = function(len, start) {
    var out = [];
    var end;
    if (start === void 0) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }
    for (var i = start; i < end; i++) {
      out.push(i);
    }
    return out;
  };
  var _removeEmpty5 = function(a) {
    var out = [];
    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        out.push(a[i]);
      }
    }
    return out;
  };
  var _stripHtml5 = function(input) {
    if (input.length > _max_str_len5) {
      throw new Error("Exceeded max str len");
    }
    var previous;
    input = input.replace(_re_html5, "");
    do {
      previous = input;
      input = input.replace(/<script/i, "");
    } while (input !== previous);
    return previous;
  };
  var _escapeHtml5 = function(d) {
    if (Array.isArray(d)) {
      d = d.join(",");
    }
    return typeof d === "string" ? d.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d;
  };
  var _normalize5 = function(str, both) {
    if (typeof str !== "string") {
      return str;
    }
    var res = str.normalize("NFD");
    return res.length !== str.length ? (both === true ? str + " " : "") + res.replace(/[\u0300-\u036f]/g, "") : res;
  };
  var _areAllUnique5 = function(src) {
    if (src.length < 2) {
      return true;
    }
    var sorted = src.slice().sort();
    var last = sorted[0];
    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }
      last = sorted[i];
    }
    return true;
  };
  var _unique5 = function(src) {
    if (Array.from && Set) {
      return Array.from(new Set(src));
    }
    if (_areAllUnique5(src)) {
      return src.slice();
    }
    var out = [], val, i, ien = src.length, j, k = 0;
    again: for (i = 0; i < ien; i++) {
      val = src[i];
      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }
      out.push(val);
      k++;
    }
    return out;
  };
  var _flatten5 = function(out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten5(out, val[i]);
      }
    } else {
      out.push(val);
    }
    return out;
  };
  function _addClass5(el, name) {
    if (name) {
      name.split(" ").forEach(function(n) {
        if (n) {
          el.classList.add(n);
        }
      });
    }
  }
  DataTable5.util = {
    /**
     * Return a string with diacritic characters decomposed
     * @param {*} mixed Function or string to normalize
     * @param {*} both Return original string and the normalized string
     * @returns String or undefined
     */
    diacritics: function(mixed, both) {
      var type = typeof mixed;
      if (type !== "function") {
        return _normalize5(mixed, both);
      }
      _normalize5 = mixed;
    },
    /**
     * Debounce a function
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    debounce: function(fn, timeout) {
      var timer;
      return function() {
        var that = this;
        var args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(that, args);
        }, timeout || 250);
      };
    },
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function(fn, freq) {
      var frequency = freq !== void 0 ? freq : 200, last, timer;
      return function() {
        var that = this, now = +/* @__PURE__ */ new Date(), args = arguments;
        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            last = void 0;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },
    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function(val) {
      return val.replace(_re_escape_regex5, "\\$1");
    },
    /**
     * Create a function that will write to a nested object or array
     * @param {*} source JSON notation string
     * @returns Write function
     */
    set: function(source) {
      if ($9.isPlainObject(source)) {
        return DataTable5.util.set(source._);
      } else if (source === null) {
        return function() {
        };
      } else if (typeof source === "function") {
        return function(data, val, meta) {
          source(data, "set", val, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var setData = function(data, val, src) {
          var a = _fnSplitObjNotation5(src), b;
          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;
          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            if (a[i] === "__proto__" || a[i] === "constructor") {
              throw new Error("Cannot set prototype values");
            }
            arrayNotation = a[i].match(__reArray5);
            funcNotation = a[i].match(__reFn5);
            if (arrayNotation) {
              a[i] = a[i].replace(__reArray5, "");
              data[a[i]] = [];
              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join(".");
              if (Array.isArray(val)) {
                for (var j = 0, jLen = val.length; j < jLen; j++) {
                  o = {};
                  setData(o, val[j], innerSrc);
                  data[a[i]].push(o);
                }
              } else {
                data[a[i]] = val;
              }
              return;
            } else if (funcNotation) {
              a[i] = a[i].replace(__reFn5, "");
              data = data[a[i]](val);
            }
            if (data[a[i]] === null || data[a[i]] === void 0) {
              data[a[i]] = {};
            }
            data = data[a[i]];
          }
          if (aLast.match(__reFn5)) {
            data = data[aLast.replace(__reFn5, "")](val);
          } else {
            data[aLast.replace(__reArray5, "")] = val;
          }
        };
        return function(data, val) {
          return setData(data, val, source);
        };
      } else {
        return function(data, val) {
          data[source] = val;
        };
      }
    },
    /**
     * Create a function that will read nested objects from arrays, based on JSON notation
     * @param {*} source JSON notation string
     * @returns Value read
     */
    get: function(source) {
      if ($9.isPlainObject(source)) {
        var o = {};
        $9.each(source, function(key, val) {
          if (val) {
            o[key] = DataTable5.util.get(val);
          }
        });
        return function(data, type, row, meta) {
          var t = o[type] || o._;
          return t !== void 0 ? t(data, type, row, meta) : data;
        };
      } else if (source === null) {
        return function(data) {
          return data;
        };
      } else if (typeof source === "function") {
        return function(data, type, row, meta) {
          return source(data, type, row, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var fetchData = function(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== "") {
            var a = _fnSplitObjNotation5(src);
            for (var i = 0, iLen = a.length; i < iLen; i++) {
              arrayNotation = a[i].match(__reArray5);
              funcNotation = a[i].match(__reFn5);
              if (arrayNotation) {
                a[i] = a[i].replace(__reArray5, "");
                if (a[i] !== "") {
                  data = data[a[i]];
                }
                out = [];
                a.splice(0, i + 1);
                innerSrc = a.join(".");
                if (Array.isArray(data)) {
                  for (var j = 0, jLen = data.length; j < jLen; j++) {
                    out.push(fetchData(data[j], type, innerSrc));
                  }
                }
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join);
                break;
              } else if (funcNotation) {
                a[i] = a[i].replace(__reFn5, "");
                data = data[a[i]]();
                continue;
              }
              if (data === null || data[a[i]] === null) {
                return null;
              } else if (data === void 0 || data[a[i]] === void 0) {
                return void 0;
              }
              data = data[a[i]];
            }
          }
          return data;
        };
        return function(data, type) {
          return fetchData(data, type, source);
        };
      } else {
        return function(data) {
          return data[source];
        };
      }
    },
    stripHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _stripHtml5 = mixed;
        return;
      } else if (type === "string") {
        return _stripHtml5(mixed);
      }
      return mixed;
    },
    escapeHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _escapeHtml5 = mixed;
        return;
      } else if (type === "string" || Array.isArray(mixed)) {
        return _escapeHtml5(mixed);
      }
      return mixed;
    },
    unique: _unique5
  };
  function _fnHungarianMap5(o) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map2 = {};
    $9.each(o, function(key) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map2[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap5(o[key]);
        }
      }
    });
    o._hungarianMap = map2;
  }
  function _fnCamelToHungarian5(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap5(src);
    }
    var hungarianKey;
    $9.each(user, function(key) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $9.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian5(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  var _fnCompatMap5 = function(o, knew, old) {
    if (o[knew] !== void 0) {
      o[old] = o[knew];
    }
  };
  function _fnCompatOpts5(init2) {
    _fnCompatMap5(init2, "ordering", "bSort");
    _fnCompatMap5(init2, "orderMulti", "bSortMulti");
    _fnCompatMap5(init2, "orderClasses", "bSortClasses");
    _fnCompatMap5(init2, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap5(init2, "order", "aaSorting");
    _fnCompatMap5(init2, "orderFixed", "aaSortingFixed");
    _fnCompatMap5(init2, "paging", "bPaginate");
    _fnCompatMap5(init2, "pagingType", "sPaginationType");
    _fnCompatMap5(init2, "pageLength", "iDisplayLength");
    _fnCompatMap5(init2, "searching", "bFilter");
    if (typeof init2.sScrollX === "boolean") {
      init2.sScrollX = init2.sScrollX ? "100%" : "";
    }
    if (typeof init2.scrollX === "boolean") {
      init2.scrollX = init2.scrollX ? "100%" : "";
    }
    var searchCols = init2.aoSearchCols;
    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian5(DataTable5.models.oSearch, searchCols[i]);
        }
      }
    }
    if (init2.serverSide && !init2.searchDelay) {
      init2.searchDelay = 400;
    }
  }
  function _fnCompatCols5(init2) {
    _fnCompatMap5(init2, "orderable", "bSortable");
    _fnCompatMap5(init2, "orderData", "aDataSort");
    _fnCompatMap5(init2, "orderSequence", "asSorting");
    _fnCompatMap5(init2, "orderDataType", "sortDataType");
    var dataSort = init2.aDataSort;
    if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
      init2.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect5(settings) {
    if (!DataTable5.__browser) {
      var browser = {};
      DataTable5.__browser = browser;
      var n = $9("<div/>").css({
        position: "fixed",
        top: 0,
        left: -1 * window.pageXOffset,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(
        $9("<div/>").css({
          position: "absolute",
          top: 1,
          left: 1,
          width: 100,
          overflow: "scroll"
        }).append(
          $9("<div/>").css({
            width: "100%",
            height: 10
          })
        )
      ).appendTo("body");
      var outer = n.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      n.remove();
    }
    $9.extend(settings.oBrowser, DataTable5.__browser);
    settings.oScroll.iBarWidth = DataTable5.__browser.barWidth;
  }
  function _fnAddColumn5(oSettings) {
    var oDefaults = DataTable5.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $9.extend({}, DataTable5.models.oColumn, oDefaults, {
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol,
      searchFixed: {},
      colEl: $9("<col>").attr("data-dt-column", iCol)
    });
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $9.extend({}, DataTable5.models.oSearch, searchCols[iCol]);
  }
  function _fnColumnOptions5(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    if (oOptions !== void 0 && oOptions !== null) {
      _fnCompatCols5(oOptions);
      _fnCamelToHungarian5(DataTable5.defaults.column, oOptions, true);
      if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      var origClass = oCol.sClass;
      $9.extend(oCol, oOptions);
      _fnMap5(oCol, oOptions, "sWidth", "sWidthOrig");
      if (origClass !== oCol.sClass) {
        oCol.sClass = origClass + " " + oCol.sClass;
      }
      if (oOptions.iDataSort !== void 0) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap5(oCol, oOptions, "aDataSort");
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn5(mDataSrc);
    if (oCol.mRender && Array.isArray(oCol.mRender)) {
      var copy = oCol.mRender.slice();
      var name = copy.shift();
      oCol.mRender = DataTable5.render[name].apply(window, copy);
    }
    oCol._render = oCol.mRender ? _fnGetObjectDataFn5(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $9.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, void 0, meta);
      return oCol._render && type ? oCol._render(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn5(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
    }
  }
  function _fnAdjustColumnSizing5(settings) {
    _fnCalculateColumnWidths5(settings);
    _fnColumnSizes5(settings);
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw5(settings);
    }
    _fnCallbackFire5(settings, null, "column-sizing", [settings]);
  }
  function _fnColumnSizes5(settings) {
    var cols = settings.aoColumns;
    for (var i = 0; i < cols.length; i++) {
      var width = _fnColumnsSumWidth5(settings, [i], false, false);
      cols[i].colEl.css("width", width);
    }
  }
  function _fnVisibleToColumnIndex5(oSettings, iMatch) {
    var aiVis = _fnGetColumns5(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible5(oSettings, iMatch) {
    var aiVis = _fnGetColumns5(oSettings, "bVisible");
    var iPos = aiVis.indexOf(iMatch);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns5(settings) {
    var layout = settings.aoHeader;
    var columns = settings.aoColumns;
    var vis = 0;
    if (layout.length) {
      for (var i = 0, ien = layout[0].length; i < ien; i++) {
        if (columns[i].bVisible && $9(layout[0][i].cell).css("display") !== "none") {
          vis++;
        }
      }
    }
    return vis;
  }
  function _fnGetColumns5(oSettings, sParam) {
    var a = [];
    oSettings.aoColumns.map(function(val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  function _fnColumnTypes5(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable5.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, detectedType, cache;
    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            if (!data[k]) {
              continue;
            }
            if (cache[k] === void 0) {
              cache[k] = _fnGetCellData5(settings, k, i, "type");
            }
            detectedType = types[j](cache[k], settings);
            if (!detectedType && j !== types.length - 2) {
              break;
            }
            if (detectedType === "html" && !_empty5(cache[k])) {
              break;
            }
          }
          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        if (!col.sType) {
          col.sType = "string";
        }
      }
      var autoClass = _ext5.type.className[col.sType];
      if (autoClass) {
        _columnAutoClass5(settings.aoHeader, i, autoClass);
        _columnAutoClass5(settings.aoFooter, i, autoClass);
      }
      var renderer = _ext5.type.render[col.sType];
      if (renderer && !col._render) {
        col._render = DataTable5.util.get(renderer);
        _columnAutoRender5(settings, i);
      }
    }
  }
  function _columnAutoRender5(settings, colIdx) {
    var data = settings.aoData;
    for (var i = 0; i < data.length; i++) {
      if (data[i].nTr) {
        var display = _fnGetCellData5(settings, i, colIdx, "display");
        data[i].displayData[colIdx] = display;
        _fnWriteCell5(data[i].anCells[colIdx], display);
      }
    }
  }
  function _columnAutoClass5(container, colIdx, className) {
    container.forEach(function(row) {
      if (row[colIdx] && row[colIdx].unique) {
        _addClass5(row[colIdx].cell, className);
      }
    });
  }
  function _fnApplyColumnDefs5(oSettings, aoColDefs, aoCols, headerLayout, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        if (aoCols[i] && aoCols[i].name) {
          columns[i].sName = aoCols[i].name;
        }
      }
    }
    if (aoColDefs) {
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        var aTargets = def.target !== void 0 ? def.target : def.targets !== void 0 ? def.targets : def.aTargets;
        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          var target = aTargets[j];
          if (typeof target === "number" && target >= 0) {
            while (columns.length <= target) {
              _fnAddColumn5(oSettings);
            }
            fn(target, def);
          } else if (typeof target === "number" && target < 0) {
            fn(columns.length + target, def);
          } else if (typeof target === "string") {
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (target === "_all") {
                fn(k, def);
              } else if (target.indexOf(":name") !== -1) {
                if (columns[k].sName === target.replace(":name", "")) {
                  fn(k, def);
                }
              } else {
                headerLayout.forEach(function(row) {
                  if (row[k]) {
                    var cell = $9(row[k].cell);
                    if (target.match(/^[a-z][\w-]*$/i)) {
                      target = "." + target;
                    }
                    if (cell.is(target)) {
                      fn(k, def);
                    }
                  }
                });
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  function _fnColumnsSumWidth5(settings, targets, original, incVisible) {
    if (!Array.isArray(targets)) {
      targets = _fnColumnsFromHeader5(targets);
    }
    var sum = 0;
    var unit;
    var columns = settings.aoColumns;
    for (var i = 0, ien = targets.length; i < ien; i++) {
      var column = columns[targets[i]];
      var definedWidth = original ? column.sWidthOrig : column.sWidth;
      if (!incVisible && column.bVisible === false) {
        continue;
      }
      if (definedWidth === null || definedWidth === void 0) {
        return null;
      } else if (typeof definedWidth === "number") {
        unit = "px";
        sum += definedWidth;
      } else {
        var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);
        if (matched) {
          sum += matched[1] * 1;
          unit = matched.length === 3 ? matched[2] : "px";
        }
      }
    }
    return sum + unit;
  }
  function _fnColumnsFromHeader5(cell) {
    var attr = $9(cell).closest("[data-dt-column]").attr("data-dt-column");
    if (!attr) {
      return [];
    }
    return attr.split(",").map(function(val) {
      return val * 1;
    });
  }
  function _fnAddData5(settings, dataIn, tr, tds) {
    var rowIdx = settings.aoData.length;
    var rowModel = $9.extend(true, {}, DataTable5.models.oRow, {
      src: tr ? "dom" : "data",
      idx: rowIdx
    });
    rowModel._aData = dataIn;
    settings.aoData.push(rowModel);
    var columns = settings.aoColumns;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    settings.aiDisplayMaster.push(rowIdx);
    var id = settings.rowIdFn(dataIn);
    if (id !== void 0) {
      settings.aIds[id] = rowModel;
    }
    if (tr || !settings.oFeatures.bDeferRender) {
      _fnCreateTr5(settings, rowIdx, tr, tds);
    }
    return rowIdx;
  }
  function _fnAddTr5(settings, trs) {
    var row;
    if (!(trs instanceof $9)) {
      trs = $9(trs);
    }
    return trs.map(function(i, el) {
      row = _fnGetRowElements5(settings, el);
      return _fnAddData5(settings, row.data, el, row.cells);
    });
  }
  function _fnGetCellData5(settings, rowIdx, colIdx, type) {
    if (type === "search") {
      type = "filter";
    } else if (type === "order") {
      type = "sort";
    }
    var row = settings.aoData[rowIdx];
    if (!row) {
      return void 0;
    }
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = row._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings,
      row: rowIdx,
      col: colIdx
    });
    if (type !== "display" && cellData && typeof cellData === "object" && cellData.nodeName) {
      cellData = cellData.innerHTML;
    }
    if (cellData === void 0) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog5(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
      cellData = defaultContent;
    } else if (typeof cellData === "function") {
      return cellData.call(rowData);
    }
    if (cellData === null && type === "display") {
      return "";
    }
    if (type === "filter") {
      var fomatters = DataTable5.ext.type.search;
      if (fomatters[col.sType]) {
        cellData = fomatters[col.sType](cellData);
      }
    }
    return cellData;
  }
  function _fnSetCellData5(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings,
      row: rowIdx,
      col: colIdx
    });
  }
  function _fnWriteCell5(td, val) {
    if (val && typeof val === "object" && val.nodeName) {
      $9(td).empty().append(val);
    } else {
      td.innerHTML = val;
    }
  }
  var __reArray5 = /\[.*?\]$/;
  var __reFn5 = /\(\)$/;
  function _fnSplitObjNotation5(str) {
    var parts = str.match(/(\\.|[^.])+/g) || [""];
    return parts.map(function(s) {
      return s.replace(/\\\./g, ".");
    });
  }
  var _fnGetObjectDataFn5 = DataTable5.util.get;
  var _fnSetObjectDataFn5 = DataTable5.util.set;
  function _fnGetDataMaster5(settings) {
    return _pluck5(settings.aoData, "_aData");
  }
  function _fnClearTable5(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnInvalidate5(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;
    row._aSortData = null;
    row._aFilterData = null;
    row.displayData = null;
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements5(
        settings,
        row,
        colIdx,
        colIdx === void 0 ? void 0 : row._aData
      ).data;
    } else {
      var cells = row.anCells;
      var display = _fnGetRowDisplay5(settings, rowIdx);
      if (cells) {
        if (colIdx !== void 0) {
          _fnWriteCell5(cells[colIdx], display[colIdx]);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            _fnWriteCell5(cells[i], display[i]);
          }
        }
      }
    }
    var cols = settings.aoColumns;
    if (colIdx !== void 0) {
      cols[colIdx].sType = null;
      cols[colIdx].maxLenString = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
        cols[i].maxLenString = null;
      }
      _fnRowAttributes5(settings, row);
    }
  }
  function _fnGetRowElements5(settings, row, colIdx, d) {
    var tds = [], td = row.firstChild, name, col, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d = d !== void 0 ? d : objectRead ? {} : [];
    var attr = function(str, td2) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr2 = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn5(str);
          setter(d, td2.getAttribute(attr2));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === void 0 || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn5(col.mData._);
          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn5(col.mData);
            }
            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }
      i++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn5(settings.rowId)(d, id);
      }
    }
    return {
      data: d,
      cells: tds
    };
  }
  function _fnGetRowDisplay5(settings, rowIdx) {
    let rowModal = settings.aoData[rowIdx];
    let columns = settings.aoColumns;
    if (!rowModal.displayData) {
      rowModal.displayData = [];
      for (var colIdx = 0, len = columns.length; colIdx < len; colIdx++) {
        rowModal.displayData.push(
          _fnGetCellData5(settings, rowIdx, colIdx, "display")
        );
      }
    }
    return rowModal.displayData;
  }
  function _fnCreateTr5(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create, trClass = oSettings.oClasses.tbody.row;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      _addClass5(nTr, trClass);
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes5(oSettings, row);
      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn && anTds[i] ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        if (!nTd) {
          _fnLog5(oSettings, 0, "Incorrect column count", 18);
        }
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd);
        var display = _fnGetRowDisplay5(oSettings, iRow);
        if (create || (oCol.mRender || oCol.mData !== i) && (!$9.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
          _fnWriteCell5(nTd, display[i]);
        }
        if (oCol.bVisible && create) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && !create) {
          nTd.parentNode.removeChild(nTd);
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(
            oSettings.oInstance,
            nTd,
            _fnGetCellData5(oSettings, iRow, i),
            rowData,
            iRow,
            i
          );
        }
      }
      _fnCallbackFire5(oSettings, "aoRowCreatedCallback", "row-created", [nTr, rowData, iRow, cells]);
    } else {
      _addClass5(row.nTr, trClass);
    }
  }
  function _fnRowAttributes5(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique5(row.__rowc.concat(a)) : a;
        $9(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $9(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $9(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead5(settings, side) {
    var classes = settings.oClasses;
    var columns = settings.aoColumns;
    var i, ien, row;
    var target = side === "header" ? settings.nTHead : settings.nTFoot;
    var titleProp = side === "header" ? "sTitle" : side;
    if (!target) {
      return;
    }
    if (side === "header" || _pluck5(settings.aoColumns, titleProp).join("")) {
      row = $9("tr", target);
      if (!row.length) {
        row = $9("<tr/>").appendTo(target);
      }
      if (row.length === 1) {
        var cells = $9("td, th", row);
        for (i = cells.length, ien = columns.length; i < ien; i++) {
          $9("<th/>").html(columns[i][titleProp] || "").appendTo(row);
        }
      }
    }
    var detected = _fnDetectHeader5(settings, target, true);
    if (side === "header") {
      settings.aoHeader = detected;
    } else {
      settings.aoFooter = detected;
    }
    $9(target).children("tr").attr("role", "row");
    $9(target).children("tr").children("th, td").each(function() {
      _fnRenderer5(settings, side)(
        settings,
        $9(this),
        classes
      );
    });
  }
  function _fnHeaderLayout5(settings, source, incColumns) {
    var row, column, cell;
    var local = [];
    var structure = [];
    var columns = settings.aoColumns;
    var columnCount = columns.length;
    var rowspan, colspan;
    if (!source) {
      return;
    }
    if (!incColumns) {
      incColumns = _range5(columnCount).filter(function(idx) {
        return columns[idx].bVisible;
      });
    }
    for (row = 0; row < source.length; row++) {
      local[row] = source[row].slice().filter(function(cell2, i) {
        return incColumns.includes(i);
      });
      structure.push([]);
    }
    for (row = 0; row < local.length; row++) {
      for (column = 0; column < local[row].length; column++) {
        rowspan = 1;
        colspan = 1;
        if (structure[row][column] === void 0) {
          cell = local[row][column].cell;
          while (local[row + rowspan] !== void 0 && local[row][column].cell == local[row + rowspan][column].cell) {
            structure[row + rowspan][column] = null;
            rowspan++;
          }
          while (local[row][column + colspan] !== void 0 && local[row][column].cell == local[row][column + colspan].cell) {
            for (var k = 0; k < rowspan; k++) {
              structure[row + k][column + colspan] = null;
            }
            colspan++;
          }
          var titleSpan = $9("span.dt-column-title", cell);
          structure[row][column] = {
            cell,
            colspan,
            rowspan,
            title: titleSpan.length ? titleSpan.html() : $9(cell).html()
          };
        }
      }
    }
    return structure;
  }
  function _fnDrawHead5(settings, source) {
    var layout = _fnHeaderLayout5(settings, source);
    var tr, n;
    for (var row = 0; row < source.length; row++) {
      tr = source[row].row;
      if (tr) {
        while (n = tr.firstChild) {
          tr.removeChild(n);
        }
      }
      for (var column = 0; column < layout[row].length; column++) {
        var point = layout[row][column];
        if (point) {
          $9(point.cell).appendTo(tr).attr("rowspan", point.rowspan).attr("colspan", point.colspan);
        }
      }
    }
  }
  function _fnDraw5(oSettings, ajaxComplete) {
    _fnStart5(oSettings);
    var aPreDraw = _fnCallbackFire5(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if (aPreDraw.indexOf(false) !== -1) {
      _fnProcessingDisplay5(oSettings, false);
      return;
    }
    var anRows = [];
    var iRowCount = 0;
    var bServerSide = _fnDataSource5(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    var columns = oSettings.aoColumns;
    var body = $9(oSettings.nTBody);
    oSettings.bDrawing = true;
    if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !ajaxComplete) {
      if (oSettings.iDraw === 0) {
        body.empty().append(_emptyRow5(oSettings));
      }
      _fnAjaxUpdate5(oSettings);
      return;
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr5(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        for (var i = 0; i < columns.length; i++) {
          var col = columns[i];
          var td = aoData.anCells[i];
          _addClass5(td, _ext5.type.className[col.sType]);
          _addClass5(td, col.sClass);
          _addClass5(td, oSettings.oClasses.tbody.cell);
        }
        _fnCallbackFire5(
          oSettings,
          "aoRowCallback",
          null,
          [nRow, aoData._aData, iRowCount, j, iDataIndex]
        );
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      anRows[0] = _emptyRow5(oSettings);
    }
    _fnCallbackFire5(oSettings, "aoHeaderCallback", "header", [
      $9(oSettings.nTHead).children("tr")[0],
      _fnGetDataMaster5(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    _fnCallbackFire5(oSettings, "aoFooterCallback", "footer", [
      $9(oSettings.nTFoot).children("tr")[0],
      _fnGetDataMaster5(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    if (body[0].replaceChildren) {
      body[0].replaceChildren.apply(body[0], anRows);
    } else {
      body.children().detach();
      body.append($9(anRows));
    }
    $9(oSettings.nTableWrapper).toggleClass("dt-empty-footer", $9("tr", oSettings.nTFoot).length === 0);
    _fnCallbackFire5(oSettings, "aoDrawCallback", "draw", [oSettings], true);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw5(settings, holdPosition, recompute) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (recompute === void 0 || recompute === true) {
      if (sort) {
        _fnSort5(settings);
      }
      if (filter) {
        _fnFilterComplete5(settings, settings.oPreviousSearch);
      } else {
        settings.aiDisplay = settings.aiDisplayMaster.slice();
      }
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw5(settings);
    settings._drawHold = false;
  }
  function _emptyRow5(settings) {
    var oLang = settings.oLanguage;
    var zero = oLang.sZeroRecords;
    var dataSrc = _fnDataSource5(settings);
    if (settings.iDraw < 1 && dataSrc === "ssp" || settings.iDraw <= 1 && dataSrc === "ajax") {
      zero = oLang.sLoadingRecords;
    } else if (oLang.sEmptyTable && settings.fnRecordsTotal() === 0) {
      zero = oLang.sEmptyTable;
    }
    return $9("<tr/>").append($9("<td />", {
      "colSpan": _fnVisbleColumns5(settings),
      "class": settings.oClasses.empty.row
    }).html(zero))[0];
  }
  function _layoutArray5(settings, layout, side) {
    var groups = {};
    $9.each(layout, function(pos, val) {
      if (val === null) {
        return;
      }
      var splitPos = pos.replace(/([A-Z])/g, " $1").split(" ");
      if (!groups[splitPos[0]]) {
        groups[splitPos[0]] = {};
      }
      var align = splitPos.length === 1 ? "full" : splitPos[1].toLowerCase();
      var group = groups[splitPos[0]];
      var groupRun = function(contents, innerVal) {
        if ($9.isPlainObject(innerVal)) {
          Object.keys(innerVal).map(function(key) {
            contents.push({
              feature: key,
              opts: innerVal[key]
            });
          });
        } else {
          contents.push(innerVal);
        }
      };
      if (!group[align] || !group[align].contents) {
        group[align] = { contents: [] };
      }
      if (Array.isArray(val)) {
        for (var i2 = 0; i2 < val.length; i2++) {
          groupRun(group[align].contents, val[i2]);
        }
      } else {
        groupRun(group[align].contents, val);
      }
      if (!Array.isArray(group[align].contents)) {
        group[align].contents = [group[align].contents];
      }
    });
    var filtered = Object.keys(groups).map(function(pos) {
      if (pos.indexOf(side) !== 0) {
        return null;
      }
      return {
        name: pos,
        val: groups[pos]
      };
    }).filter(function(item) {
      return item !== null;
    });
    filtered.sort(function(a, b) {
      var order1 = a.name.replace(/[^0-9]/g, "") * 1;
      var order2 = b.name.replace(/[^0-9]/g, "") * 1;
      return order2 - order1;
    });
    if (side === "bottom") {
      filtered.reverse();
    }
    var rows = [];
    for (var i = 0, ien = filtered.length; i < ien; i++) {
      if (filtered[i].val.full) {
        rows.push({ full: filtered[i].val.full });
        _layoutResolve5(settings, rows[rows.length - 1]);
        delete filtered[i].val.full;
      }
      if (Object.keys(filtered[i].val).length) {
        rows.push(filtered[i].val);
        _layoutResolve5(settings, rows[rows.length - 1]);
      }
    }
    return rows;
  }
  function _layoutResolve5(settings, row) {
    var getFeature = function(feature, opts) {
      if (!_ext5.features[feature]) {
        _fnLog5(settings, 0, "Unknown feature: " + feature);
      }
      return _ext5.features[feature].apply(this, [settings, opts]);
    };
    var resolve = function(item) {
      var line = row[item].contents;
      for (var i = 0, ien = line.length; i < ien; i++) {
        if (!line[i]) {
          continue;
        } else if (typeof line[i] === "string") {
          line[i] = getFeature(line[i], null);
        } else if ($9.isPlainObject(line[i])) {
          line[i] = getFeature(line[i].feature, line[i].opts);
        } else if (typeof line[i].node === "function") {
          line[i] = line[i].node(settings);
        } else if (typeof line[i] === "function") {
          var inst = line[i](settings);
          line[i] = typeof inst.node === "function" ? inst.node() : inst;
        }
      }
    };
    $9.each(row, function(key) {
      resolve(key);
    });
  }
  function _fnAddOptionsHtml5(settings) {
    var classes = settings.oClasses;
    var table = $9(settings.nTable);
    var insert = $9("<div/>").attr({
      id: settings.sTableId + "_wrapper",
      "class": classes.container
    }).insertBefore(table);
    settings.nTableWrapper = insert[0];
    if (settings.sDom) {
      _fnLayoutDom5(settings, settings.sDom, insert);
    } else {
      var top = _layoutArray5(settings, settings.layout, "top");
      var bottom = _layoutArray5(settings, settings.layout, "bottom");
      var renderer = _fnRenderer5(settings, "layout");
      top.forEach(function(item) {
        renderer(settings, insert, item);
      });
      renderer(settings, insert, {
        full: {
          table: true,
          contents: [_fnFeatureHtmlTable5(settings)]
        }
      });
      bottom.forEach(function(item) {
        renderer(settings, insert, item);
      });
    }
    _processingHtml5(settings);
  }
  function _fnLayoutDom5(settings, dom, insert) {
    var parts = dom.match(/(".*?")|('.*?')|./g);
    var featureNode, option, newNode, next, attr;
    for (var i = 0; i < parts.length; i++) {
      featureNode = null;
      option = parts[i];
      if (option == "<") {
        newNode = $9("<div/>");
        next = parts[i + 1];
        if (next[0] == "'" || next[0] == '"') {
          attr = next.replace(/['"]/g, "");
          var id = "", className;
          if (attr.indexOf(".") != -1) {
            var split = attr.split(".");
            id = split[0];
            className = split[1];
          } else if (attr[0] == "#") {
            id = attr;
          } else {
            className = attr;
          }
          newNode.attr("id", id.substring(1)).addClass(className);
          i++;
        }
        insert.append(newNode);
        insert = newNode;
      } else if (option == ">") {
        insert = insert.parent();
      } else if (option == "t") {
        featureNode = _fnFeatureHtmlTable5(settings);
      } else {
        DataTable5.ext.feature.forEach(function(feature) {
          if (option == feature.cFeature) {
            featureNode = feature.fnInit(settings);
          }
        });
      }
      if (featureNode) {
        insert.append(featureNode);
      }
    }
  }
  function _fnDetectHeader5(settings, thead, write) {
    var columns = settings.aoColumns;
    var rows = $9(thead).children("tr");
    var row, cell;
    var i, k, l, iLen, shifted, column, colspan, rowspan;
    var isHeader = thead && thead.nodeName.toLowerCase() === "thead";
    var layout = [];
    var unique;
    var shift = function(a, i2, j) {
      var k2 = a[i2];
      while (k2[j]) {
        j++;
      }
      return j;
    };
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      layout.push([]);
    }
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      row = rows[i];
      column = 0;
      cell = row.firstChild;
      while (cell) {
        if (cell.nodeName.toUpperCase() == "TD" || cell.nodeName.toUpperCase() == "TH") {
          var cols = [];
          colspan = cell.getAttribute("colspan") * 1;
          rowspan = cell.getAttribute("rowspan") * 1;
          colspan = !colspan || colspan === 0 || colspan === 1 ? 1 : colspan;
          rowspan = !rowspan || rowspan === 0 || rowspan === 1 ? 1 : rowspan;
          shifted = shift(layout, i, column);
          unique = colspan === 1 ? true : false;
          if (write) {
            if (unique) {
              _fnColumnOptions5(settings, shifted, $9(cell).data());
              var columnDef = columns[shifted];
              var width = cell.getAttribute("width") || null;
              var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
              if (t) {
                width = t[1];
              }
              columnDef.sWidthOrig = columnDef.sWidth || width;
              if (isHeader) {
                if (columnDef.sTitle !== null && !columnDef.autoTitle) {
                  cell.innerHTML = columnDef.sTitle;
                }
                if (!columnDef.sTitle && unique) {
                  columnDef.sTitle = _stripHtml5(cell.innerHTML);
                  columnDef.autoTitle = true;
                }
              } else {
                if (columnDef.footer) {
                  cell.innerHTML = columnDef.footer;
                }
              }
              if (!columnDef.ariaTitle) {
                columnDef.ariaTitle = $9(cell).attr("aria-label") || columnDef.sTitle;
              }
              if (columnDef.className) {
                $9(cell).addClass(columnDef.className);
              }
            }
            if ($9("span.dt-column-title", cell).length === 0) {
              $9("<span>").addClass("dt-column-title").append(cell.childNodes).appendTo(cell);
            }
            if (isHeader && $9("span.dt-column-order", cell).length === 0) {
              $9("<span>").addClass("dt-column-order").appendTo(cell);
            }
          }
          for (l = 0; l < colspan; l++) {
            for (k = 0; k < rowspan; k++) {
              layout[i + k][shifted + l] = {
                cell,
                unique
              };
              layout[i + k].row = row;
            }
            cols.push(shifted + l);
          }
          cell.setAttribute("data-dt-column", _unique5(cols).join(","));
        }
        cell = cell.nextSibling;
      }
    }
    return layout;
  }
  function _fnStart5(oSettings) {
    var bServerSide = _fnDataSource5(oSettings) == "ssp";
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
  }
  function _fnBuildAjax5(oSettings, data, fn) {
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
      if (json === null || typeof status === "number" && status == 204) {
        json = {};
        _fnAjaxDataSrc5(oSettings, json, []);
      }
      var error = json.error || json.sError;
      if (error) {
        _fnLog5(oSettings, 0, error);
      }
      oSettings.json = json;
      _fnCallbackFire5(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR], true);
      fn(json);
    };
    if ($9.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === "function" ? ajaxData(data, oSettings) : (
        // fn can manipulate data or return
        ajaxData
      );
      data = typeof ajaxData === "function" && newData ? newData : $9.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {
      "url": typeof ajax === "string" ? ajax : "",
      "data": data,
      "success": callback,
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function(xhr, error) {
        var ret = _fnCallbackFire5(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR], true);
        if (ret.indexOf(true) === -1) {
          if (error == "parsererror") {
            _fnLog5(oSettings, 0, "Invalid JSON response", 1);
          } else if (xhr.readyState === 4) {
            _fnLog5(oSettings, 0, "Ajax error", 7);
          }
        }
        _fnProcessingDisplay5(oSettings, false);
      }
    };
    if ($9.isPlainObject(ajax)) {
      $9.extend(baseAjax, ajax);
    }
    oSettings.oAjaxData = data;
    _fnCallbackFire5(oSettings, null, "preXhr", [oSettings, data, baseAjax], true);
    if (typeof ajax === "function") {
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else if (ajax.url === "") {
      var empty = {};
      DataTable5.util.set(ajax.dataSrc)(empty, []);
      callback(empty);
    } else {
      oSettings.jqXHR = $9.ajax(baseAjax);
      if (ajaxData) {
        ajax.data = ajaxData;
      }
    }
  }
  function _fnAjaxUpdate5(settings) {
    settings.iDraw++;
    _fnProcessingDisplay5(settings, true);
    _fnBuildAjax5(
      settings,
      _fnAjaxParameters5(settings),
      function(json) {
        _fnAjaxUpdateDraw5(settings, json);
      }
    );
  }
  function _fnAjaxParameters5(settings) {
    var columns = settings.aoColumns, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, colData = function(idx, prop) {
      return typeof columns[idx][prop] === "function" ? "function" : columns[idx][prop];
    };
    return {
      draw: settings.iDraw,
      columns: columns.map(function(column, i) {
        return {
          data: colData(i, "mData"),
          name: column.sName,
          searchable: column.bSearchable,
          orderable: column.bSortable,
          search: {
            value: preColSearch[i].search,
            regex: preColSearch[i].regex,
            fixed: Object.keys(column.searchFixed).map(function(name) {
              return {
                name,
                term: column.searchFixed[name].toString()
              };
            })
          }
        };
      }),
      order: _fnSortFlatten5(settings).map(function(val) {
        return {
          column: val.col,
          dir: val.dir,
          name: colData(val.col, "sName")
        };
      }),
      start: settings._iDisplayStart,
      length: features.bPaginate ? settings._iDisplayLength : -1,
      search: {
        value: preSearch.search,
        regex: preSearch.regex,
        fixed: Object.keys(settings.searchFixed).map(function(name) {
          return {
            name,
            term: settings.searchFixed[name].toString()
          };
        })
      }
    };
  }
  function _fnAjaxUpdateDraw5(settings, json) {
    var data = _fnAjaxDataSrc5(settings, json);
    var draw = _fnAjaxDataSrcParam5(settings, "draw", json);
    var recordsTotal = _fnAjaxDataSrcParam5(settings, "recordsTotal", json);
    var recordsFiltered = _fnAjaxDataSrcParam5(settings, "recordsFiltered", json);
    if (draw !== void 0) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    if (!data) {
      data = [];
    }
    _fnClearTable5(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData5(settings, data[i]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnDraw5(settings, true);
    _fnInitComplete5(settings);
    _fnProcessingDisplay5(settings, false);
  }
  function _fnAjaxDataSrc5(settings, json, write) {
    var dataProp = "data";
    if ($9.isPlainObject(settings.ajax) && settings.ajax.dataSrc !== void 0) {
      var dataSrc = settings.ajax.dataSrc;
      if (typeof dataSrc === "string" || typeof dataSrc === "function") {
        dataProp = dataSrc;
      } else if (dataSrc.data !== void 0) {
        dataProp = dataSrc.data;
      }
    }
    if (!write) {
      if (dataProp === "data") {
        return json.aaData || json[dataProp];
      }
      return dataProp !== "" ? _fnGetObjectDataFn5(dataProp)(json) : json;
    }
    _fnSetObjectDataFn5(dataProp)(json, write);
  }
  function _fnAjaxDataSrcParam5(settings, param, json) {
    var dataSrc = $9.isPlainObject(settings.ajax) ? settings.ajax.dataSrc : null;
    if (dataSrc && dataSrc[param]) {
      return _fnGetObjectDataFn5(dataSrc[param])(json);
    }
    var old = "";
    if (param === "draw") {
      old = "sEcho";
    } else if (param === "recordsTotal") {
      old = "iTotalRecords";
    } else if (param === "recordsFiltered") {
      old = "iTotalDisplayRecords";
    }
    return json[old] !== void 0 ? json[old] : json[param];
  }
  function _fnFilterComplete5(settings, input) {
    var columnsSearch = settings.aoPreSearchCols;
    _fnColumnTypes5(settings);
    if (_fnDataSource5(settings) != "ssp") {
      _fnFilterData5(settings);
      settings.aiDisplay = settings.aiDisplayMaster.slice();
      _fnFilter5(settings.aiDisplay, settings, input.search, input);
      $9.each(settings.searchFixed, function(name, term) {
        _fnFilter5(settings.aiDisplay, settings, term, {});
      });
      for (var i = 0; i < columnsSearch.length; i++) {
        var col = columnsSearch[i];
        _fnFilter5(
          settings.aiDisplay,
          settings,
          col.search,
          col,
          i
        );
        $9.each(settings.aoColumns[i].searchFixed, function(name, term) {
          _fnFilter5(settings.aiDisplay, settings, term, {}, i);
        });
      }
      _fnFilterCustom5(settings);
    }
    settings.bFiltered = true;
    _fnCallbackFire5(settings, null, "search", [settings]);
  }
  function _fnFilterCustom5(settings) {
    var filters = DataTable5.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = [];
      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];
        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      displayRows.push.apply(displayRows, rows);
    }
  }
  function _fnFilter5(searchRows, settings, input, options, column) {
    if (input === "") {
      return;
    }
    var i = 0;
    var searchFunc = typeof input === "function" ? input : null;
    var rpSearch = input instanceof RegExp ? input : searchFunc ? null : _fnFilterCreateSearch5(input, options);
    while (i < searchRows.length) {
      var row = settings.aoData[searchRows[i]];
      var data = column === void 0 ? row._sFilterRow : row._aFilterData[column];
      if (searchFunc && !searchFunc(data, row._aData, searchRows[i], column) || rpSearch && !rpSearch.test(data)) {
        searchRows.splice(i, 1);
        i--;
      }
      i++;
    }
  }
  function _fnFilterCreateSearch5(search, inOpts) {
    var not = [];
    var options = $9.extend({}, {
      boundary: false,
      caseInsensitive: true,
      exact: false,
      regex: false,
      smart: true
    }, inOpts);
    if (typeof search !== "string") {
      search = search.toString();
    }
    search = _normalize5(search);
    if (options.exact) {
      return new RegExp(
        "^" + _fnEscapeRegex5(search) + "$",
        options.caseInsensitive ? "i" : ""
      );
    }
    search = options.regex ? search : _fnEscapeRegex5(search);
    if (options.smart) {
      var parts = search.match(/!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""];
      var a = parts.map(function(word) {
        var negative = false;
        var m2;
        if (word.charAt(0) === "!") {
          negative = true;
          word = word.substring(1);
        }
        if (word.charAt(0) === '"') {
          m2 = word.match(/^"(.*)"$/);
          word = m2 ? m2[1] : word;
        } else if (word.charAt(0) === "\u201C") {
          m2 = word.match(/^\u201C(.*)\u201D$/);
          word = m2 ? m2[1] : word;
        }
        if (negative) {
          if (word.length > 1) {
            not.push("(?!" + word + ")");
          }
          word = "";
        }
        return word.replace(/"/g, "");
      });
      var match = not.length ? not.join("") : "";
      var boundary = options.boundary ? "\\b" : "";
      search = "^(?=.*?" + boundary + a.join(")(?=.*?" + boundary) + ")(" + match + ".)*$";
    }
    return new RegExp(search, options.caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex5 = DataTable5.util.escapeRegex;
  var __filter_div5 = $9("<div>")[0];
  var __filter_div_textContent5 = __filter_div5.textContent !== void 0;
  function _fnFilterData5(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var column;
    var j, jen, filterData, cellData, row;
    var wasInvalidated = false;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aFilterData) {
        filterData = [];
        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];
          if (column.bSearchable) {
            cellData = _fnGetCellData5(settings, rowIdx, j, "filter");
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div5.innerHTML = cellData;
            cellData = __filter_div_textContent5 ? __filter_div5.textContent : __filter_div5.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnInitialise5(settings) {
    var i, iAjaxStart = settings.iInitDisplayStart;
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise5(settings);
      }, 200);
      return;
    }
    _fnBuildHead5(settings, "header");
    _fnBuildHead5(settings, "footer");
    _fnDrawHead5(settings, settings.aoHeader);
    _fnDrawHead5(settings, settings.aoFooter);
    _fnAddOptionsHtml5(settings);
    _fnSortInit5(settings);
    _colGroup5(settings);
    _fnProcessingDisplay5(settings, true);
    _fnCallbackFire5(settings, null, "preInit", [settings], true);
    _fnReDraw5(settings);
    var dataSrc = _fnDataSource5(settings);
    if (dataSrc != "ssp") {
      if (dataSrc == "ajax") {
        _fnBuildAjax5(settings, {}, function(json) {
          var aData = _fnAjaxDataSrc5(settings, json);
          for (i = 0; i < aData.length; i++) {
            _fnAddData5(settings, aData[i]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw5(settings);
          _fnProcessingDisplay5(settings, false);
          _fnInitComplete5(settings);
        }, settings);
      } else {
        _fnInitComplete5(settings);
        _fnProcessingDisplay5(settings, false);
      }
    }
  }
  function _fnInitComplete5(settings) {
    if (settings._bInitComplete) {
      return;
    }
    var args = [settings, settings.json];
    settings._bInitComplete = true;
    _fnAdjustColumnSizing5(settings);
    _fnCallbackFire5(settings, null, "plugin-init", args, true);
    _fnCallbackFire5(settings, "aoInitComplete", "init", args, true);
  }
  function _fnLengthChange5(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow5(settings);
    _fnCallbackFire5(settings, null, "length", [settings, len]);
  }
  function _fnPageChange5(settings, action, redraw) {
    var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;
      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;
      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else if (action === "ellipsis") {
      return;
    } else {
      _fnLog5(settings, 0, "Unknown paging action: " + action, 5);
    }
    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;
    _fnCallbackFire5(settings, null, changed ? "page" : "page-nc", [settings]);
    if (changed && redraw) {
      _fnDraw5(settings);
    }
    return changed;
  }
  function _processingHtml5(settings) {
    var table = settings.nTable;
    if (settings.oFeatures.bProcessing) {
      var n = $9("<div/>", {
        "id": settings.sTableId + "_processing",
        "class": settings.oClasses.processing.container,
        "role": "status"
      }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>").insertBefore(table);
      $9(table).on("processing.dt.DT", function(e, s, show) {
        n.css("display", show ? "block" : "none");
      });
    }
  }
  function _fnProcessingDisplay5(settings, show) {
    _fnCallbackFire5(settings, null, "processing", [settings, show]);
  }
  function _fnFeatureHtmlTable5(settings) {
    var table = $9(settings.nTable);
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses.scrolling;
    var caption = settings.captionNode;
    var captionSide = caption ? caption._captionSide : null;
    var headerClone = $9(table[0].cloneNode(false));
    var footerClone = $9(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size = function(s) {
      return !s ? null : _fnStringToCss5(s);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $9(_div, { "class": classes.container }).append(
      $9(_div, { "class": classes.header.self }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: scrollX ? size(scrollX) : "100%"
      }).append(
        $9(_div, { "class": classes.header.inner }).css({
          "box-sizing": "content-box",
          width: scroll.sXInner || "100%"
        }).append(
          headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
            table.children("thead")
          )
        )
      )
    ).append(
      $9(_div, { "class": classes.body }).css({
        position: "relative",
        overflow: "auto",
        width: size(scrollX)
      }).append(table)
    );
    if (footer) {
      scroller.append(
        $9(_div, { "class": classes.footer.self }).css({
          overflow: "hidden",
          border: 0,
          width: scrollX ? size(scrollX) : "100%"
        }).append(
          $9(_div, { "class": classes.footer.inner }).append(
            footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
              table.children("tfoot")
            )
          )
        )
      );
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    $9(scrollBody).on("scroll.DT", function() {
      var scrollLeft = this.scrollLeft;
      scrollHead.scrollLeft = scrollLeft;
      if (footer) {
        scrollFoot.scrollLeft = scrollLeft;
      }
    });
    $9("th, td", scrollHead).on("focus", function() {
      var scrollLeft = scrollHead.scrollLeft;
      scrollBody.scrollLeft = scrollLeft;
      if (footer) {
        scrollBody.scrollLeft = scrollLeft;
      }
    });
    $9(scrollBody).css("max-height", scrollY);
    if (!scroll.bCollapse) {
      $9(scrollBody).css("height", scrollY);
    }
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push(_fnScrollDraw5);
    return scroller[0];
  }
  function _fnScrollDraw5(settings) {
    var scroll = settings.oScroll, barWidth = scroll.iBarWidth, divHeader = $9(settings.nScrollHead), divHeaderInner = divHeader.children("div"), divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $9(divBodyEl), divFooter = $9(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $9(settings.nTHead), table = $9(settings.nTable), footer = settings.nTFoot && $9("th, td", settings.nTFoot).length ? $9(settings.nTFoot) : null, browser = settings.oBrowser, headerCopy, footerCopy;
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing5(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    headerCopy = header.clone().prependTo(table);
    headerCopy.find("th, td").removeAttr("tabindex");
    headerCopy.find("[id]").removeAttr("id");
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerCopy.find("[id]").removeAttr("id");
    }
    if (settings.aiDisplay.length) {
      var colSizes = table.find("tbody tr").eq(0).find("th, td").map(function(vis) {
        return {
          idx: _fnVisibleToColumnIndex5(settings, vis),
          width: $9(this).outerWidth()
        };
      });
      for (var i = 0; i < colSizes.length; i++) {
        var colEl = settings.aoColumns[colSizes[i].idx].colEl[0];
        var colWidth = colEl.style.width.replace("px", "");
        if (colWidth !== colSizes[i].width) {
          colEl.style.width = colSizes[i].width + "px";
        }
      }
    }
    divHeaderTable.find("colgroup").remove();
    divHeaderTable.append(settings.colgroup.clone());
    if (footer) {
      divFooterTable.find("colgroup").remove();
      divFooterTable.append(settings.colgroup.clone());
    }
    $9("th, td", headerCopy).each(function() {
      $9(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
    });
    if (footer) {
      $9("th, td", footerCopy).each(function() {
        $9(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
      });
    }
    var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var paddingSide = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    var outerWidth = table.outerWidth();
    divHeaderTable.css("width", _fnStringToCss5(outerWidth));
    divHeaderInner.css("width", _fnStringToCss5(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    if (footer) {
      divFooterTable.css("width", _fnStringToCss5(outerWidth));
      divFooterInner.css("width", _fnStringToCss5(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    }
    table.children("colgroup").prependTo(table);
    divBody.trigger("scroll");
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnCalculateColumnWidths5(settings) {
    if (!settings.oFeatures.bAutoWidth) {
      return;
    }
    var table = settings.nTable, columns = settings.aoColumns, scroll = settings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, visibleColumns = _fnGetColumns5(settings, "bVisible"), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, i, column, columnIdx;
    var styleWidth = table.style.width;
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    _fnCallbackFire5(
      settings,
      null,
      "column-calc",
      { visible: visibleColumns },
      false
    );
    var tmpTable = $9(table.cloneNode()).css("visibility", "hidden").removeAttr("id");
    tmpTable.append("<tbody>");
    var tr = $9("<tr/>").appendTo(tmpTable.find("tbody"));
    tmpTable.append($9(settings.nTHead).clone()).append($9(settings.nTFoot).clone());
    tmpTable.find("tfoot th, tfoot td").css("width", "");
    tmpTable.find("thead th, thead td").each(function() {
      var width = _fnColumnsSumWidth5(settings, this, true, false);
      if (width) {
        this.style.width = width;
        if (scrollX) {
          $9(this).append($9("<div/>").css({
            width,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } else {
        this.style.width = "";
      }
    });
    for (i = 0; i < visibleColumns.length; i++) {
      columnIdx = visibleColumns[i];
      column = columns[columnIdx];
      var longest = _fnGetMaxLenString5(settings, columnIdx);
      var autoClass = _ext5.type.className[column.sType];
      var text = longest + column.sContentPadding;
      var insert = longest.indexOf("<") === -1 ? document.createTextNode(text) : text;
      $9("<td/>").addClass(autoClass).addClass(column.sClass).append(insert).appendTo(tr);
    }
    $9("[name]", tmpTable).removeAttr("name");
    var holder = $9("<div/>").css(
      scrollX || scrollY ? {
        position: "absolute",
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: "hidden"
      } : {}
    ).append(tmpTable).appendTo(tableContainer);
    if (scrollX && scrollXInner) {
      tmpTable.width(scrollXInner);
    } else if (scrollX) {
      tmpTable.css("width", "auto");
      tmpTable.removeAttr("width");
      if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
        tmpTable.width(tableContainer.clientWidth);
      }
    } else if (scrollY) {
      tmpTable.width(tableContainer.clientWidth);
    } else if (tableWidthAttr) {
      tmpTable.width(tableWidthAttr);
    }
    var total = 0;
    var bodyCells = tmpTable.find("tbody tr").eq(0).children();
    for (i = 0; i < visibleColumns.length; i++) {
      var bounding = bodyCells[i].getBoundingClientRect().width;
      total += bounding;
      columns[visibleColumns[i]].sWidth = _fnStringToCss5(bounding);
    }
    table.style.width = _fnStringToCss5(total);
    holder.remove();
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss5(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !settings._reszEvt) {
      var bindResize = function() {
        $9(window).on("resize.DT-" + settings.sInstance, DataTable5.util.throttle(function() {
          if (!settings.bDestroying) {
            _fnAdjustColumnSizing5(settings);
          }
        }));
      };
      bindResize();
      settings._reszEvt = true;
    }
  }
  function _fnGetMaxLenString5(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    if (!column.maxLenString) {
      var s, max = "", maxLen = -1;
      for (var i = 0, ien = settings.aiDisplayMaster.length; i < ien; i++) {
        var rowIdx = settings.aiDisplayMaster[i];
        var data = _fnGetRowDisplay5(settings, rowIdx)[colIdx];
        var cellString = data && typeof data === "object" && data.nodeType ? data.innerHTML : data + "";
        cellString = cellString.replace(/id=".*?"/g, "").replace(/name=".*?"/g, "");
        s = _stripHtml5(cellString).replace(/&nbsp;/g, " ");
        if (s.length > maxLen) {
          max = cellString;
          maxLen = s.length;
        }
      }
      column.maxLenString = max;
    }
    return column.maxLenString;
  }
  function _fnStringToCss5(s) {
    if (s === null) {
      return "0px";
    }
    if (typeof s == "number") {
      return s < 0 ? "0px" : s + "px";
    }
    return s.match(/\d$/) ? s + "px" : s;
  }
  function _colGroup5(settings) {
    var cols = settings.aoColumns;
    settings.colgroup.empty();
    for (i = 0; i < cols.length; i++) {
      if (cols[i].bVisible) {
        settings.colgroup.append(cols[i].colEl);
      }
    }
  }
  function _fnSortInit5(settings) {
    var target = settings.nTHead;
    var headerRows = target.querySelectorAll("tr");
    var legacyTop = settings.bSortCellsTop;
    var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
    if (legacyTop === true) {
      target = headerRows[0];
    } else if (legacyTop === false) {
      target = headerRows[headerRows.length - 1];
    }
    _fnSortAttachListener5(
      settings,
      target,
      target === settings.nTHead ? "tr" + notSelector + " th" + notSelector + ", tr" + notSelector + " td" + notSelector : "th" + notSelector + ", td" + notSelector
    );
    var order = [];
    _fnSortResolve5(settings, order, settings.aaSorting);
    settings.aaSorting = order;
  }
  function _fnSortAttachListener5(settings, node, selector, column, callback) {
    _fnBindAction5(node, selector, function(e) {
      var run = false;
      var columns = column === void 0 ? _fnColumnsFromHeader5(e.target) : [column];
      if (columns.length) {
        for (var i = 0, ien = columns.length; i < ien; i++) {
          var ret = _fnSortAdd5(settings, columns[i], i, e.shiftKey);
          if (ret !== false) {
            run = true;
          }
          if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === "") {
            break;
          }
        }
        if (run) {
          _fnProcessingDisplay5(settings, true);
          setTimeout(function() {
            _fnSort5(settings);
            _fnSortDisplay5(settings, settings.aiDisplay);
            _fnProcessingDisplay5(settings, false);
            _fnReDraw5(settings, false, false);
            if (callback) {
              callback();
            }
          }, 0);
        }
      }
    });
  }
  function _fnSortDisplay5(settings, display) {
    var master = settings.aiDisplayMaster;
    var masterMap = {};
    var map2 = {};
    var i;
    for (i = 0; i < master.length; i++) {
      masterMap[master[i]] = i;
    }
    for (i = 0; i < display.length; i++) {
      map2[display[i]] = masterMap[display[i]];
    }
    display.sort(function(a, b) {
      return map2[a] - map2[b];
    });
  }
  function _fnSortResolve5(settings, nestedSort, sort) {
    var push = function(a) {
      if ($9.isPlainObject(a)) {
        if (a.idx !== void 0) {
          nestedSort.push([a.idx, a.dir]);
        } else if (a.name) {
          var cols = _pluck5(settings.aoColumns, "sName");
          var idx = cols.indexOf(a.name);
          if (idx !== -1) {
            nestedSort.push([idx, a.dir]);
          }
        }
      } else {
        nestedSort.push(a);
      }
    };
    if ($9.isPlainObject(sort)) {
      push(sort);
    } else if (sort.length && typeof sort[0] === "number") {
      push(sort);
    } else if (sort.length) {
      for (var z = 0; z < sort.length; z++) {
        push(sort[z]);
      }
    }
  }
  function _fnSortFlatten5(settings) {
    var i, k, kLen, aSort = [], extSort = DataTable5.ext.type.order, aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $9.isPlainObject(fixed), nestedSort = [];
    if (!settings.oFeatures.bSort) {
      return aSort;
    }
    if (Array.isArray(fixed)) {
      _fnSortResolve5(settings, nestedSort, fixed);
    }
    if (fixedObj && fixed.pre) {
      _fnSortResolve5(settings, nestedSort, fixed.pre);
    }
    _fnSortResolve5(settings, nestedSort, settings.aaSorting);
    if (fixedObj && fixed.post) {
      _fnSortResolve5(settings, nestedSort, fixed.post);
    }
    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      if (aoColumns[srcCol]) {
        aDataSort = aoColumns[srcCol].aDataSort;
        for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
          iCol = aDataSort[k];
          sType = aoColumns[iCol].sType || "string";
          if (nestedSort[i]._idx === void 0) {
            nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
          }
          if (nestedSort[i][1]) {
            aSort.push({
              src: srcCol,
              col: iCol,
              dir: nestedSort[i][1],
              index: nestedSort[i]._idx,
              type: sType,
              formatter: extSort[sType + "-pre"],
              sorter: extSort[sType + "-" + nestedSort[i][1]]
            });
          }
        }
      }
    }
    return aSort;
  }
  function _fnSort5(oSettings, col, dir) {
    var i, ien, iLen, aiOrig = [], extSort = DataTable5.ext.type.order, aoData = oSettings.aoData, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    _fnColumnTypes5(oSettings);
    if (col !== void 0) {
      var srcCol = oSettings.aoColumns[col];
      aSort = [{
        src: col,
        col,
        dir,
        index: 0,
        type: srcCol.sType,
        formatter: extSort[srcCol.sType + "-pre"],
        sorter: extSort[srcCol.sType + "-" + dir]
      }];
      displayMaster = displayMaster.slice();
    } else {
      aSort = _fnSortFlatten5(oSettings);
    }
    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i];
      _fnSortData5(oSettings, sortCol.col);
    }
    if (_fnDataSource5(oSettings) != "ssp" && aSort.length !== 0) {
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[i] = i;
      }
      if (aSort.length && aSort[0].dir === "desc") {
        aiOrig.reverse();
      }
      displayMaster.sort(function(a, b) {
        var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
        for (k = 0; k < len; k++) {
          sort = aSort[k];
          x = dataA[sort.col];
          y = dataB[sort.col];
          if (sort.sorter) {
            test = sort.sorter(x, y);
            if (test !== 0) {
              return test;
            }
          } else {
            test = x < y ? -1 : x > y ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
        }
        x = aiOrig[a];
        y = aiOrig[b];
        return x < y ? -1 : x > y ? 1 : 0;
      });
    } else if (aSort.length === 0) {
      displayMaster.sort(function(x, y) {
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    if (col === void 0) {
      oSettings.bSorted = true;
      _fnCallbackFire5(oSettings, null, "order", [oSettings, aSort]);
    }
    return displayMaster;
  }
  function _fnSortAdd5(settings, colIdx, addIndex, shift) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a, overflow) {
      var idx = a._idx;
      if (idx === void 0) {
        idx = asSorting.indexOf(a[1]);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (!col.bSortable) {
      return false;
    }
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if ((shift || addIndex) && settings.oFeatures.bSortMulti) {
      var sortIdx = _pluck5(sorting, "0").indexOf(colIdx);
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else if (shift) {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      } else {
        sorting.push([colIdx, sorting[0][1], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    }
  }
  function _fnSortingClasses5(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.order.position;
    var sort = _fnSortFlatten5(settings);
    var features = settings.oFeatures;
    var i, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src;
        $9(_pluck5(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      }
      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $9(_pluck5(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData5(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    var customSort = DataTable5.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(
        settings.oInstance,
        settings,
        colIdx,
        _fnColumnIndexToVisible5(settings, colIdx)
      );
    }
    var row, cellData;
    var formatter = DataTable5.ext.type.order[column.sType + "-pre"];
    var data = settings.aoData;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[colIdx] || customSort) {
        cellData = customSort ? customData[rowIdx] : (
          // If there was a custom sort function, use data from there
          _fnGetCellData5(settings, rowIdx, colIdx, "sort")
        );
        row._aSortData[colIdx] = formatter ? formatter(cellData, settings) : cellData;
      }
    }
  }
  function _fnSaveState5(settings) {
    if (settings._bLoadingState) {
      return;
    }
    var state = {
      time: +/* @__PURE__ */ new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $9.extend(true, [], settings.aaSorting),
      search: $9.extend({}, settings.oPreviousSearch),
      columns: settings.aoColumns.map(function(col, i) {
        return {
          visible: col.bVisible,
          search: $9.extend({}, settings.aoPreSearchCols[i])
        };
      })
    };
    settings.oSavedState = state;
    _fnCallbackFire5(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
  }
  function _fnLoadState5(settings, init2, callback) {
    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }
    var loaded = function(state2) {
      _fnImplementState5(settings, state2, callback);
    };
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
    if (state !== void 0) {
      _fnImplementState5(settings, state, callback);
    }
    return true;
  }
  function _fnImplementState5(settings, s, callback) {
    var i, ien;
    var columns = settings.aoColumns;
    settings._bLoadingState = true;
    var api = settings._bInitComplete ? new DataTable5.Api(settings) : null;
    if (!s || !s.time) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && s.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var abStateLoad = _fnCallbackFire5(settings, "aoStateLoadParams", "stateLoadParams", [settings, s]);
    if (abStateLoad.indexOf(false) !== -1) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    if (s.columns && columns.length !== s.columns.length) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    settings.oLoadedState = $9.extend(true, {}, s);
    _fnCallbackFire5(settings, null, "stateLoadInit", [settings, s], true);
    if (s.length !== void 0) {
      if (api) {
        api.page.len(s.length);
      } else {
        settings._iDisplayLength = s.length;
      }
    }
    if (s.start !== void 0) {
      if (api === null) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      } else {
        _fnPageChange5(settings, s.start / settings._iDisplayLength);
      }
    }
    if (s.order !== void 0) {
      settings.aaSorting = [];
      $9.each(s.order, function(i2, col2) {
        settings.aaSorting.push(
          col2[0] >= columns.length ? [0, col2[1]] : col2
        );
      });
    }
    if (s.search !== void 0) {
      $9.extend(settings.oPreviousSearch, s.search);
    }
    if (s.columns) {
      for (i = 0, ien = s.columns.length; i < ien; i++) {
        var col = s.columns[i];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i).visible(col.visible, false);
          } else {
            columns[i].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $9.extend(settings.aoPreSearchCols[i], col.search);
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
    settings._bLoadingState = false;
    _fnCallbackFire5(settings, "aoStateLoaded", "stateLoaded", [settings, s]);
    callback();
  }
  function _fnLog5(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable5.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire5(settings, null, "dt-error", [settings, tn, msg], true);
      }
      if (type == "alert") {
        alert(msg);
      } else if (type == "throw") {
        throw new Error(msg);
      } else if (typeof type == "function") {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  function _fnMap5(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $9.each(name, function(i, val) {
        if (Array.isArray(val)) {
          _fnMap5(ret, src, val[0], val[1]);
        } else {
          _fnMap5(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === void 0) {
      mappedName = name;
    }
    if (src[name] !== void 0) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend5(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, prop)) {
        val = extender[prop];
        if ($9.isPlainObject(val)) {
          if (!$9.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $9.extend(true, out[prop], val);
        } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }
    return out;
  }
  function _fnBindAction5(n, selector, fn) {
    $9(n).on("click.DT", selector, function(e) {
      fn(e);
    }).on("keypress.DT", selector, function(e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on("selectstart.DT", selector, function() {
      return false;
    });
  }
  function _fnCallbackReg5(settings, store, fn) {
    if (fn) {
      settings[store].push(fn);
    }
  }
  function _fnCallbackFire5(settings, callbackArr, eventName, args, bubbles) {
    var ret = [];
    if (callbackArr) {
      ret = settings[callbackArr].slice().reverse().map(function(val) {
        return val.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e = $9.Event(eventName + ".dt");
      var table = $9(settings.nTable);
      e.dt = settings.api;
      table[bubbles ? "trigger" : "triggerHandler"](e, args);
      if (bubbles && table.parents("body").length === 0) {
        $9("body").trigger(e, args);
      }
      ret.push(e.result);
    }
    return ret;
  }
  function _fnLengthOverflow5(settings) {
    var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start >= end) {
      start = end - len;
    }
    start -= start % len;
    if (len === -1 || start < 0) {
      start = 0;
    }
    settings._iDisplayStart = start;
  }
  function _fnRenderer5(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable5.ext.renderer[type];
    if ($9.isPlainObject(renderer) && renderer[type]) {
      return host[renderer[type]] || host._;
    } else if (typeof renderer === "string") {
      return host[renderer] || host._;
    }
    return host._;
  }
  function _fnDataSource5(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else if (settings.ajax) {
      return "ajax";
    }
    return "dom";
  }
  function _fnMacros5(settings, str, entries) {
    var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), max = settings.fnRecordsTotal(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, max)).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len))).replace(/_ENTRIES_/g, settings.api.i18n("entries", "", entries)).replace(/_ENTRIES-MAX_/g, settings.api.i18n("entries", "", max)).replace(/_ENTRIES-TOTAL_/g, settings.api.i18n("entries", "", vis));
  }
  var __apiStruct5 = [];
  var __arrayProto5 = Array.prototype;
  var _toSettings5 = function(mixed) {
    var idx, jq;
    var settings = DataTable5.settings;
    var tables = _pluck5(settings, "nTable");
    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oFeatures) {
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
      idx = tables.indexOf(mixed);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === "function") {
      return mixed.settings().toArray();
    } else if (typeof mixed === "string") {
      jq = $9(mixed).get();
    } else if (mixed instanceof $9) {
      jq = mixed.get();
    }
    if (jq) {
      return settings.filter(function(v, idx2) {
        return jq.includes(tables[idx2]);
      });
    }
  };
  _Api5 = function(context, data) {
    if (!(this instanceof _Api5)) {
      return new _Api5(context, data);
    }
    var settings = [];
    var ctxSettings = function(o) {
      var a = _toSettings5(o);
      if (a) {
        settings.push.apply(settings, a);
      }
    };
    if (Array.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = settings.length > 1 ? _unique5(settings) : settings;
    if (data) {
      this.push.apply(this, data);
    }
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
    _Api5.extend(this, this, __apiStruct5);
  };
  DataTable5.Api = _Api5;
  $9.extend(_Api5.prototype, {
    any: function() {
      return this.count() !== 0;
    },
    context: [],
    // array of table settings objects
    count: function() {
      return this.flatten().length;
    },
    each: function(fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }
      return this;
    },
    eq: function(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api5(ctx[idx], this[idx]) : null;
    },
    filter: function(fn) {
      var a = __arrayProto5.filter.call(this, fn, this);
      return new _Api5(this.context, a);
    },
    flatten: function() {
      var a = [];
      return new _Api5(this.context, a.concat.apply(a, this.toArray()));
    },
    get: function(idx) {
      return this[idx];
    },
    join: __arrayProto5.join,
    includes: function(find) {
      return this.indexOf(find) === -1 ? false : true;
    },
    indexOf: __arrayProto5.indexOf,
    iterator: function(flatten, type, fn, alwaysNew) {
      var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
      if (typeof flatten === "string") {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }
      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api5(context[i]);
        if (type === "table") {
          ret = fn.call(apiInst, context[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "columns" || type === "rows") {
          ret = fn.call(apiInst, context[i], this[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "every" || type === "column" || type === "column-rows" || type === "row" || type === "cell") {
          items = this[i];
          if (type === "column-rows") {
            rows = _selector_row_indexes5(context[i], selector.opts);
          }
          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];
            if (type === "cell") {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }
            if (ret !== void 0) {
              a.push(ret);
            }
          }
        }
      }
      if (a.length || alwaysNew) {
        var api = new _Api5(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
    lastIndexOf: __arrayProto5.lastIndexOf,
    length: 0,
    map: function(fn) {
      var a = __arrayProto5.map.call(this, fn, this);
      return new _Api5(this.context, a);
    },
    pluck: function(prop) {
      var fn = DataTable5.util.get(prop);
      return this.map(function(el) {
        return fn(el);
      });
    },
    pop: __arrayProto5.pop,
    push: __arrayProto5.push,
    reduce: __arrayProto5.reduce,
    reduceRight: __arrayProto5.reduceRight,
    reverse: __arrayProto5.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto5.shift,
    slice: function() {
      return new _Api5(this.context, this);
    },
    sort: __arrayProto5.sort,
    splice: __arrayProto5.splice,
    toArray: function() {
      return __arrayProto5.slice.call(this);
    },
    to$: function() {
      return $9(this);
    },
    toJQuery: function() {
      return $9(this);
    },
    unique: function() {
      return new _Api5(this.context, _unique5(this.toArray()));
    },
    unshift: __arrayProto5.unshift
  });
  function _api_scope5(scope, fn, struc) {
    return function() {
      var ret = fn.apply(scope || this, arguments);
      _Api5.extend(ret, ret, struc.methodExt);
      return ret;
    };
  }
  function _api_find5(src, name) {
    for (var i = 0, ien = src.length; i < ien; i++) {
      if (src[i].name === name) {
        return src[i];
      }
    }
    return null;
  }
  window.__apiStruct = __apiStruct5;
  _Api5.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api5) && !obj.__dt_wrapper) {
      return;
    }
    var i, ien, struct;
    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i];
      if (struct.name === "__proto__") {
        continue;
      }
      obj[struct.name] = struct.type === "function" ? _api_scope5(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api5.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api5.register = _api_register5 = function(name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api5.register(name[j], val);
      }
      return;
    }
    var i, ien, heir = name.split("."), struct = __apiStruct5, key, method;
    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf("()") !== -1;
      key = method ? heir[i].replace("()", "") : heir[i];
      var src = _api_find5(struct, key);
      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: "object"
        };
        struct.push(src);
      }
      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === "function" ? "function" : $9.isPlainObject(val) ? "object" : "other";
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api5.registerPlural = _api_registerPlural5 = function(pluralName, singularName, val) {
    _Api5.register(pluralName, val);
    _Api5.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else if (ret instanceof _Api5) {
        return ret.length ? Array.isArray(ret[0]) ? new _Api5(ret.context, ret[0]) : (
          // Array results are 'enhanced'
          ret[0]
        ) : void 0;
      }
      return ret;
    });
  };
  var __table_selector5 = function(selector, a) {
    if (Array.isArray(selector)) {
      var result = [];
      selector.forEach(function(sel) {
        var inner = __table_selector5(sel, a);
        result.push.apply(result, inner);
      });
      return result.filter(function(item) {
        return item;
      });
    }
    if (typeof selector === "number") {
      return [a[selector]];
    }
    var nodes = a.map(function(el) {
      return el.nTable;
    });
    return $9(nodes).filter(selector).map(function() {
      var idx = nodes.indexOf(this);
      return a[idx];
    }).toArray();
  };
  _api_register5("tables()", function(selector) {
    return selector !== void 0 && selector !== null ? new _Api5(__table_selector5(selector, this.context)) : this;
  });
  _api_register5("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api5(ctx[0]) : tables;
  });
  [
    ["nodes", "node", "nTable"],
    ["body", "body", "nTBody"],
    ["header", "header", "nTHead"],
    ["footer", "footer", "nTFoot"]
  ].forEach(function(item) {
    _api_registerPlural5(
      "tables()." + item[0] + "()",
      "table()." + item[1] + "()",
      function() {
        return this.iterator("table", function(ctx) {
          return ctx[item[2]];
        }, 1);
      }
    );
  });
  [
    ["header", "aoHeader"],
    ["footer", "aoFooter"]
  ].forEach(function(item) {
    _api_register5("table()." + item[0] + ".structure()", function(selector) {
      var indexes = this.columns(selector).indexes().flatten();
      var ctx = this.context[0];
      return _fnHeaderLayout5(ctx, ctx[item[1]], indexes);
    });
  });
  _api_registerPlural5("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register5("tables().every()", function(fn) {
    var that = this;
    return this.iterator("table", function(s, i) {
      fn.call(that.table(i), i);
    });
  });
  _api_register5("caption()", function(value, side) {
    var context = this.context;
    if (value === void 0) {
      var caption = context[0].captionNode;
      return caption && context.length ? caption.innerHTML : null;
    }
    return this.iterator("table", function(ctx) {
      var table = $9(ctx.nTable);
      var caption2 = $9(ctx.captionNode);
      var container = $9(ctx.nTableWrapper);
      if (!caption2.length) {
        caption2 = $9("<caption/>").html(value);
        ctx.captionNode = caption2[0];
        if (!side) {
          table.prepend(caption2);
          side = caption2.css("caption-side");
        }
      }
      caption2.html(value);
      if (side) {
        caption2.css("caption-side", side);
        caption2[0]._captionSide = side;
      }
      if (container.find("div.dataTables_scroll").length) {
        var selector = side === "top" ? "Head" : "Foot";
        container.find("div.dataTables_scroll" + selector + " table").prepend(caption2);
      } else {
        table.prepend(caption2);
      }
    }, 1);
  });
  _api_register5("caption.node()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].captionNode : null;
  });
  _api_register5("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw5(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw5(settings, paging === false);
      }
    });
  });
  _api_register5("page()", function(action) {
    if (action === void 0) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange5(settings, action);
    });
  });
  _api_register5("page.info()", function() {
    if (this.context.length === 0) {
      return void 0;
    }
    var settings = this.context[0], start = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource5(settings) === "ssp"
    };
  });
  _api_register5("page.len()", function(len) {
    if (len === void 0) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange5(settings, len);
    });
  });
  var __reload5 = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api5(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource5(settings) == "ssp") {
      _fnReDraw5(settings, holdPosition);
    } else {
      _fnProcessingDisplay5(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax5(settings, {}, function(json) {
        _fnClearTable5(settings);
        var data = _fnAjaxDataSrc5(settings, json);
        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData5(settings, data[i]);
        }
        _fnReDraw5(settings, holdPosition);
        _fnInitComplete5(settings);
        _fnProcessingDisplay5(settings, false);
      });
    }
  };
  _api_register5("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register5("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register5("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload5(settings, resetPaging === false, callback);
    });
  });
  _api_register5("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === void 0) {
      if (ctx.length === 0) {
        return void 0;
      }
      ctx = ctx[0];
      return $9.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax;
    }
    return this.iterator("table", function(settings) {
      if ($9.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register5("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload5(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run5 = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
      selector = [selector];
    }
    for (i = 0, ien = selector.length; i < ien; i++) {
      a = selector[i] && selector[i].split && !selector[i].match(/[[(:]/) ? selector[i].split(",") : [selector[i]];
      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === "string" ? a[j].trim() : a[j]);
        res = res.filter(function(item) {
          return item !== null && item !== void 0;
        });
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext5.selector[type];
    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }
    return _unique5(out);
  };
  var _selector_opts5 = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === void 0) {
      opts.search = opts.filter;
    }
    return $9.extend({
      search: "none",
      order: "current",
      page: "all"
    }, opts);
  };
  var _selector_first5 = function(old) {
    let inst = new _Api5(old.context[0]);
    if (old.length) {
      inst.push(old[0]);
    }
    inst.selector = old.selector;
    if (inst.length && inst[0].length > 1) {
      inst[0].splice(1);
    }
    return inst;
  };
  var _selector_row_indexes5 = function(settings, opts) {
    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order = opts.order, page = opts.page;
    if (page == "current") {
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == "current" || order == "applied") {
      if (search == "none") {
        a = displayMaster.slice();
      } else if (search == "applied") {
        a = displayFiltered.slice();
      } else if (search == "removed") {
        var displayFilteredMap = {};
        for (i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }
        displayMaster.forEach(function(item) {
          if (!Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
            a.push(item);
          }
        });
      }
    } else if (order == "index" || order == "original") {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (!settings.aoData[i]) {
          continue;
        }
        if (search == "none") {
          a.push(i);
        } else {
          tmp = displayFiltered.indexOf(i);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(i);
          }
        }
      }
    } else if (typeof order === "number") {
      var ordered = _fnSort5(settings, order, "asc");
      if (search === "none") {
        a = ordered;
      } else {
        for (i = 0; i < ordered.length; i++) {
          tmp = displayFiltered.indexOf(ordered[i]);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(ordered[i]);
          }
        }
      }
    }
    return a;
  };
  var __row_selector5 = function(settings, selector, opts) {
    var rows;
    var run = function(sel) {
      var selInt = _intVal5(sel);
      var aoData = settings.aoData;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      if (!rows) {
        rows = _selector_row_indexes5(settings, opts);
      }
      if (selInt !== null && rows.indexOf(selInt) !== -1) {
        return [selInt];
      } else if (sel === null || sel === void 0 || sel === "") {
        return rows;
      }
      if (typeof sel === "function") {
        return rows.map(function(idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex;
        var cellIdx = sel._DT_CellIndex;
        if (rowIdx !== void 0) {
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $9(sel).closest("*[data-dt-row]");
          return host.length ? [host.data("dt-row")] : [];
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== void 0) {
          return [rowObj.idx];
        }
      }
      var nodes = _removeEmpty5(
        _pluck_order5(settings.aoData, rows, "nTr")
      );
      return $9(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    var matched = _selector_run5("row", selector, run, settings, opts);
    if (opts.order === "current" || opts.order === "applied") {
      _fnSortDisplay5(settings, matched);
    }
    return matched;
  };
  _api_register5("rows()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($9.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts5(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector5(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register5("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || void 0;
    }, 1);
  });
  _api_register5("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order5(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural5("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r = settings.aoData[row];
      return type === "search" ? r._aFilterData : r._aSortData;
    }, 1);
  });
  _api_registerPlural5("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate5(settings, row, src);
    });
  });
  _api_registerPlural5("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural5("rows().ids()", "row().id()", function(hash) {
    var a = [];
    var context = this.context;
    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? "#" : "") + id);
      }
    }
    return new _Api5(context, a);
  });
  _api_registerPlural5("rows().remove()", "row().remove()", function() {
    this.iterator("row", function(settings, row) {
      var data = settings.aoData;
      var rowData = data[row];
      var idx = settings.aiDisplayMaster.indexOf(row);
      if (idx !== -1) {
        settings.aiDisplayMaster.splice(idx, 1);
      }
      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      }
      _fnLengthOverflow5(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== void 0) {
        delete settings.aIds[id];
      }
      data[row] = null;
    });
    return this;
  });
  _api_register5("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i, ien;
      var out = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr5(settings, row)[0]);
        } else {
          out.push(_fnAddData5(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    modRows.push.apply(modRows, newRows);
    return modRows;
  });
  _api_register5("row()", function(selector, opts) {
    return _selector_first5(this.rows(selector, opts));
  });
  _api_register5("row().data()", function(data) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]]._aData : void 0;
    }
    var row = ctx[0].aoData[this[0]];
    row._aData = data;
    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn5(ctx[0].rowId)(data, row.nTr.id);
    }
    _fnInvalidate5(ctx[0], this[0], "data");
    return this;
  });
  _api_register5("row().node()", function() {
    var ctx = this.context;
    return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]].nTr || null : null;
  });
  _api_register5("row.add()", function(row) {
    if (row instanceof $9 && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr5(settings, row)[0];
      }
      return _fnAddData5(settings, row);
    });
    return this.row(rows[0]);
  });
  $9(document).on("plugin-init.dt", function(e, context) {
    var api = new _Api5(context);
    api.on("stateSaveParams.DT", function(e2, settings, d) {
      var idFn = settings.rowIdFn;
      var rows = settings.aiDisplayMaster;
      var ids = [];
      for (var i = 0; i < rows.length; i++) {
        var rowIdx = rows[i];
        var data = settings.aoData[rowIdx];
        if (data._detailsShow) {
          ids.push("#" + idFn(data._aData));
        }
      }
      d.childRows = ids;
    });
    api.on("stateLoaded.DT", function(e2, settings, state) {
      __details_state_load5(api, state);
    });
    __details_state_load5(api, api.state.loaded());
  });
  var __details_state_load5 = function(api, state) {
    if (state && state.childRows) {
      api.rows(state.childRows.map(function(id) {
        return id.replace(/(?<!\\):/g, "\\:");
      })).every(function() {
        _fnCallbackFire5(api.settings()[0], null, "requestChild", [this]);
      });
    }
  };
  var __details_add5 = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r, k) {
      if (Array.isArray(r) || r instanceof $9) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }
        return;
      }
      if (r.nodeName && r.nodeName.toLowerCase() === "tr") {
        r.setAttribute("data-dt-row", row.idx);
        rows.push(r);
      } else {
        var created = $9("<tr><td></td></tr>").attr("data-dt-row", row.idx).addClass(k);
        $9("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns5(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.detach();
    }
    row._details = $9(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_state5 = DataTable5.util.throttle(
    function(ctx) {
      _fnSaveState5(ctx[0]);
    },
    500
  );
  var __details_remove5 = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = void 0;
        row._details = void 0;
        $9(row.nTr).removeClass("dt-hasChild");
        __details_state5(ctx);
      }
    }
  };
  var __details_display5 = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
          $9(row.nTr).addClass("dt-hasChild");
        } else {
          row._details.detach();
          $9(row.nTr).removeClass("dt-hasChild");
        }
        _fnCallbackFire5(ctx[0], null, "childRow", [show, api.row(api[0])]);
        __details_events5(ctx[0]);
        __details_state5(ctx);
      }
    }
  };
  var __details_events5 = function(settings) {
    var api = new _Api5(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-sizing" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck5(data, "_details").length > 0) {
      api.on(drawEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({ page: "current" }).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns5(ctx);
        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];
          if (row && row._details) {
            row._details.each(function() {
              var el = $9(this).children("td");
              if (el.length == 1) {
                el.attr("colspan", visible);
              }
            });
          }
        }
      });
      api.on(destroyEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i] && data[i]._details) {
            __details_remove5(api, i);
          }
        }
      });
    }
  };
  var _emp5 = "";
  var _child_obj5 = _emp5 + "row().child";
  var _child_mth5 = _child_obj5 + "()";
  _api_register5(_child_mth5, function(data, klass) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && ctx[0].aoData[this[0]] ? ctx[0].aoData[this[0]]._details : void 0;
    } else if (data === true) {
      this.child.show();
    } else if (data === false) {
      __details_remove5(this);
    } else if (ctx.length && this.length) {
      __details_add5(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }
    return this;
  });
  _api_register5([
    _child_obj5 + ".show()",
    _child_mth5 + ".show()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display5(this, true);
    return this;
  });
  _api_register5([
    _child_obj5 + ".hide()",
    _child_mth5 + ".hide()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display5(this, false);
    return this;
  });
  _api_register5([
    _child_obj5 + ".remove()",
    _child_mth5 + ".remove()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_remove5(this);
    return this;
  });
  _api_register5(_child_obj5 + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector5 = /^([^:]+):(name|title|visIdx|visible)$/;
  var __columnData5 = function(settings, column, r1, r2, rows, type) {
    var a = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData5(settings, rows[row], column, type));
    }
    return a;
  };
  var __column_header5 = function(settings, column, row) {
    var header = settings.aoHeader;
    var target = row !== void 0 ? row : settings.bSortCellsTop ? 0 : header.length - 1;
    return header[target][column].cell;
  };
  var __column_selector5 = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck5(columns, "sName"), titles = _pluck5(columns, "sTitle"), cells = DataTable5.util.get("[].[].cell")(settings.aoHeader), nodes = _unique5(_flatten5([], cells));
    var run = function(s) {
      var selInt = _intVal5(s);
      if (s === "") {
        return _range5(columns.length);
      }
      if (selInt !== null) {
        return [
          selInt >= 0 ? selInt : (
            // Count from left
            columns.length + selInt
          )
          // Count from right (+ because its a negative value)
        ];
      }
      if (typeof s === "function") {
        var rows = _selector_row_indexes5(settings, opts);
        return columns.map(function(col, idx2) {
          return s(
            idx2,
            __columnData5(settings, idx2, 0, 0, rows),
            __column_header5(settings, idx2)
          ) ? idx2 : null;
        });
      }
      var match = typeof s === "string" ? s.match(__re_column_selector5) : "";
      if (match) {
        switch (match[2]) {
          case "visIdx":
          case "visible":
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = columns.map(function(col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex5(settings, idx)];
          case "name":
            return names.map(function(name, i) {
              return name === match[1] ? i : null;
            });
          case "title":
            return titles.map(function(title, i) {
              return title === match[1] ? i : null;
            });
          default:
            return [];
        }
      }
      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      }
      var jqResult = $9(nodes).filter(s).map(function() {
        return _fnColumnsFromHeader5(this);
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      var host = $9(s).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run5("column", selector, run, settings, opts);
  };
  var __setColumnVis5 = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, cells, i, ien, tr;
    if (vis === void 0) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return false;
    }
    if (vis) {
      var insertBefore = _pluck5(cols, "bVisible").indexOf(true, column + 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        if (data[i]) {
          tr = data[i].nTr;
          cells = data[i].anCells;
          if (tr) {
            tr.insertBefore(cells[column], cells[insertBefore] || null);
          }
        }
      }
    } else {
      $9(_pluck5(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
    _colGroup5(settings);
    return true;
  };
  _api_register5("columns()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($9.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts5(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector5(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural5("columns().header()", "column().header()", function(row) {
    return this.iterator("column", function(settings, column) {
      return __column_header5(settings, column, row);
    }, 1);
  });
  _api_registerPlural5("columns().footer()", "column().footer()", function(row) {
    return this.iterator("column", function(settings, column) {
      var footer = settings.aoFooter;
      if (!footer.length) {
        return null;
      }
      return settings.aoFooter[row !== void 0 ? row : 0][column].cell;
    }, 1);
  });
  _api_registerPlural5("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData5, 1);
  });
  _api_registerPlural5("columns().render()", "column().render()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return __columnData5(settings, column, i, j, rows, type);
    }, 1);
  });
  _api_registerPlural5("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural5("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order5(
        settings.aoData,
        rows,
        type === "search" ? "_aFilterData" : "_aSortData",
        column
      );
    }, 1);
  });
  _api_registerPlural5("columns().init()", "column().init()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column];
    }, 1);
  });
  _api_registerPlural5("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order5(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural5("columns().titles()", "column().title()", function(title, row) {
    return this.iterator("column", function(settings, column) {
      if (typeof title === "number") {
        row = title;
        title = void 0;
      }
      var span = $9("span.dt-column-title", this.column(column).header(row));
      if (title !== void 0) {
        span.html(title);
        return this;
      }
      return span.html();
    }, 1);
  });
  _api_registerPlural5("columns().types()", "column().type()", function() {
    return this.iterator("column", function(settings, column) {
      var type = settings.aoColumns[column].sType;
      if (!type) {
        _fnColumnTypes5(settings);
      }
      return type;
    }, 1);
  });
  _api_registerPlural5("columns().visible()", "column().visible()", function(vis, calc) {
    var that = this;
    var changed = [];
    var ret = this.iterator("column", function(settings, column) {
      if (vis === void 0) {
        return settings.aoColumns[column].bVisible;
      }
      if (__setColumnVis5(settings, column, vis)) {
        changed.push(column);
      }
    });
    if (vis !== void 0) {
      this.iterator("table", function(settings) {
        _fnDrawHead5(settings, settings.aoHeader);
        _fnDrawHead5(settings, settings.aoFooter);
        if (!settings.aiDisplay.length) {
          $9(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns5(settings));
        }
        _fnSaveState5(settings);
        that.iterator("column", function(settings2, column) {
          if (changed.includes(column)) {
            _fnCallbackFire5(settings2, null, "column-visibility", [settings2, column, vis, calc]);
          }
        });
        if (changed.length && (calc === void 0 || calc)) {
          that.columns.adjust();
        }
      });
    }
    return ret;
  });
  _api_registerPlural5("columns().widths()", "column().width()", function() {
    var columns = this.columns(":visible").count();
    var row = $9("<tr>").html("<td>" + Array(columns).join("</td><td>") + "</td>");
    $9(this.table().body()).append(row);
    var widths = row.children().map(function() {
      return $9(this).outerWidth();
    });
    row.remove();
    return this.iterator("column", function(settings, column) {
      var visIdx = _fnColumnIndexToVisible5(settings, column);
      return visIdx !== null ? widths[visIdx] : 0;
    }, 1);
  });
  _api_registerPlural5("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible5(settings, column) : column;
    }, 1);
  });
  _api_register5("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing5(settings);
    }, 1);
  });
  _api_register5("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex5(ctx, idx);
      } else if (type === "fromData" || type === "toVisible") {
        return _fnColumnIndexToVisible5(ctx, idx);
      }
    }
  });
  _api_register5("column()", function(selector, opts) {
    return _selector_first5(this.columns(selector, opts));
  });
  var __cell_selector5 = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes5(settings, opts);
    var cells = _removeEmpty5(_pluck_order5(data, rows, "anCells"));
    var allCells = $9(_flatten5([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;
    var run = function(s) {
      var fnSelector = typeof s === "function";
      if (s === null || s === void 0 || fnSelector) {
        a = [];
        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];
          for (j = 0; j < columns; j++) {
            o = {
              row,
              column: j
            };
            if (fnSelector) {
              host = data[row];
              if (s(o, _fnGetCellData5(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              a.push(o);
            }
          }
        }
        return a;
      }
      if ($9.isPlainObject(s)) {
        return s.column !== void 0 && s.row !== void 0 && rows.indexOf(s.row) !== -1 ? [s] : [];
      }
      var jqResult = allCells.filter(s).map(function(i2, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      host = $9(s).closest("*[data-dt-row]");
      return host.length ? [{
        row: host.data("dt-row"),
        column: host.data("dt-column")
      }] : [];
    };
    return _selector_run5("cell", selector, run, settings, opts);
  };
  _api_register5("cells()", function(rowSelector, columnSelector, opts) {
    if ($9.isPlainObject(rowSelector)) {
      if (rowSelector.row === void 0) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($9.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === void 0) {
      return this.iterator("table", function(settings) {
        return __cell_selector5(settings, rowSelector, _selector_opts5(opts));
      });
    }
    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {};
    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator("table", function(settings, idx) {
      var a = [];
      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }
      return a;
    }, 1);
    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $9.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts
    });
    return cells;
  });
  _api_registerPlural5("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : void 0;
    }, 1);
  });
  _api_register5("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData5(settings, row, column);
    }, 1);
  });
  _api_registerPlural5("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural5("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData5(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural5("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {
        row,
        column,
        columnVisible: _fnColumnIndexToVisible5(settings, column)
      };
    }, 1);
  });
  _api_registerPlural5("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate5(settings, row, src, column);
    });
  });
  _api_register5("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first5(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register5("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === void 0) {
      return ctx.length && cell.length ? _fnGetCellData5(ctx[0], cell[0].row, cell[0].column) : void 0;
    }
    _fnSetCellData5(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate5(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register5("order()", function(order, dir) {
    var ctx = this.context;
    var args = Array.prototype.slice.call(arguments);
    if (order === void 0) {
      return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
    }
    if (typeof order === "number") {
      order = [[order, dir]];
    } else if (args.length > 1) {
      order = args;
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = Array.isArray(order) ? order.slice() : order;
    });
  });
  _api_register5("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener5(settings, node, {}, column, callback);
    });
  });
  _api_register5("order.fixed()", function(set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
      return Array.isArray(fixed) ? { pre: fixed } : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $9.extend(true, {}, set);
    });
  });
  _api_register5([
    "columns().order()",
    "column().order()"
  ], function(dir) {
    var that = this;
    if (!dir) {
      return this.iterator("column", function(settings, idx) {
        var sort = _fnSortFlatten5(settings);
        for (var i = 0, ien = sort.length; i < ien; i++) {
          if (sort[i].col === idx) {
            return sort[i].dir;
          }
        }
        return null;
      }, 1);
    } else {
      return this.iterator("table", function(settings, i) {
        settings.aaSorting = that[i].map(function(col) {
          return [col, dir];
        });
      });
    }
  });
  _api_registerPlural5("columns().orderable()", "column().orderable()", function(directions) {
    return this.iterator("column", function(settings, idx) {
      var col = settings.aoColumns[idx];
      return directions ? col.asSorting : col.bSortable;
    }, 1);
  });
  _api_register5("processing()", function(show) {
    return this.iterator("table", function(ctx) {
      _fnProcessingDisplay5(ctx, show);
    });
  });
  _api_register5("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === void 0) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.search : void 0;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      if (typeof regex === "object") {
        _fnFilterComplete5(settings, $9.extend(settings.oPreviousSearch, regex, {
          search: input
        }));
      } else {
        _fnFilterComplete5(settings, $9.extend(settings.oPreviousSearch, {
          search: input,
          regex: regex === null ? false : regex,
          smart: smart === null ? true : smart,
          caseInsensitive: caseInsen === null ? true : caseInsen
        }));
      }
    });
  });
  _api_register5("search.fixed()", function(name, search) {
    var ret = this.iterator(true, "table", function(settings) {
      var fixed = settings.searchFixed;
      if (!name) {
        return Object.keys(fixed);
      } else if (search === void 0) {
        return fixed[name];
      } else if (search === null) {
        delete fixed[name];
      } else {
        fixed[name] = search;
      }
      return this;
    });
    return name !== void 0 && search === void 0 ? ret[0] : ret;
  });
  _api_registerPlural5(
    "columns().search()",
    "column().search()",
    function(input, regex, smart, caseInsen) {
      return this.iterator("column", function(settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === void 0) {
          return preSearch[column].search;
        }
        if (!settings.oFeatures.bFilter) {
          return;
        }
        if (typeof regex === "object") {
          $9.extend(preSearch[column], regex, {
            search: input
          });
        } else {
          $9.extend(preSearch[column], {
            search: input,
            regex: regex === null ? false : regex,
            smart: smart === null ? true : smart,
            caseInsensitive: caseInsen === null ? true : caseInsen
          });
        }
        _fnFilterComplete5(settings, settings.oPreviousSearch);
      });
    }
  );
  _api_register5(
    [
      "columns().search.fixed()",
      "column().search.fixed()"
    ],
    function(name, search) {
      var ret = this.iterator(true, "column", function(settings, colIdx) {
        var fixed = settings.aoColumns[colIdx].searchFixed;
        if (!name) {
          return Object.keys(fixed);
        } else if (search === void 0) {
          return fixed[name];
        } else if (search === null) {
          delete fixed[name];
        } else {
          fixed[name] = search;
        }
        return this;
      });
      return name !== void 0 && search === void 0 ? ret[0] : ret;
    }
  );
  _api_register5("state()", function(set, ignoreTime) {
    if (!set) {
      return this.context.length ? this.context[0].oSavedState : null;
    }
    var setMutate = $9.extend(true, {}, set);
    return this.iterator("table", function(settings) {
      if (ignoreTime !== false) {
        setMutate.time = +/* @__PURE__ */ new Date() + 100;
      }
      _fnImplementState5(settings, setMutate, function() {
      });
    });
  });
  _api_register5("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register5("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register5("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState5(settings);
    });
  });
  DataTable5.use = function(module, type) {
    if (type === "lib" || module.fn) {
      $9 = module;
    } else if (type == "win" || module.document) {
      window = module;
      document = module.document;
    } else if (type === "datetime" || module.type === "DateTime") {
      DataTable5.DateTime = module;
    }
  };
  DataTable5.factory = function(root, jq) {
    var is = false;
    if (root && root.document) {
      window = root;
      document = root.document;
    }
    if (jq && jq.fn && jq.fn.jquery) {
      $9 = jq;
      is = true;
    }
    return is;
  };
  DataTable5.versionCheck = function(version, version2) {
    var aThis = version2 ? version2.split(".") : DataTable5.version.split(".");
    var aThat = version.split(".");
    var iThis, iThat;
    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable5.isDataTable = function(table) {
    var t = $9(table).get(0);
    var is = false;
    if (table instanceof DataTable5.Api) {
      return true;
    }
    $9.each(DataTable5.settings, function(i, o) {
      var head = o.nScrollHead ? $9("table", o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $9("table", o.nScrollFoot)[0] : null;
      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  DataTable5.tables = function(visible) {
    var api = false;
    if ($9.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a = DataTable5.settings.filter(function(o) {
      return !visible || visible && $9(o.nTable).is(":visible") ? true : false;
    }).map(function(o) {
      return o.nTable;
    });
    return api ? new _Api5(a) : a;
  };
  DataTable5.camelToHungarian = _fnCamelToHungarian5;
  _api_register5("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $9(rows);
    return $9([].concat(
      jqRows.filter(selector).toArray(),
      jqRows.find(selector).toArray()
    ));
  });
  $9.each(["on", "one", "off"], function(i, key) {
    _api_register5(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      args[0] = args[0].split(/\s/).map(function(e) {
        return !e.match(/\.dt\b/) ? e + ".dt" : e;
      }).join(" ");
      var inst = $9(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register5("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable5(settings);
    });
  });
  _api_register5("error()", function(msg) {
    return this.iterator("table", function(settings) {
      _fnLog5(settings, 0, msg);
    });
  });
  _api_register5("settings()", function() {
    return new _Api5(this.context, this.context);
  });
  _api_register5("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register5("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck5(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register5("trigger()", function(name, args, bubbles) {
    return this.iterator("table", function(settings) {
      return _fnCallbackFire5(settings, null, name, args, bubbles);
    }).flatten();
  });
  _api_register5("ready()", function(fn) {
    var ctx = this.context;
    if (!fn) {
      return ctx.length ? ctx[0]._bInitComplete || false : null;
    }
    return this.tables().every(function() {
      if (this.context[0]._bInitComplete) {
        fn.call(this);
      } else {
        this.on("init", function() {
          fn.call(this);
        });
      }
    });
  });
  _api_register5("destroy()", function(remove) {
    remove = remove || false;
    return this.iterator("table", function(settings) {
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $9(table);
      var jqTbody = $9(tbody);
      var jqWrapper = $9(settings.nTableWrapper);
      var rows = settings.aoData.map(function(r) {
        return r ? r.nTr : null;
      });
      var orderClasses = classes.order;
      settings.bDestroying = true;
      _fnCallbackFire5(settings, "aoDestroyCallback", "destroy", [settings], true);
      if (!remove) {
        new _Api5(settings).columns().visible(true);
      }
      jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
      $9(window).off(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.colgroup.remove();
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses5(settings);
      $9("th, td", thead).removeClass(
        orderClasses.canAsc + " " + orderClasses.canDesc + " " + orderClasses.isAsc + " " + orderClasses.isDesc
      ).css("width", "");
      jqTbody.children().detach();
      jqTbody.append(rows);
      var orig = settings.nTableWrapper.parentNode;
      var insertBefore = settings.nTableWrapper.nextSibling;
      var removedMethod = remove ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove && orig) {
        orig.insertBefore(table, insertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.table);
      }
      var idx = DataTable5.settings.indexOf(settings);
      if (idx !== -1) {
        DataTable5.settings.splice(idx, 1);
      }
    });
  });
  $9.each(["column", "row", "cell"], function(i, type) {
    _api_register5(type + "s().every()", function(fn) {
      var opts = this.selector.opts;
      var api = this;
      var inst;
      var counter = 0;
      return this.iterator("every", function(settings, selectedIdx, tableIdx) {
        inst = api[type](selectedIdx, opts);
        if (type === "cell") {
          fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
        } else {
          fn.call(inst, selectedIdx, tableIdx, counter);
        }
        counter++;
      });
    });
  });
  _api_register5("i18n()", function(token, def, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn5(token)(ctx.oLanguage);
    if (resolved === void 0) {
      resolved = def;
    }
    if ($9.isPlainObject(resolved)) {
      resolved = plural !== void 0 && resolved[plural] !== void 0 ? resolved[plural] : resolved._;
    }
    return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
  });
  DataTable5.version = "2.0.5";
  DataTable5.settings = [];
  DataTable5.models = {};
  DataTable5.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     */
    "caseInsensitive": true,
    /**
     * Applied search term
     */
    "search": "",
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     */
    "regex": false,
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     */
    "smart": true,
    /**
     * Flag to indicate if DataTables should only trigger a search when
     * the return key is pressed.
     */
    "return": false
  };
  DataTable5.models.oRow = {
    /**
     * TR element for the row
     */
    "nTr": null,
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     */
    "anCells": null,
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     */
    "_aData": [],
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     */
    "_aSortData": null,
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     */
    "_aFilterData": null,
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     */
    "_sFilterRow": null,
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     */
    "src": null,
    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     */
    "idx": -1,
    /**
     * Cached display value
     */
    displayData: null
  };
  DataTable5.models.oColumn = {
    /**
     * Column index.
     */
    "idx": null,
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     */
    "aDataSort": null,
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     */
    "asSorting": null,
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     */
    "bSearchable": null,
    /**
     * Flag to indicate if the column is sortable or not.
     */
    "bSortable": null,
    /**
     * Flag to indicate if the column is currently visible in the table or not
     */
    "bVisible": null,
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     */
    "_sManualType": null,
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     */
    "_bAttrSrc": false,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     */
    "fnGetData": null,
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     */
    "fnSetData": null,
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     */
    "mData": null,
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     */
    "mRender": null,
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     */
    "sClass": null,
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     */
    "sContentPadding": null,
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     */
    "sName": null,
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     */
    "sSortDataType": "std",
    /**
     * Class to be applied to the header element when sorting on this column
     */
    "sSortingClass": null,
    /**
     * Title of the column - what is seen in the TH element (nTh).
     */
    "sTitle": null,
    /**
     * Column sorting and filtering type
     */
    "sType": null,
    /**
     * Width of the column
     */
    "sWidth": null,
    /**
     * Width of the column when it was first "encountered"
     */
    "sWidthOrig": null,
    /** Cached string which is the longest in the column */
    maxLenString: null,
    /**
     * Store for named searches
     */
    searchFixed: null
  };
  DataTable5.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     */
    "aaData": null,
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     */
    "aaSorting": [[0, "asc"]],
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     */
    "aaSortingFixed": [],
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     */
    "ajax": null,
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     */
    "aLengthMenu": [10, 25, 50, 100],
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     */
    "aoColumns": null,
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     */
    "aoColumnDefs": null,
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     */
    "aoSearchCols": [],
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     */
    "bAutoWidth": true,
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     */
    "bDeferRender": true,
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     */
    "bDestroy": false,
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     */
    "bFilter": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bInfo": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bLengthChange": true,
    /**
     * Enable or disable pagination.
     */
    "bPaginate": true,
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     */
    "bProcessing": false,
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     */
    "bRetrieve": false,
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     */
    "bScrollCollapse": false,
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     */
    "bServerSide": false,
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     */
    "bSort": true,
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     */
    "bSortMulti": true,
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     */
    "bSortCellsTop": null,
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     */
    "bSortClasses": true,
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     */
    "bStateSave": false,
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     */
    "fnCreatedRow": null,
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     */
    "fnDrawCallback": null,
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     */
    "fnFooterCallback": null,
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     */
    "fnFormatNumber": function(toFormat) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     */
    "fnHeaderCallback": null,
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     */
    "fnInfoCallback": null,
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     */
    "fnInitComplete": null,
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     */
    "fnPreDrawCallback": null,
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     */
    "fnRowCallback": null,
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateLoadCallback": function(settings) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            "DataTables_" + settings.sInstance + "_" + location.pathname
          )
        );
      } catch (e) {
        return {};
      }
    },
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     */
    "fnStateLoadParams": null,
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     */
    "fnStateLoaded": null,
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateSaveCallback": function(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname,
          JSON.stringify(data)
        );
      } catch (e) {
      }
    },
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     */
    "fnStateSaveParams": null,
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     */
    "iStateDuration": 7200,
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     */
    "iDisplayLength": 10,
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     */
    "iDisplayStart": 0,
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     */
    "iTabIndex": 0,
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     */
    "oClasses": {},
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be sorted
         */
        "orderable": ": Activate to sort",
        /**
         * ARIA label that is added to the table headers when the column is currently being sorted
         */
        "orderableReverse": ": Activate to invert sorting",
        /**
         * ARIA label that is added to the table headers when the column is currently being 
         * sorted and next step is to remove sorting
         */
        "orderableRemove": ": Activate to remove sorting",
        paginate: {
          first: "First",
          last: "Last",
          next: "Next",
          previous: "Previous"
        }
      },
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       */
      "oPaginate": {
        /**
         * Label and character for first page button ()
         */
        "sFirst": "\xAB",
        /**
         * Last page button ()
         */
        "sLast": "\xBB",
        /**
         * Next page button ()
         */
        "sNext": "\u203A",
        /**
         * Previous page button ()
         */
        "sPrevious": "\u2039"
      },
      /**
       * Plural object for the data type the table is showing
       */
      entries: {
        _: "entries",
        1: "entry"
      },
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       */
      "sEmptyTable": "No data available in table",
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       */
      "sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       */
      "sInfoPostFix": "",
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       */
      "sDecimal": "",
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       */
      "sThousands": ",",
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       */
      "sLengthMenu": "_MENU_ _ENTRIES_ per page",
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       */
      "sLoadingRecords": "Loading...",
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       */
      "sProcessing": "",
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       */
      "sSearch": "Search:",
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       */
      "sUrl": "",
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       */
      "sZeroRecords": "No matching records found"
    },
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     */
    "oSearch": $9.extend({}, DataTable5.models.oSearch),
    /**
     * Table and control layout. This replaces the legacy `dom` option.
     */
    layout: {
      topStart: "pageLength",
      topEnd: "search",
      bottomStart: "info",
      bottomEnd: "paging"
    },
    /**
     * Legacy DOM layout option
     */
    "sDom": null,
    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     */
    "searchDelay": null,
    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     */
    "sPaginationType": "full_numbers",
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     */
    "sScrollX": "",
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     */
    "sScrollXInner": "",
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     */
    "sScrollY": "",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     */
    "sServerMethod": "GET",
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     */
    "renderer": null,
    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     */
    "rowId": "DT_RowId",
    /**
     * Caption value
     */
    "caption": null
  };
  _fnHungarianMap5(DataTable5.defaults);
  DataTable5.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     */
    "aDataSort": null,
    "iDataSort": -1,
    ariaTitle: "",
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     */
    "asSorting": ["asc", "desc", ""],
    /**
     * Enable or disable filtering on the data in this column.
     */
    "bSearchable": true,
    /**
     * Enable or disable ordering on this column.
     */
    "bSortable": true,
    /**
     * Enable or disable the display of this column.
     */
    "bVisible": true,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     */
    "mData": null,
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     */
    "mRender": null,
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     */
    "sCellType": "td",
    /**
     * Class to give to each cell in this column.
     */
    "sClass": "",
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     */
    "sContentPadding": "",
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     */
    "sName": "",
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     */
    "sSortDataType": "std",
    /**
     * The title of this column.
     */
    "sTitle": null,
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     */
    "sType": null,
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     */
    "sWidth": null
  };
  _fnHungarianMap5(DataTable5.defaults.column);
  DataTable5.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bAutoWidth": null,
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all for DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bDeferRender": null,
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bFilter": null,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bInfo": true,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bLengthChange": true,
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bPaginate": null,
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bProcessing": null,
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bServerSide": null,
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSort": null,
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortMulti": null,
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortClasses": null,
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bStateSave": null
    },
    /**
     * Scrolling settings for a table.
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bCollapse": null,
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       */
      "iBarWidth": 0,
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sX": null,
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @deprecated
       */
      "sXInner": null,
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sY": null
    },
    /**
     * Language information for the table.
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       */
      "fnInfoCallback": null
    },
    /**
     * Browser support parameters
     */
    "oBrowser": {
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       */
      "bScrollbarLeft": false,
      /**
       * Browser scrollbar width
       */
      "barWidth": 0
    },
    "ajax": null,
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     */
    "aanFeatures": [],
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     */
    "aoData": [],
    /**
     * Array of indexes which are in the current display (after filtering etc)
     */
    "aiDisplay": [],
    /**
     * Array of indexes for display - no filtering
     */
    "aiDisplayMaster": [],
    /**
     * Map of row ids to data indexes
     */
    "aIds": {},
    /**
     * Store information about each column that is in use
     */
    "aoColumns": [],
    /**
     * Store information about the table's header
     */
    "aoHeader": [],
    /**
     * Store information about the table's footer
     */
    "aoFooter": [],
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "oPreviousSearch": {},
    /**
     * Store for named searches
     */
    searchFixed: {},
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     */
    "aoPreSearchCols": [],
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSorting": null,
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSortingFixed": [],
    /**
     * If restoring a table - we should restore its width
     */
    "sDestroyWidth": 0,
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     */
    "aoRowCallback": [],
    /**
     * Callback functions for the header on each draw.
     */
    "aoHeaderCallback": [],
    /**
     * Callback function for the footer on each draw.
     */
    "aoFooterCallback": [],
    /**
     * Array of callback functions for draw callback functions
     */
    "aoDrawCallback": [],
    /**
     * Array of callback functions for row created function
     */
    "aoRowCreatedCallback": [],
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     */
    "aoPreDrawCallback": [],
    /**
     * Callback functions for when the table has been initialised.
     */
    "aoInitComplete": [],
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     */
    "aoStateSaveParams": [],
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     */
    "aoStateLoadParams": [],
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     */
    "aoStateLoaded": [],
    /**
     * Cache the table ID for quick access
     */
    "sTableId": "",
    /**
     * The TABLE node for the main table
     */
    "nTable": null,
    /**
     * Permanent ref to the thead element
     */
    "nTHead": null,
    /**
     * Permanent ref to the tfoot element - if it exists
     */
    "nTFoot": null,
    /**
     * Permanent ref to the tbody element
     */
    "nTBody": null,
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     */
    "nTableWrapper": null,
    /**
     * Indicate if all required information has been read in
     */
    "bInitialised": false,
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     */
    "aoOpenRows": [],
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sDom": null,
    /**
     * Search delay (in mS)
     */
    "searchDelay": null,
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sPaginationType": "two_button",
    /**
     * Number of paging controls on the page. Only used for backwards compatibility
     */
    pagingControls: 0,
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "iStateDuration": 0,
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateSave": [],
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateLoad": [],
    /**
     * State that was saved. Useful for back reference
     */
    "oSavedState": null,
    /**
     * State that was loaded. Useful for back reference
     */
    "oLoadedState": null,
    /**
     * Note if draw should be blocked while getting data
     */
    "bAjaxDataGet": true,
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     */
    "jqXHR": null,
    /**
     * JSON returned from the server in the last Ajax request
     */
    "json": void 0,
    /**
     * Data submitted as part of the last Ajax request
     */
    "oAjaxData": void 0,
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sServerMethod": null,
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "fnFormatNumber": null,
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aLengthMenu": null,
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     */
    "iDraw": 0,
    /**
     * Indicate if a redraw is being done - useful for Ajax
     */
    "bDrawing": false,
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     */
    "iDrawError": -1,
    /**
     * Paging display length
     */
    "_iDisplayLength": 10,
    /**
     * Paging start point - aiDisplay index
     */
    "_iDisplayStart": 0,
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsTotal": 0,
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsDisplay": 0,
    /**
     * The classes to use for the table
     */
    "oClasses": {},
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bFiltered": false,
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bSorted": false,
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSortCellsTop": null,
    /**
     * Initialisation object that is used for the table
     */
    "oInit": null,
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     */
    "aoDestroyCallback": [],
    /**
     * Get the number of records in the current record set, before filtering
     */
    "fnRecordsTotal": function() {
      return _fnDataSource5(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },
    /**
     * Get the number of records in the current record set, after filtering
     */
    "fnRecordsDisplay": function() {
      return _fnDataSource5(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },
    /**
     * Get the display end point - aiDisplay index
     */
    "fnDisplayEnd": function() {
      var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },
    /**
     * The DataTables object for this table
     */
    "oInstance": null,
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     */
    "sInstance": null,
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
    /**
     * Last applied sort
     */
    "aLastSort": [],
    /**
     * Stored plug-in instances
     */
    "oPlugins": {},
    /**
     * Function used to get a row's id from the row's data
     */
    "rowIdFn": null,
    /**
     * Data location where to store a row's id
     */
    "rowId": null,
    caption: "",
    captionNode: null,
    colgroup: null
  };
  var extPagination5 = DataTable5.ext.pager;
  $9.extend(extPagination5, {
    simple: function() {
      return ["previous", "next"];
    },
    full: function() {
      return ["first", "previous", "next", "last"];
    },
    numbers: function() {
      return ["numbers"];
    },
    simple_numbers: function() {
      return ["previous", "numbers", "next"];
    },
    full_numbers: function() {
      return ["first", "previous", "numbers", "next", "last"];
    },
    first_last: function() {
      return ["first", "last"];
    },
    first_last_numbers: function() {
      return ["first", "numbers", "last"];
    },
    // For testing and plug-ins to use
    _numbers: _pagingNumbers5,
    // Number of number buttons - legacy, use `numbers` option for paging feature
    numbers_length: 7
  });
  $9.extend(true, DataTable5.ext.renderer, {
    pagingButton: {
      _: function(settings, buttonType, content, active, disabled) {
        var classes = settings.oClasses.paging;
        var btnClasses = [classes.button];
        var btn;
        if (active) {
          btnClasses.push(classes.active);
        }
        if (disabled) {
          btnClasses.push(classes.disabled);
        }
        if (buttonType === "ellipsis") {
          btn = $9('<span class="ellipsis"></span>').html(content)[0];
        } else {
          btn = $9("<button>", {
            class: btnClasses.join(" "),
            role: "link",
            type: "button"
          }).html(content);
        }
        return {
          display: btn,
          clicker: btn
        };
      }
    },
    pagingContainer: {
      _: function(settings, buttons) {
        return buttons;
      }
    }
  });
  var _filterString5 = function(stripHtml, normalize) {
    return function(str) {
      if (_empty5(str) || typeof str !== "string") {
        return str;
      }
      str = str.replace(_re_new_lines5, " ");
      if (stripHtml) {
        str = _stripHtml5(str);
      }
      if (normalize) {
        str = _normalize5(str, false);
      }
      return str;
    };
  };
  function __mldFnName4(name) {
    return name.replace(/[\W]/g, "_");
  }
  function __mld5(dt, momentFn, luxonFn, dateFn, arg1) {
    if (window.moment) {
      return dt[momentFn](arg1);
    } else if (window.luxon) {
      return dt[luxonFn](arg1);
    }
    return dateFn ? dt[dateFn](arg1) : dt;
  }
  var __mlWarning5 = false;
  function __mldObj5(d, format, locale) {
    var dt;
    if (window.moment) {
      dt = window.moment.utc(d, format, locale, true);
      if (!dt.isValid()) {
        return null;
      }
    } else if (window.luxon) {
      dt = format && typeof d === "string" ? window.luxon.DateTime.fromFormat(d, format) : window.luxon.DateTime.fromISO(d);
      if (!dt.isValid) {
        return null;
      }
      dt.setLocale(locale);
    } else if (!format) {
      dt = new Date(d);
    } else {
      if (!__mlWarning5) {
        alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
      }
      __mlWarning5 = true;
    }
    return dt;
  }
  function __mlHelper5(localeString) {
    return function(from, to, locale, def) {
      if (arguments.length === 0) {
        locale = "en";
        to = null;
        from = null;
      } else if (arguments.length === 1) {
        locale = "en";
        to = from;
        from = null;
      } else if (arguments.length === 2) {
        locale = to;
        to = from;
        from = null;
      }
      var typeName = "datetime" + (to ? "-" + __mldFnName4(to) : "");
      if (!DataTable5.ext.type.order[typeName]) {
        DataTable5.type(typeName, {
          detect: function(d) {
            return d === typeName ? typeName : false;
          },
          order: {
            pre: function(d) {
              return d.valueOf();
            }
          },
          className: "dt-right"
        });
      }
      return function(d, type) {
        if (d === null || d === void 0) {
          if (def === "--now") {
            var local = /* @__PURE__ */ new Date();
            d = new Date(Date.UTC(
              local.getFullYear(),
              local.getMonth(),
              local.getDate(),
              local.getHours(),
              local.getMinutes(),
              local.getSeconds()
            ));
          } else {
            d = "";
          }
        }
        if (type === "type") {
          return typeName;
        }
        if (d === "") {
          return type !== "sort" ? "" : __mldObj5("0000-01-01 00:00:00", null, locale);
        }
        if (to !== null && from === to && type !== "sort" && type !== "type" && !(d instanceof Date)) {
          return d;
        }
        var dt = __mldObj5(d, from, locale);
        if (dt === null) {
          return d;
        }
        if (type === "sort") {
          return dt;
        }
        var formatted = to === null ? __mld5(dt, "toDate", "toJSDate", "")[localeString]() : __mld5(dt, "format", "toFormat", "toISOString", to);
        return type === "display" ? _escapeHtml5(formatted) : formatted;
      };
    };
  }
  var __thousands5 = ",";
  var __decimal5 = ".";
  if (window.Intl !== void 0) {
    try {
      num = new Intl.NumberFormat().formatToParts(100000.1);
      for (i = 0; i < num.length; i++) {
        if (num[i].type === "group") {
          __thousands5 = num[i].value;
        } else if (num[i].type === "decimal") {
          __decimal5 = num[i].value;
        }
      }
    } catch (e) {
    }
  }
  var num;
  var i;
  DataTable5.datetime = function(format, locale) {
    var typeName = "datetime-detect-" + __mldFnName4(format);
    if (!locale) {
      locale = "en";
    }
    if (!DataTable5.ext.type.order[typeName]) {
      DataTable5.type(typeName, {
        detect: function(d) {
          var dt = __mldObj5(d, format, locale);
          return d === "" || dt ? typeName : false;
        },
        order: {
          pre: function(d) {
            return __mldObj5(d, format, locale) || 0;
          }
        },
        className: "dt-right"
      });
    }
  };
  DataTable5.render = {
    date: __mlHelper5("toLocaleDateString"),
    datetime: __mlHelper5("toLocaleString"),
    time: __mlHelper5("toLocaleTimeString"),
    number: function(thousands, decimal, precision, prefix, postfix) {
      if (thousands === null || thousands === void 0) {
        thousands = __thousands5;
      }
      if (decimal === null || decimal === void 0) {
        decimal = __decimal5;
      }
      return {
        display: function(d) {
          if (typeof d !== "number" && typeof d !== "string") {
            return d;
          }
          if (d === "" || d === null) {
            return d;
          }
          var negative = d < 0 ? "-" : "";
          var flo = parseFloat(d);
          var abs = Math.abs(flo);
          if (abs >= 1e11 || abs < 1e-4 && abs !== 0) {
            var exp = flo.toExponential(precision).split(/e\+?/);
            return exp[0] + " x 10<sup>" + exp[1] + "</sup>";
          }
          if (isNaN(flo)) {
            return _escapeHtml5(d);
          }
          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
          if (intPart === 0 && parseFloat(floatPart) === 0) {
            negative = "";
          }
          return negative + (prefix || "") + intPart.toString().replace(
            /\B(?=(\d{3})+(?!\d))/g,
            thousands
          ) + floatPart + (postfix || "");
        }
      };
    },
    text: function() {
      return {
        display: _escapeHtml5,
        filter: _escapeHtml5
      };
    }
  };
  var _extTypes5 = DataTable5.ext.type;
  DataTable5.type = function(name, prop, val) {
    if (!prop) {
      return {
        className: _extTypes5.className[name],
        detect: _extTypes5.detect.find(function(fn) {
          return fn.name === name;
        }),
        order: {
          pre: _extTypes5.order[name + "-pre"],
          asc: _extTypes5.order[name + "-asc"],
          desc: _extTypes5.order[name + "-desc"]
        },
        render: _extTypes5.render[name],
        search: _extTypes5.search[name]
      };
    }
    var setProp = function(prop2, propVal) {
      _extTypes5[prop2][name] = propVal;
    };
    var setDetect = function(fn) {
      var cb = function(d, s) {
        var ret = fn(d, s);
        return ret === true ? name : ret;
      };
      Object.defineProperty(cb, "name", { value: name });
      var idx = _extTypes5.detect.findIndex(function(fn2) {
        return fn2.name === name;
      });
      if (idx === -1) {
        _extTypes5.detect.unshift(cb);
      } else {
        _extTypes5.detect.splice(idx, 1, cb);
      }
    };
    var setOrder = function(obj) {
      _extTypes5.order[name + "-pre"] = obj.pre;
      _extTypes5.order[name + "-asc"] = obj.asc;
      _extTypes5.order[name + "-desc"] = obj.desc;
    };
    if (val === void 0) {
      val = prop;
      prop = null;
    }
    if (prop === "className") {
      setProp("className", val);
    } else if (prop === "detect") {
      setDetect(val);
    } else if (prop === "order") {
      setOrder(val);
    } else if (prop === "render") {
      setProp("render", val);
    } else if (prop === "search") {
      setProp("search", val);
    } else if (!prop) {
      if (val.className) {
        setProp("className", val.className);
      }
      if (val.detect !== void 0) {
        setDetect(val.detect);
      }
      if (val.order) {
        setOrder(val.order);
      }
      if (val.render !== void 0) {
        setProp("render", val.render);
      }
      if (val.search !== void 0) {
        setProp("search", val.search);
      }
    }
  };
  DataTable5.types = function() {
    return _extTypes5.detect.map(function(fn) {
      return fn.name;
    });
  };
  DataTable5.type("string", {
    detect: function() {
      return "string";
    },
    order: {
      pre: function(a) {
        return _empty5(a) ? "" : typeof a === "string" ? a.toLowerCase() : !a.toString ? "" : a.toString();
      }
    },
    search: _filterString5(false, true)
  });
  DataTable5.type("html", {
    detect: function(d) {
      return _empty5(d) || typeof d === "string" && d.indexOf("<") !== -1 ? "html" : null;
    },
    order: {
      pre: function(a) {
        return _empty5(a) ? "" : a.replace ? _stripHtml5(a).trim().toLowerCase() : a + "";
      }
    },
    search: _filterString5(true, true)
  });
  DataTable5.type("date", {
    className: "dt-type-date",
    detect: function(d) {
      if (d && !(d instanceof Date) && !_re_date5.test(d)) {
        return null;
      }
      var parsed = Date.parse(d);
      return parsed !== null && !isNaN(parsed) || _empty5(d) ? "date" : null;
    },
    order: {
      pre: function(d) {
        var ts = Date.parse(d);
        return isNaN(ts) ? -Infinity : ts;
      }
    }
  });
  DataTable5.type("html-num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric5(d, decimal, true) ? "html-num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace5(d, dp, _re_html5, _re_formatted_numeric5);
      }
    },
    search: _filterString5(true, true)
  });
  DataTable5.type("html-num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric5(d, decimal) ? "html-num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace5(d, dp, _re_html5);
      }
    },
    search: _filterString5(true, true)
  });
  DataTable5.type("num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber5(d, decimal, true) ? "num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace5(d, dp, _re_formatted_numeric5);
      }
    }
  });
  DataTable5.type("num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber5(d, decimal) ? "num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace5(d, dp);
      }
    }
  });
  var __numericReplace5 = function(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === "-")) {
      return -Infinity;
    }
    var type = typeof d;
    if (type === "number" || type === "bigint") {
      return d;
    }
    if (decimalPlace) {
      d = _numToDecimal5(d, decimalPlace);
    }
    if (d.replace) {
      if (re1) {
        d = d.replace(re1, "");
      }
      if (re2) {
        d = d.replace(re2, "");
      }
    }
    return d * 1;
  };
  $9.extend(true, DataTable5.ext.renderer, {
    footer: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.tfoot.cell);
      }
    },
    header: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.thead.cell);
        if (!settings.oFeatures.bSort) {
          cell.addClass(classes.order.none);
        }
        var legacyTop = settings.bSortCellsTop;
        var headerRows = cell.closest("thead").find("tr");
        var rowIdx = cell.parent().index();
        if (
          // Cells and rows which have the attribute to disable the icons
          cell.attr("data-dt-order") === "disable" || cell.parent().attr("data-dt-order") === "disable" || // Legacy support for `orderCellsTop`. If it is set, then cells
          // which are not in the top or bottom row of the header (depending
          // on the value) do not get the sorting classes applied to them
          legacyTop === true && rowIdx !== 0 || legacyTop === false && rowIdx !== headerRows.length - 1
        ) {
          return;
        }
        $9(settings.nTable).on("order.dt.DT", function(e, ctx, sorting) {
          if (settings !== ctx) {
            return;
          }
          var orderClasses = classes.order;
          var columns = ctx.api.columns(cell);
          var col = settings.aoColumns[columns.flatten()[0]];
          var orderable = columns.orderable().includes(true);
          var ariaType = "";
          var indexes = columns.indexes();
          var sortDirs = columns.orderable(true).flatten();
          var orderedColumns = "," + sorting.map(function(val) {
            return val.col;
          }).join(",") + ",";
          cell.removeClass(
            orderClasses.isAsc + " " + orderClasses.isDesc
          ).toggleClass(orderClasses.none, !orderable).toggleClass(orderClasses.canAsc, orderable && sortDirs.includes("asc")).toggleClass(orderClasses.canDesc, orderable && sortDirs.includes("desc"));
          var sortIdx = orderedColumns.indexOf("," + indexes.toArray().join(",") + ",");
          if (sortIdx !== -1) {
            var orderDirs = columns.order();
            cell.addClass(
              orderDirs.includes("asc") ? orderClasses.isAsc : "" + orderDirs.includes("desc") ? orderClasses.isDesc : ""
            );
          }
          if (sortIdx === 0) {
            var firstSort = sorting[0];
            var sortOrder = col.asSorting;
            cell.attr("aria-sort", firstSort.dir === "asc" ? "ascending" : "descending");
            ariaType = !sortOrder[firstSort.index + 1] ? "Remove" : "Reverse";
          } else {
            cell.removeAttr("aria-sort");
          }
          cell.attr(
            "aria-label",
            orderable ? col.ariaTitle + ctx.api.i18n("oAria.orderable" + ariaType) : col.ariaTitle
          );
          if (orderable) {
            cell.find(".dt-column-title").attr("role", "button");
            cell.attr("tabindex", 0);
          }
        });
      }
    },
    layout: {
      _: function(settings, container, items) {
        var row = $9("<div/>").addClass("dt-layout-row").appendTo(container);
        $9.each(items, function(key, val) {
          var klass = !val.table ? "dt-" + key + " " : "";
          if (val.table) {
            row.addClass("dt-layout-table");
          }
          $9("<div/>").attr({
            id: val.id || null,
            "class": "dt-layout-cell " + klass + (val.className || "")
          }).append(val.contents).appendTo(row);
        });
      }
    }
  });
  DataTable5.feature = {};
  DataTable5.feature.register = function(name, cb, legacy) {
    DataTable5.ext.features[name] = cb;
    if (legacy) {
      _ext5.feature.push({
        cFeature: legacy,
        fnInit: cb
      });
    }
  };
  DataTable5.feature.register("info", function(settings, opts) {
    if (!settings.oFeatures.bInfo) {
      return null;
    }
    var lang = settings.oLanguage, tid = settings.sTableId, n = $9("<div/>", {
      "class": settings.oClasses.info.container
    });
    opts = $9.extend({
      callback: lang.fnInfoCallback,
      empty: lang.sInfoEmpty,
      postfix: lang.sInfoPostFix,
      search: lang.sInfoFiltered,
      text: lang.sInfo
    }, opts);
    settings.aoDrawCallback.push(function(s) {
      _fnUpdateInfo5(s, opts, n);
    });
    if (!settings._infoEl) {
      n.attr({
        "aria-live": "polite",
        id: tid + "_info",
        role: "status"
      });
      $9(settings.nTable).attr("aria-describedby", tid + "_info");
      settings._infoEl = n;
    }
    return n;
  }, "i");
  function _fnUpdateInfo5(settings, opts, node) {
    var start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? opts.text : opts.empty;
    if (total !== max) {
      out += " " + opts.search;
    }
    out += opts.postfix;
    out = _fnMacros5(settings, out);
    if (opts.callback) {
      out = opts.callback.call(
        settings.oInstance,
        settings,
        start,
        end,
        max,
        total,
        out
      );
    }
    node.html(out);
    _fnCallbackFire5(settings, null, "info", [settings, node[0], out]);
  }
  var __searchCounter5 = 0;
  DataTable5.feature.register("search", function(settings, opts) {
    if (!settings.oFeatures.bFilter) {
      return null;
    }
    var classes = settings.oClasses.search;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var input = '<input type="search" class="' + classes.input + '"/>';
    opts = $9.extend({
      placeholder: language.sSearchPlaceholder,
      text: language.sSearch
    }, opts);
    if (opts.text.indexOf("_INPUT_") === -1) {
      opts.text += "_INPUT_";
    }
    opts.text = _fnMacros5(settings, opts.text);
    var end = opts.text.match(/_INPUT_$/);
    var start = opts.text.match(/^_INPUT_/);
    var removed = opts.text.replace(/_INPUT_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_INPUT_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_INPUT_";
    }
    var filter = $9("<div>").addClass(classes.container).append(str.replace(/_INPUT_/, input));
    filter.find("label").attr("for", "dt-search-" + __searchCounter5);
    filter.find("input").attr("id", "dt-search-" + __searchCounter5);
    __searchCounter5++;
    var searchFn = function(event) {
      var val = this.value;
      if (previousSearch.return && event.key !== "Enter") {
        return;
      }
      if (val != previousSearch.search) {
        previousSearch.search = val;
        _fnFilterComplete5(settings, previousSearch);
        settings._iDisplayStart = 0;
        _fnDraw5(settings);
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : 0;
    var jqFilter = $9("input", filter).val(previousSearch.search).attr("placeholder", opts.placeholder).on(
      "keyup.DT search.DT input.DT paste.DT cut.DT",
      searchDelay ? DataTable5.util.debounce(searchFn, searchDelay) : searchFn
    ).on("mouseup.DT", function(e) {
      setTimeout(function() {
        searchFn.call(jqFilter[0], e);
      }, 10);
    }).on("keypress.DT", function(e) {
      if (e.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $9(settings.nTable).on("search.dt.DT", function(ev, s) {
      if (settings === s && jqFilter[0] !== document.activeElement) {
        jqFilter.val(
          typeof previousSearch.search !== "function" ? previousSearch.search : ""
        );
      }
    });
    return filter;
  }, "f");
  DataTable5.feature.register("paging", function(settings, opts) {
    if (!settings.oFeatures.bPaginate) {
      return null;
    }
    opts = $9.extend({
      buttons: DataTable5.ext.pager.numbers_length,
      type: settings.sPaginationType,
      boundaryNumbers: true
    }, opts);
    if (opts.numbers) {
      opts.buttons = opts.numbers;
    }
    var host = $9("<div/>").addClass(settings.oClasses.paging.container + " paging_" + opts.type);
    var draw = function() {
      _pagingDraw5(settings, host, opts);
    };
    settings.aoDrawCallback.push(draw);
    $9(settings.nTable).on("column-sizing.dt.DT", draw);
    return host;
  }, "p");
  function _pagingDraw5(settings, host, opts) {
    if (!settings._bInitComplete) {
      return;
    }
    var plugin = DataTable5.ext.pager[opts.type], aria = settings.oLanguage.oAria.paginate || {}, start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin().map(function(val) {
      return val === "numbers" ? _pagingNumbers5(page, pages, opts.buttons, opts.boundaryNumbers) : val;
    }).flat();
    var buttonEls = [];
    for (var i = 0; i < buttons.length; i++) {
      var button = buttons[i];
      var btnInfo = _pagingButtonInfo5(settings, button, page, pages);
      var btn = _fnRenderer5(settings, "pagingButton")(
        settings,
        button,
        btnInfo.display,
        btnInfo.active,
        btnInfo.disabled
      );
      $9(btn.clicker).attr({
        "aria-controls": settings.sTableId,
        "aria-disabled": btnInfo.disabled ? "true" : null,
        "aria-current": btnInfo.active ? "page" : null,
        "aria-label": aria[button],
        "data-dt-idx": button,
        "tabIndex": btnInfo.disabled ? -1 : settings.iTabIndex
      });
      if (typeof button !== "number") {
        $9(btn.clicker).addClass(button);
      }
      _fnBindAction5(
        btn.clicker,
        { action: button },
        function(e) {
          e.preventDefault();
          _fnPageChange5(settings, e.data.action, true);
        }
      );
      buttonEls.push(btn.display);
    }
    var wrapped = _fnRenderer5(settings, "pagingContainer")(
      settings,
      buttonEls
    );
    var activeEl = host.find(document.activeElement).data("dt-idx");
    host.empty().append(wrapped);
    if (activeEl !== void 0) {
      host.find("[data-dt-idx=" + activeEl + "]").trigger("focus");
    }
    if (buttonEls.length && // any buttons
    opts.numbers > 1 && // prevent infinite
    $9(host).height() >= $9(buttonEls[0]).outerHeight() * 2 - 10) {
      _pagingDraw5(settings, host, $9.extend({}, opts, { numbers: opts.numbers - 2 }));
    }
  }
  function _pagingButtonInfo5(settings, button, page, pages) {
    var lang = settings.oLanguage.oPaginate;
    var o = {
      display: "",
      active: false,
      disabled: false
    };
    switch (button) {
      case "ellipsis":
        o.display = "&#x2026;";
        o.disabled = true;
        break;
      case "first":
        o.display = lang.sFirst;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "previous":
        o.display = lang.sPrevious;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "next":
        o.display = lang.sNext;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      case "last":
        o.display = lang.sLast;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      default:
        if (typeof button === "number") {
          o.display = settings.fnFormatNumber(button + 1);
          if (page === button) {
            o.active = true;
          }
        }
        break;
    }
    return o;
  }
  function _pagingNumbers5(page, pages, buttons, addFirstLast) {
    var numbers = [], half = Math.floor(buttons / 2), before = addFirstLast ? 2 : 1, after = addFirstLast ? 1 : 0;
    if (pages <= buttons) {
      numbers = _range5(0, pages);
    } else if (buttons === 1) {
      numbers = [page];
    } else if (buttons === 3) {
      if (page <= 1) {
        numbers = [0, 1, "ellipsis"];
      } else if (page >= pages - 2) {
        numbers = _range5(pages - 2, pages);
        numbers.unshift("ellipsis");
      } else {
        numbers = ["ellipsis", page, "ellipsis"];
      }
    } else if (page <= half) {
      numbers = _range5(0, buttons - before);
      numbers.push("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
      }
    } else if (page >= pages - 1 - half) {
      numbers = _range5(pages - (buttons - before), pages);
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.unshift(0);
      }
    } else {
      numbers = _range5(page - half + before, page + half - after);
      numbers.push("ellipsis");
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
        numbers.unshift(0);
      }
    }
    return numbers;
  }
  var __lengthCounter5 = 0;
  DataTable5.feature.register("pageLength", function(settings, opts) {
    var features = settings.oFeatures;
    if (!features.bPaginate || !features.bLengthChange) {
      return null;
    }
    opts = $9.extend({
      menu: settings.aLengthMenu,
      text: settings.oLanguage.sLengthMenu
    }, opts);
    var classes = settings.oClasses.length, tableId = settings.sTableId, menu = opts.menu, lengths = [], language = [], i;
    if (Array.isArray(menu[0])) {
      lengths = menu[0];
      language = menu[1];
    } else {
      for (i = 0; i < menu.length; i++) {
        if ($9.isPlainObject(menu[i])) {
          lengths.push(menu[i].value);
          language.push(menu[i].label);
        } else {
          lengths.push(menu[i]);
          language.push(menu[i]);
        }
      }
    }
    var end = opts.text.match(/_MENU_$/);
    var start = opts.text.match(/^_MENU_/);
    var removed = opts.text.replace(/_MENU_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_MENU_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_MENU_";
    }
    var div = $9("<div/>").addClass(classes.container).append(
      str.replace("_MENU_", "<span></span>")
    );
    var textNodes = [];
    div.find("label")[0].childNodes.forEach(function(el) {
      if (el.nodeType === Node.TEXT_NODE) {
        textNodes.push({
          el,
          text: el.textContent
        });
      }
    });
    var updateEntries = function(len) {
      textNodes.forEach(function(node) {
        node.el.textContent = _fnMacros5(settings, node.text, len);
      });
    };
    var select = $9("<select/>", {
      "name": tableId + "_length",
      "aria-controls": tableId,
      "class": classes.select
    });
    for (i = 0; i < lengths.length; i++) {
      select[0][i] = new Option(
        typeof language[i] === "number" ? settings.fnFormatNumber(language[i]) : language[i],
        lengths[i]
      );
    }
    div.find("label").attr("for", "dt-length-" + __lengthCounter5);
    select.attr("id", "dt-length-" + __lengthCounter5);
    __lengthCounter5++;
    div.find("span").replaceWith(select);
    $9("select", div).val(settings._iDisplayLength).on("change.DT", function() {
      _fnLengthChange5(settings, $9(this).val());
      _fnDraw5(settings);
    });
    $9(settings.nTable).on("length.dt.DT", function(e, s, len) {
      if (settings === s) {
        $9("select", div).val(len);
        updateEntries(len);
      }
    });
    updateEntries(settings._iDisplayLength);
    return div;
  }, "l");
  $9.fn.dataTable = DataTable5;
  DataTable5.$ = $9;
  $9.fn.dataTableSettings = DataTable5.settings;
  $9.fn.dataTableExt = DataTable5.ext;
  $9.fn.DataTable = function(opts) {
    return $9(this).dataTable(opts).api();
  };
  $9.each(DataTable5, function(prop, val) {
    $9.fn.DataTable[prop] = val;
  });
  var dataTables_default5 = DataTable5;

  // node_modules/datatables.net-fixedheader/js/dataTables.fixedHeader.mjs
  var $10 = import_jquery11.default;
  var _instCounter = 0;
  var FixedHeader = function(dt, config) {
    if (!dataTables_default5.versionCheck("2")) {
      throw "Warning: FixedHeader requires DataTables 2 or newer";
    }
    if (!(this instanceof FixedHeader)) {
      throw "FixedHeader must be initialised with the 'new' keyword.";
    }
    if (config === true) {
      config = {};
    }
    dt = new dataTables_default5.Api(dt);
    this.c = $10.extend(true, {}, FixedHeader.defaults, config);
    this.s = {
      dt,
      position: {
        theadTop: 0,
        tbodyTop: 0,
        tfootTop: 0,
        tfootBottom: 0,
        width: 0,
        left: 0,
        tfootHeight: 0,
        theadHeight: 0,
        windowHeight: $10(window).height(),
        visible: true
      },
      headerMode: null,
      footerMode: null,
      autoWidth: dt.settings()[0].oFeatures.bAutoWidth,
      namespace: ".dtfc" + _instCounter++,
      scrollLeft: {
        header: -1,
        footer: -1
      },
      enable: true,
      autoDisable: false
    };
    this.dom = {
      floatingHeader: null,
      thead: $10(dt.table().header()),
      tbody: $10(dt.table().body()),
      tfoot: $10(dt.table().footer()),
      header: {
        host: null,
        floating: null,
        floatingParent: $10('<div class="dtfh-floatingparent"><div></div></div>'),
        placeholder: null
      },
      footer: {
        host: null,
        floating: null,
        floatingParent: $10('<div class="dtfh-floatingparent"><div></div></div>'),
        placeholder: null
      }
    };
    this.dom.header.host = this.dom.thead.parent();
    this.dom.footer.host = this.dom.tfoot.parent();
    var dtSettings = dt.settings()[0];
    if (dtSettings._fixedHeader) {
      throw "FixedHeader already initialised on table " + dtSettings.nTable.id;
    }
    dtSettings._fixedHeader = this;
    this._constructor();
  };
  $10.extend(FixedHeader.prototype, {
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * API methods
     */
    /**
     * Kill off FH and any events
     */
    destroy: function() {
      var dom = this.dom;
      this.s.dt.off(".dtfc");
      $10(window).off(this.s.namespace);
      if (dom.header.rightBlocker) {
        dom.header.rightBlocker.remove();
      }
      if (dom.header.leftBlocker) {
        dom.header.leftBlocker.remove();
      }
      if (dom.footer.rightBlocker) {
        dom.footer.rightBlocker.remove();
      }
      if (dom.footer.leftBlocker) {
        dom.footer.leftBlocker.remove();
      }
      if (this.c.header) {
        this._modeChange("in-place", "header", true);
      }
      if (this.c.footer && dom.tfoot.length) {
        this._modeChange("in-place", "footer", true);
      }
    },
    /**
     * Enable / disable the fixed elements
     *
     * @param  {boolean} enable `true` to enable, `false` to disable
     */
    enable: function(enable, update, type) {
      this.s.enable = enable;
      this.s.enableType = type;
      if (update || update === void 0) {
        this._positions();
        this._scroll(true);
      }
    },
    /**
     * Get enabled status
     */
    enabled: function() {
      return this.s.enable;
    },
    /**
     * Set header offset
     *
     * @param  {int} new value for headerOffset
     */
    headerOffset: function(offset) {
      if (offset !== void 0) {
        this.c.headerOffset = offset;
        this.update();
      }
      return this.c.headerOffset;
    },
    /**
     * Set footer offset
     *
     * @param  {int} new value for footerOffset
     */
    footerOffset: function(offset) {
      if (offset !== void 0) {
        this.c.footerOffset = offset;
        this.update();
      }
      return this.c.footerOffset;
    },
    /**
     * Recalculate the position of the fixed elements and force them into place
     */
    update: function(force) {
      var table = this.s.dt.table().node();
      if (!this.s.enable && !this.s.autoDisable) {
        return;
      }
      if ($10(table).is(":visible")) {
        this.s.autoDisable = false;
        this.enable(true, false);
      } else {
        this.s.autoDisable = true;
        this.enable(false, false);
      }
      if ($10(table).children("thead").length === 0) {
        return;
      }
      this._positions();
      this._scroll(force !== void 0 ? force : true);
      this._widths(this.dom.header);
      this._widths(this.dom.footer);
    },
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Constructor
     */
    /**
     * FixedHeader constructor - adding the required event listeners and
     * simple initialisation
     *
     * @private
     */
    _constructor: function() {
      var that = this;
      var dt = this.s.dt;
      $10(window).on("scroll" + this.s.namespace, function() {
        that._scroll();
      }).on(
        "resize" + this.s.namespace,
        dataTables_default5.util.throttle(function() {
          that.s.position.windowHeight = $10(window).height();
          that.update();
        }, 50)
      );
      var autoHeader = $10(".fh-fixedHeader");
      if (!this.c.headerOffset && autoHeader.length) {
        this.c.headerOffset = autoHeader.outerHeight();
      }
      var autoFooter = $10(".fh-fixedFooter");
      if (!this.c.footerOffset && autoFooter.length) {
        this.c.footerOffset = autoFooter.outerHeight();
      }
      dt.on(
        "column-reorder.dt.dtfc column-visibility.dt.dtfc column-sizing.dt.dtfc responsive-display.dt.dtfc",
        function(e, ctx) {
          that.update();
        }
      ).on("draw.dt.dtfc", function(e, ctx) {
        that.update(ctx === dt.settings()[0] ? false : true);
      });
      dt.on("destroy.dtfc", function() {
        that.destroy();
      });
      this._positions();
      this._scroll();
    },
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Private methods
     */
    /**
     * Clone a fixed item to act as a place holder for the original element
     * which is moved into a clone of the table element, and moved around the
     * document to give the fixed effect.
     *
     * @param  {string}  item  'header' or 'footer'
     * @param  {boolean} force Force the clone to happen, or allow automatic
     *   decision (reuse existing if available)
     * @private
     */
    _clone: function(item, force) {
      var that = this;
      var dt = this.s.dt;
      var itemDom = this.dom[item];
      var itemElement = item === "header" ? this.dom.thead : this.dom.tfoot;
      if (item === "footer" && this._scrollEnabled()) {
        return;
      }
      if (!force && itemDom.floating) {
        itemDom.floating.removeClass(
          "fixedHeader-floating fixedHeader-locked"
        );
      } else {
        if (itemDom.floating) {
          if (itemDom.placeholder !== null) {
            itemDom.placeholder.remove();
          }
          itemDom.floating.children().detach();
          itemDom.floating.remove();
        }
        var tableNode = $10(dt.table().node());
        var scrollBody = $10(tableNode.parent());
        var scrollEnabled = this._scrollEnabled();
        itemDom.floating = $10(dt.table().node().cloneNode(false)).attr("aria-hidden", "true").css({
          top: 0,
          left: 0
        }).removeAttr("id");
        itemDom.floatingParent.css({
          width: scrollBody[0].offsetWidth,
          overflow: "hidden",
          height: "fit-content",
          position: "fixed",
          left: scrollEnabled ? tableNode.offset().left + scrollBody.scrollLeft() : 0
        }).css(
          item === "header" ? {
            top: this.c.headerOffset,
            bottom: ""
          } : {
            top: "",
            bottom: this.c.footerOffset
          }
        ).addClass(
          item === "footer" ? "dtfh-floatingparent-foot" : "dtfh-floatingparent-head"
        ).appendTo("body").children().eq(0).append(itemDom.floating);
        this._stickyPosition(itemDom.floating, "-");
        var scrollLeftUpdate = function() {
          var scrollLeft = scrollBody.scrollLeft();
          that.s.scrollLeft = { footer: scrollLeft, header: scrollLeft };
          itemDom.floatingParent.scrollLeft(that.s.scrollLeft.header);
        };
        scrollLeftUpdate();
        scrollBody.off("scroll.dtfh").on("scroll.dtfh", scrollLeftUpdate);
        itemDom.floatingParent.children().css({
          width: "fit-content",
          paddingRight: that.s.dt.settings()[0].oBrowser.barWidth
        });
        let blocker = $10(
          item === "footer" ? "div.dtfc-bottom-blocker" : "div.dtfc-top-blocker",
          dt.table().container()
        );
        if (blocker.length) {
          blocker.clone().appendTo(itemDom.floatingParent).css({
            position: "fixed",
            right: blocker.width()
          });
        }
        itemDom.placeholder = itemElement.clone(false);
        itemDom.placeholder.find("*[id]").removeAttr("id");
        itemDom.host.prepend(itemDom.placeholder);
        itemDom.floating.append(itemElement);
        this._widths(itemDom);
      }
    },
    /**
     * This method sets the sticky position of the header elements to match fixed columns
     * @param {JQuery<HTMLElement>} el
     * @param {string} sign
     */
    _stickyPosition: function(el, sign) {
      if (this._scrollEnabled()) {
        var that = this;
        var rtl = $10(that.s.dt.table().node()).css("direction") === "rtl";
        el.find("th").each(function() {
          if ($10(this).css("position") === "sticky") {
            var right = $10(this).css("right");
            var left = $10(this).css("left");
            var potential;
            if (right !== "auto" && !rtl) {
              potential = +right.replace(/px/g, "");
              $10(this).css("right", potential > 0 ? potential : 0);
            } else if (left !== "auto" && rtl) {
              potential = +left.replace(/px/g, "");
              $10(this).css("left", potential > 0 ? potential : 0);
            }
          }
        });
      }
    },
    /**
     * Reposition the floating elements to take account of horizontal page
     * scroll
     *
     * @param  {string} item       The `header` or `footer`
     * @param  {int}    scrollLeft Document scrollLeft
     * @private
     */
    _horizontal: function(item, scrollLeft) {
      var itemDom = this.dom[item];
      var lastScrollLeft = this.s.scrollLeft;
      if (itemDom.floating && lastScrollLeft[item] !== scrollLeft) {
        if (this._scrollEnabled()) {
          var newScrollLeft = $10(
            $10(this.s.dt.table().node()).parent()
          ).scrollLeft();
          itemDom.floating.scrollLeft(newScrollLeft);
          itemDom.floatingParent.scrollLeft(newScrollLeft);
        }
        lastScrollLeft[item] = scrollLeft;
      }
    },
    /**
     * Change from one display mode to another. Each fixed item can be in one
     * of:
     *
     * * `in-place` - In the main DataTable
     * * `in` - Floating over the DataTable
     * * `below` - (Header only) Fixed to the bottom of the table body
     * * `above` - (Footer only) Fixed to the top of the table body
     *
     * @param  {string}  mode        Mode that the item should be shown in
     * @param  {string}  item        'header' or 'footer'
     * @param  {boolean} forceChange Force a redraw of the mode, even if already
     *     in that mode.
     * @private
     */
    _modeChange: function(mode, item, forceChange) {
      var itemDom = this.dom[item];
      var position = this.s.position;
      var scrollEnabled = this._scrollEnabled();
      if (item === "footer" && scrollEnabled) {
        return;
      }
      var importantWidth = function(w) {
        itemDom.floating[0].style.setProperty("width", w + "px", "important");
        if (!scrollEnabled) {
          itemDom.floatingParent[0].style.setProperty("width", w + "px", "important");
        }
      };
      var tablePart = this.dom[item === "footer" ? "tfoot" : "thead"];
      var focus = $10.contains(tablePart[0], document.activeElement) ? document.activeElement : null;
      var scrollBody = $10($10(this.s.dt.table().node()).parent());
      if (mode === "in-place") {
        if (itemDom.placeholder) {
          itemDom.placeholder.remove();
          itemDom.placeholder = null;
        }
        if (item === "header") {
          itemDom.host.prepend(tablePart);
        } else {
          itemDom.host.append(tablePart);
        }
        if (itemDom.floating) {
          itemDom.floating.remove();
          itemDom.floating = null;
          this._stickyPosition(itemDom.host, "+");
        }
        if (itemDom.floatingParent) {
          itemDom.floatingParent.find("div.dtfc-top-blocker").remove();
          itemDom.floatingParent.remove();
        }
        $10($10(itemDom.host.parent()).parent()).scrollLeft(
          scrollBody.scrollLeft()
        );
      } else if (mode === "in") {
        this._clone(item, forceChange);
        var scrollOffset = scrollBody.offset();
        var windowTop = $10(document).scrollTop();
        var windowHeight = $10(window).height();
        var windowBottom = windowTop + windowHeight;
        var bodyTop = scrollEnabled ? scrollOffset.top : position.tbodyTop;
        var bodyBottom = scrollEnabled ? scrollOffset.top + scrollBody.outerHeight() : position.tfootTop;
        var shuffle;
        if (item === "footer") {
          shuffle = bodyTop > windowBottom ? position.tfootHeight : bodyTop + position.tfootHeight - windowBottom;
        } else {
          shuffle = windowTop + this.c.headerOffset + position.theadHeight - bodyBottom;
        }
        var prop = item === "header" ? "top" : "bottom";
        var val = this.c[item + "Offset"] - (shuffle > 0 ? shuffle : 0);
        itemDom.floating.addClass("fixedHeader-floating");
        itemDom.floatingParent.css(prop, val).css({
          left: position.left,
          "z-index": 3
        });
        importantWidth(position.width);
        if (item === "footer") {
          itemDom.floating.css("top", "");
        }
      } else if (mode === "below") {
        this._clone(item, forceChange);
        itemDom.floating.addClass("fixedHeader-locked");
        itemDom.floatingParent.css({
          position: "absolute",
          top: position.tfootTop - position.theadHeight,
          left: position.left + "px"
        });
        importantWidth(position.width);
      } else if (mode === "above") {
        this._clone(item, forceChange);
        itemDom.floating.addClass("fixedHeader-locked");
        itemDom.floatingParent.css({
          position: "absolute",
          top: position.tbodyTop,
          left: position.left + "px"
        });
        importantWidth(position.width);
      }
      if (focus && focus !== document.activeElement) {
        setTimeout(function() {
          focus.focus();
        }, 10);
      }
      this.s.scrollLeft.header = -1;
      this.s.scrollLeft.footer = -1;
      this.s[item + "Mode"] = mode;
    },
    /**
     * Cache the positional information that is required for the mode
     * calculations that FixedHeader performs.
     *
     * @private
     */
    _positions: function() {
      var dt = this.s.dt;
      var table = dt.table();
      var position = this.s.position;
      var dom = this.dom;
      var tableNode = $10(table.node());
      var scrollEnabled = this._scrollEnabled();
      var thead = $10(dt.table().header());
      var tfoot = $10(dt.table().footer());
      var tbody = dom.tbody;
      var scrollBody = tableNode.parent();
      position.visible = tableNode.is(":visible");
      position.width = tableNode.outerWidth();
      position.left = tableNode.offset().left;
      position.theadTop = thead.offset().top;
      position.tbodyTop = scrollEnabled ? scrollBody.offset().top : tbody.offset().top;
      position.tbodyHeight = scrollEnabled ? scrollBody.outerHeight() : tbody.outerHeight();
      position.theadHeight = thead.outerHeight();
      position.theadBottom = position.theadTop + position.theadHeight;
      position.tfootTop = position.tbodyTop + position.tbodyHeight;
      if (tfoot.length) {
        position.tfootBottom = position.tfootTop + tfoot.outerHeight();
        position.tfootHeight = tfoot.outerHeight();
      } else {
        position.tfootBottom = position.tfootTop;
        position.tfootHeight = 0;
      }
    },
    /**
     * Mode calculation - determine what mode the fixed items should be placed
     * into.
     *
     * @param  {boolean} forceChange Force a redraw of the mode, even if already
     *     in that mode.
     * @private
     */
    _scroll: function(forceChange) {
      if (this.s.dt.settings()[0].bDestroying) {
        return;
      }
      var scrollEnabled = this._scrollEnabled();
      var scrollBody = $10(this.s.dt.table().node()).parent();
      var scrollOffset = scrollBody.offset();
      var scrollHeight = scrollBody.outerHeight();
      var windowLeft = $10(document).scrollLeft();
      var windowTop = $10(document).scrollTop();
      var windowHeight = $10(window).height();
      var windowBottom = windowHeight + windowTop;
      var position = this.s.position;
      var headerMode, footerMode;
      var bodyTop = scrollEnabled ? scrollOffset.top : position.tbodyTop;
      var bodyLeft = scrollEnabled ? scrollOffset.left : position.left;
      var bodyBottom = scrollEnabled ? scrollOffset.top + scrollHeight : position.tfootTop;
      var bodyWidth = scrollEnabled ? scrollBody.outerWidth() : position.tbodyWidth;
      if (this.c.header) {
        if (!this.s.enable) {
          headerMode = "in-place";
        } else if (!position.visible || windowTop + this.c.headerOffset + position.theadHeight <= bodyTop) {
          headerMode = "in-place";
        } else if (
          // The scrolling plus the header offset plus the height of the header is lower than the top of the body
          windowTop + this.c.headerOffset + position.theadHeight > bodyTop && // And the scrolling at the top plus the header offset is above the bottom of the body
          windowTop + this.c.headerOffset + position.theadHeight < bodyBottom
        ) {
          headerMode = "in";
          if (windowTop + this.c.headerOffset + position.theadHeight > bodyBottom || this.dom.header.floatingParent === void 0) {
            forceChange = true;
          } else {
            this.dom.header.floatingParent.css({
              top: this.c.headerOffset,
              position: "fixed"
            }).children().eq(0).append(this.dom.header.floating);
          }
        } else {
          headerMode = "below";
        }
        if (forceChange || headerMode !== this.s.headerMode) {
          this._modeChange(headerMode, "header", forceChange);
        }
        this._horizontal("header", windowLeft);
      }
      var header = {
        offset: { top: 0, left: 0 },
        height: 0
      };
      var footer = {
        offset: { top: 0, left: 0 },
        height: 0
      };
      if (this.c.footer && this.dom.tfoot.length && this.dom.tfoot.find("th, td").length) {
        if (!this.s.enable) {
          footerMode = "in-place";
        } else if (!position.visible || position.tfootBottom + this.c.footerOffset <= windowBottom) {
          footerMode = "in-place";
        } else if (bodyBottom + position.tfootHeight + this.c.footerOffset > windowBottom && bodyTop + this.c.footerOffset < windowBottom) {
          footerMode = "in";
          forceChange = true;
        } else {
          footerMode = "above";
        }
        if (forceChange || footerMode !== this.s.footerMode) {
          this._modeChange(footerMode, "footer", forceChange);
        }
        this._horizontal("footer", windowLeft);
        var getOffsetHeight = function(el) {
          return {
            offset: el.offset(),
            height: el.outerHeight()
          };
        };
        header = this.dom.header.floating ? getOffsetHeight(this.dom.header.floating) : getOffsetHeight(this.dom.thead);
        footer = this.dom.footer.floating ? getOffsetHeight(this.dom.footer.floating) : getOffsetHeight(this.dom.tfoot);
        if (scrollEnabled && footer.offset.top > windowTop) {
          var overlap = windowTop - scrollOffset.top;
          var newHeight = windowBottom + // If the gap between the top of the scrollbody and the window is more than
          //  the height of the header then the top of the table is still visible so add that gap
          // Doing this has effectively calculated the height from the top of the table to the bottom of the current page
          (overlap > -header.height ? overlap : 0) - // Take from that
          // The top of the header plus
          (header.offset.top + // The header height if the standard header is present
          (overlap < -header.height ? header.height : 0) + // And the height of the footer
          footer.height);
          if (newHeight < 0) {
            newHeight = 0;
          }
          scrollBody.outerHeight(newHeight);
          if (Math.round(scrollBody.outerHeight()) >= Math.round(newHeight)) {
            $10(this.dom.tfoot.parent()).addClass("fixedHeader-floating");
          } else {
            $10(this.dom.tfoot.parent()).removeClass(
              "fixedHeader-floating"
            );
          }
        }
      }
      if (this.dom.header.floating) {
        this.dom.header.floatingParent.css("left", bodyLeft - windowLeft);
      }
      if (this.dom.footer.floating) {
        this.dom.footer.floatingParent.css("left", bodyLeft - windowLeft);
      }
      if (this.s.dt.settings()[0]._fixedColumns !== void 0) {
        var adjustBlocker = function(side, end, el) {
          if (el === void 0) {
            var blocker = $10(
              "div.dtfc-" + side + "-" + end + "-blocker"
            );
            el = blocker.length === 0 ? null : blocker.clone().css("z-index", 1);
          }
          if (el !== null) {
            if (headerMode === "in" || headerMode === "below") {
              el.appendTo("body").css({
                top: end === "top" ? header.offset.top : footer.offset.top,
                left: side === "right" ? bodyLeft + bodyWidth - el.width() : bodyLeft
              });
            } else {
              el.detach();
            }
          }
          return el;
        };
        this.dom.header.rightBlocker = adjustBlocker(
          "right",
          "top",
          this.dom.header.rightBlocker
        );
        this.dom.header.leftBlocker = adjustBlocker(
          "left",
          "top",
          this.dom.header.leftBlocker
        );
        this.dom.footer.rightBlocker = adjustBlocker(
          "right",
          "bottom",
          this.dom.footer.rightBlocker
        );
        this.dom.footer.leftBlocker = adjustBlocker(
          "left",
          "bottom",
          this.dom.footer.leftBlocker
        );
      }
    },
    /**
     * Function to check if scrolling is enabled on the table or not
     * @returns Boolean value indicating if scrolling on the table is enabled or not
     */
    _scrollEnabled: function() {
      var oScroll = this.s.dt.settings()[0].oScroll;
      if (oScroll.sY !== "" || oScroll.sX !== "") {
        return true;
      }
      return false;
    },
    /**
     * Realign columns by using the colgroup tag and
     * checking column widths
     */
    _widths: function(itemDom) {
      if (!itemDom || !itemDom.placeholder) {
        return;
      }
      var tableNode = $10(this.s.dt.table().node());
      var scrollBody = $10(tableNode.parent());
      itemDom.floatingParent.css("width", scrollBody[0].offsetWidth);
      itemDom.floating.css("width", tableNode[0].offsetWidth);
      $10("colgroup", itemDom.floating).remove();
      var cols = itemDom.placeholder.parent().find("colgroup").clone().appendTo(itemDom.floating).find("col");
      var widths = this.s.dt.columns(":visible").widths();
      for (var i = 0; i < widths.length; i++) {
        cols.eq(i).css("width", widths[i]);
      }
    }
  });
  FixedHeader.version = "4.0.1";
  FixedHeader.defaults = {
    header: true,
    footer: false,
    headerOffset: 0,
    footerOffset: 0
  };
  $10.fn.dataTable.FixedHeader = FixedHeader;
  $10.fn.DataTable.FixedHeader = FixedHeader;
  $10(document).on("init.dt.dtfh", function(e, settings, json) {
    if (e.namespace !== "dt") {
      return;
    }
    var init2 = settings.oInit.fixedHeader;
    var defaults = dataTables_default5.defaults.fixedHeader;
    if ((init2 || defaults) && !settings._fixedHeader) {
      var opts = $10.extend({}, defaults, init2);
      if (init2 !== false) {
        new FixedHeader(settings, opts);
      }
    }
  });
  dataTables_default5.Api.register("fixedHeader()", function() {
  });
  dataTables_default5.Api.register("fixedHeader.adjust()", function() {
    return this.iterator("table", function(ctx) {
      var fh = ctx._fixedHeader;
      if (fh) {
        fh.update();
      }
    });
  });
  dataTables_default5.Api.register("fixedHeader.enable()", function(flag) {
    return this.iterator("table", function(ctx) {
      var fh = ctx._fixedHeader;
      flag = flag !== void 0 ? flag : true;
      if (fh && flag !== fh.enabled()) {
        fh.enable(flag);
      }
    });
  });
  dataTables_default5.Api.register("fixedHeader.enabled()", function() {
    if (this.context.length) {
      var fh = this.context[0]._fixedHeader;
      if (fh) {
        return fh.enabled();
      }
    }
    return false;
  });
  dataTables_default5.Api.register("fixedHeader.disable()", function() {
    return this.iterator("table", function(ctx) {
      var fh = ctx._fixedHeader;
      if (fh && fh.enabled()) {
        fh.enable(false);
      }
    });
  });
  $10.each(["header", "footer"], function(i, el) {
    dataTables_default5.Api.register("fixedHeader." + el + "Offset()", function(offset) {
      var ctx = this.context;
      if (offset === void 0) {
        return ctx.length && ctx[0]._fixedHeader ? ctx[0]._fixedHeader[el + "Offset"]() : void 0;
      }
      return this.iterator("table", function(ctx2) {
        var fh = ctx2._fixedHeader;
        if (fh) {
          fh[el + "Offset"](offset);
        }
      });
    });
  });

  // node_modules/datatables.net-buttons-bs5/js/buttons.bootstrap5.mjs
  var import_jquery14 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-buttons/js/dataTables.buttons.mjs
  var import_jquery13 = __toESM(require_jquery(), 1);
  var $11 = import_jquery13.default;
  var _instCounter2 = 0;
  var _buttonCounter = 0;
  var _dtButtons = dataTables_default.ext.buttons;
  var _entityDecoder = null;
  function _fadeIn(el, duration, fn) {
    if ($11.fn.animate) {
      el.stop().fadeIn(duration, fn);
    } else {
      el.css("display", "block");
      if (fn) {
        fn.call(el);
      }
    }
  }
  function _fadeOut(el, duration, fn) {
    if ($11.fn.animate) {
      el.stop().fadeOut(duration, fn);
    } else {
      el.css("display", "none");
      if (fn) {
        fn.call(el);
      }
    }
  }
  var Buttons = function(dt, config) {
    if (!dataTables_default.versionCheck("2")) {
      throw "Warning: Buttons requires DataTables 2 or newer";
    }
    if (!(this instanceof Buttons)) {
      return function(settings) {
        return new Buttons(settings, dt).container();
      };
    }
    if (typeof config === "undefined") {
      config = {};
    }
    if (config === true) {
      config = {};
    }
    if (Array.isArray(config)) {
      config = { buttons: config };
    }
    this.c = $11.extend(true, {}, Buttons.defaults, config);
    if (config.buttons) {
      this.c.buttons = config.buttons;
    }
    this.s = {
      dt: new dataTables_default.Api(dt),
      buttons: [],
      listenKeys: "",
      namespace: "dtb" + _instCounter2++
    };
    this.dom = {
      container: $11("<" + this.c.dom.container.tag + "/>").addClass(
        this.c.dom.container.className
      )
    };
    this._constructor();
  };
  $11.extend(Buttons.prototype, {
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Public methods
     */
    /**
     * Get the action of a button
     * @param  {int|string} Button index
     * @return {function}
     */
    /**
    * Set the action of a button
    * @param  {node} node Button element
    * @param  {function} action Function to set
    * @return {Buttons} Self for chaining
    */
    action: function(node, action) {
      var button = this._nodeToButton(node);
      if (action === void 0) {
        return button.conf.action;
      }
      button.conf.action = action;
      return this;
    },
    /**
     * Add an active class to the button to make to look active or get current
     * active state.
     * @param  {node} node Button element
     * @param  {boolean} [flag] Enable / disable flag
     * @return {Buttons} Self for chaining or boolean for getter
     */
    active: function(node, flag) {
      var button = this._nodeToButton(node);
      var klass = this.c.dom.button.active;
      var jqNode = $11(button.node);
      if (button.inCollection && this.c.dom.collection.button && this.c.dom.collection.button.active !== void 0) {
        klass = this.c.dom.collection.button.active;
      }
      if (flag === void 0) {
        return jqNode.hasClass(klass);
      }
      jqNode.toggleClass(klass, flag === void 0 ? true : flag);
      return this;
    },
    /**
     * Add a new button
     * @param {object} config Button configuration object, base string name or function
     * @param {int|string} [idx] Button index for where to insert the button
     * @param {boolean} [draw=true] Trigger a draw. Set a false when adding
     *   lots of buttons, until the last button.
     * @return {Buttons} Self for chaining
     */
    add: function(config, idx, draw) {
      var buttons = this.s.buttons;
      if (typeof idx === "string") {
        var split = idx.split("-");
        var base = this.s;
        for (var i = 0, ien = split.length - 1; i < ien; i++) {
          base = base.buttons[split[i] * 1];
        }
        buttons = base.buttons;
        idx = split[split.length - 1] * 1;
      }
      this._expandButton(
        buttons,
        config,
        config !== void 0 ? config.split : void 0,
        (config === void 0 || config.split === void 0 || config.split.length === 0) && base !== void 0,
        false,
        idx
      );
      if (draw === void 0 || draw === true) {
        this._draw();
      }
      return this;
    },
    /**
     * Clear buttons from a collection and then insert new buttons
     */
    collectionRebuild: function(node, newButtons) {
      var button = this._nodeToButton(node);
      if (newButtons !== void 0) {
        var i;
        for (i = button.buttons.length - 1; i >= 0; i--) {
          this.remove(button.buttons[i].node);
        }
        if (button.conf.prefixButtons) {
          newButtons.unshift.apply(newButtons, button.conf.prefixButtons);
        }
        if (button.conf.postfixButtons) {
          newButtons.push.apply(newButtons, button.conf.postfixButtons);
        }
        for (i = 0; i < newButtons.length; i++) {
          var newBtn = newButtons[i];
          this._expandButton(
            button.buttons,
            newBtn,
            newBtn !== void 0 && newBtn.config !== void 0 && newBtn.config.split !== void 0,
            true,
            newBtn.parentConf !== void 0 && newBtn.parentConf.split !== void 0,
            null,
            newBtn.parentConf
          );
        }
      }
      this._draw(button.collection, button.buttons);
    },
    /**
     * Get the container node for the buttons
     * @return {jQuery} Buttons node
     */
    container: function() {
      return this.dom.container;
    },
    /**
     * Disable a button
     * @param  {node} node Button node
     * @return {Buttons} Self for chaining
     */
    disable: function(node) {
      var button = this._nodeToButton(node);
      $11(button.node).addClass(this.c.dom.button.disabled).prop("disabled", true);
      return this;
    },
    /**
     * Destroy the instance, cleaning up event handlers and removing DOM
     * elements
     * @return {Buttons} Self for chaining
     */
    destroy: function() {
      $11("body").off("keyup." + this.s.namespace);
      var buttons = this.s.buttons.slice();
      var i, ien;
      for (i = 0, ien = buttons.length; i < ien; i++) {
        this.remove(buttons[i].node);
      }
      this.dom.container.remove();
      var buttonInsts = this.s.dt.settings()[0];
      for (i = 0, ien = buttonInsts.length; i < ien; i++) {
        if (buttonInsts.inst === this) {
          buttonInsts.splice(i, 1);
          break;
        }
      }
      return this;
    },
    /**
     * Enable / disable a button
     * @param  {node} node Button node
     * @param  {boolean} [flag=true] Enable / disable flag
     * @return {Buttons} Self for chaining
     */
    enable: function(node, flag) {
      if (flag === false) {
        return this.disable(node);
      }
      var button = this._nodeToButton(node);
      $11(button.node).removeClass(this.c.dom.button.disabled).prop("disabled", false);
      return this;
    },
    /**
     * Get a button's index
     *
     * This is internally recursive
     * @param {element} node Button to get the index of
     * @return {string} Button index
     */
    index: function(node, nested, buttons) {
      if (!nested) {
        nested = "";
        buttons = this.s.buttons;
      }
      for (var i = 0, ien = buttons.length; i < ien; i++) {
        var inner = buttons[i].buttons;
        if (buttons[i].node === node) {
          return nested + i;
        }
        if (inner && inner.length) {
          var match = this.index(node, i + "-", inner);
          if (match !== null) {
            return match;
          }
        }
      }
      return null;
    },
    /**
     * Get the instance name for the button set selector
     * @return {string} Instance name
     */
    name: function() {
      return this.c.name;
    },
    /**
     * Get a button's node of the buttons container if no button is given
     * @param  {node} [node] Button node
     * @return {jQuery} Button element, or container
     */
    node: function(node) {
      if (!node) {
        return this.dom.container;
      }
      var button = this._nodeToButton(node);
      return $11(button.node);
    },
    /**
     * Set / get a processing class on the selected button
     * @param {element} node Triggering button node
     * @param  {boolean} flag true to add, false to remove, undefined to get
     * @return {boolean|Buttons} Getter value or this if a setter.
     */
    processing: function(node, flag) {
      var dt = this.s.dt;
      var button = this._nodeToButton(node);
      if (flag === void 0) {
        return $11(button.node).hasClass("processing");
      }
      $11(button.node).toggleClass("processing", flag);
      $11(dt.table().node()).triggerHandler("buttons-processing.dt", [
        flag,
        dt.button(node),
        dt,
        $11(node),
        button.conf
      ]);
      return this;
    },
    /**
     * Remove a button.
     * @param  {node} node Button node
     * @return {Buttons} Self for chaining
     */
    remove: function(node) {
      var button = this._nodeToButton(node);
      var host = this._nodeToHost(node);
      var dt = this.s.dt;
      if (button.buttons.length) {
        for (var i = button.buttons.length - 1; i >= 0; i--) {
          this.remove(button.buttons[i].node);
        }
      }
      button.conf.destroying = true;
      if (button.conf.destroy) {
        button.conf.destroy.call(dt.button(node), dt, $11(node), button.conf);
      }
      this._removeKey(button.conf);
      $11(button.node).remove();
      var idx = $11.inArray(button, host);
      host.splice(idx, 1);
      return this;
    },
    /**
     * Get the text for a button
     * @param  {int|string} node Button index
     * @return {string} Button text
     */
    /**
    * Set the text for a button
    * @param  {int|string|function} node Button index
    * @param  {string} label Text
    * @return {Buttons} Self for chaining
    */
    text: function(node, label) {
      var button = this._nodeToButton(node);
      var textNode = button.textNode;
      var dt = this.s.dt;
      var jqNode = $11(button.node);
      var text = function(opt) {
        return typeof opt === "function" ? opt(dt, jqNode, button.conf) : opt;
      };
      if (label === void 0) {
        return text(button.conf.text);
      }
      button.conf.text = label;
      textNode.html(text(label));
      return this;
    },
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Constructor
     */
    /**
     * Buttons constructor
     * @private
     */
    _constructor: function() {
      var that = this;
      var dt = this.s.dt;
      var dtSettings = dt.settings()[0];
      var buttons = this.c.buttons;
      if (!dtSettings._buttons) {
        dtSettings._buttons = [];
      }
      dtSettings._buttons.push({
        inst: this,
        name: this.c.name
      });
      for (var i = 0, ien = buttons.length; i < ien; i++) {
        this.add(buttons[i]);
      }
      dt.on("destroy", function(e, settings) {
        if (settings === dtSettings) {
          that.destroy();
        }
      });
      $11("body").on("keyup." + this.s.namespace, function(e) {
        if (!document.activeElement || document.activeElement === document.body) {
          var character = String.fromCharCode(e.keyCode).toLowerCase();
          if (that.s.listenKeys.toLowerCase().indexOf(character) !== -1) {
            that._keypress(character, e);
          }
        }
      });
    },
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Private methods
     */
    /**
     * Add a new button to the key press listener
     * @param {object} conf Resolved button configuration object
     * @private
     */
    _addKey: function(conf) {
      if (conf.key) {
        this.s.listenKeys += $11.isPlainObject(conf.key) ? conf.key.key : conf.key;
      }
    },
    /**
     * Insert the buttons into the container. Call without parameters!
     * @param  {node} [container] Recursive only - Insert point
     * @param  {array} [buttons] Recursive only - Buttons array
     * @private
     */
    _draw: function(container, buttons) {
      if (!container) {
        container = this.dom.container;
        buttons = this.s.buttons;
      }
      container.children().detach();
      for (var i = 0, ien = buttons.length; i < ien; i++) {
        container.append(buttons[i].inserter);
        container.append(" ");
        if (buttons[i].buttons && buttons[i].buttons.length) {
          this._draw(buttons[i].collection, buttons[i].buttons);
        }
      }
    },
    /**
     * Create buttons from an array of buttons
     * @param  {array} attachTo Buttons array to attach to
     * @param  {object} button Button definition
     * @param  {boolean} inCollection true if the button is in a collection
     * @private
     */
    _expandButton: function(attachTo, button, split, inCollection, inSplit, attachPoint, parentConf) {
      var dt = this.s.dt;
      var isSplit = false;
      var domCollection = this.c.dom.collection;
      var buttons = !Array.isArray(button) ? [button] : button;
      if (button === void 0) {
        buttons = !Array.isArray(split) ? [split] : split;
      }
      for (var i = 0, ien = buttons.length; i < ien; i++) {
        var conf = this._resolveExtends(buttons[i]);
        if (!conf) {
          continue;
        }
        isSplit = conf.config && conf.config.split ? true : false;
        if (Array.isArray(conf)) {
          this._expandButton(
            attachTo,
            conf,
            built !== void 0 && built.conf !== void 0 ? built.conf.split : void 0,
            inCollection,
            parentConf !== void 0 && parentConf.split !== void 0,
            attachPoint,
            parentConf
          );
          continue;
        }
        var built = this._buildButton(
          conf,
          inCollection,
          conf.split !== void 0 || conf.config !== void 0 && conf.config.split !== void 0,
          inSplit
        );
        if (!built) {
          continue;
        }
        if (attachPoint !== void 0 && attachPoint !== null) {
          attachTo.splice(attachPoint, 0, built);
          attachPoint++;
        } else {
          attachTo.push(built);
        }
        if (built.conf.buttons) {
          built.collection = $11(
            "<" + domCollection.container.content.tag + "/>"
          );
          built.conf._collection = built.collection;
          $11(built.node).append(domCollection.action.dropHtml);
          this._expandButton(
            built.buttons,
            built.conf.buttons,
            built.conf.split,
            !isSplit,
            isSplit,
            attachPoint,
            built.conf
          );
        }
        if (built.conf.split) {
          built.collection = $11("<" + domCollection.container.tag + "/>");
          built.conf._collection = built.collection;
          for (var j = 0; j < built.conf.split.length; j++) {
            var item = built.conf.split[j];
            if (typeof item === "object") {
              item.parent = parentConf;
              if (item.collectionLayout === void 0) {
                item.collectionLayout = built.conf.collectionLayout;
              }
              if (item.dropup === void 0) {
                item.dropup = built.conf.dropup;
              }
              if (item.fade === void 0) {
                item.fade = built.conf.fade;
              }
            }
          }
          this._expandButton(
            built.buttons,
            built.conf.buttons,
            built.conf.split,
            !isSplit,
            isSplit,
            attachPoint,
            built.conf
          );
        }
        built.conf.parent = parentConf;
        if (conf.init) {
          conf.init.call(dt.button(built.node), dt, $11(built.node), conf);
        }
      }
    },
    /**
     * Create an individual button
     * @param  {object} config            Resolved button configuration
     * @param  {boolean} inCollection `true` if a collection button
     * @return {object} Completed button description object
     * @private
     */
    _buildButton: function(config, inCollection, isSplit, inSplit) {
      var that = this;
      var configDom = this.c.dom;
      var textNode;
      var dt = this.s.dt;
      var text = function(opt) {
        return typeof opt === "function" ? opt(dt, button, config) : opt;
      };
      var dom = $11.extend(true, {}, configDom.button);
      if (inCollection && isSplit && configDom.collection.split) {
        $11.extend(true, dom, configDom.collection.split.action);
      } else if (inSplit || inCollection) {
        $11.extend(true, dom, configDom.collection.button);
      } else if (isSplit) {
        $11.extend(true, dom, configDom.split.button);
      }
      if (config.spacer) {
        var spacer = $11("<" + dom.spacer.tag + "/>").addClass(
          "dt-button-spacer " + config.style + " " + dom.spacer.className
        ).html(text(config.text));
        return {
          conf: config,
          node: spacer,
          inserter: spacer,
          buttons: [],
          inCollection,
          isSplit,
          collection: null,
          textNode: spacer
        };
      }
      if (config.available && !config.available(dt, config) && !config.html) {
        return false;
      }
      var button;
      if (!config.html) {
        var run = function(e, dt2, button2, config2, done) {
          config2.action.call(dt2.button(button2), e, dt2, button2, config2, done);
          $11(dt2.table().node()).triggerHandler("buttons-action.dt", [
            dt2.button(button2),
            dt2,
            button2,
            config2
          ]);
        };
        var action = function(e, dt2, button2, config2) {
          if (config2.async) {
            that.processing(button2[0], true);
            setTimeout(function() {
              run(e, dt2, button2, config2, function() {
                that.processing(button2[0], false);
              });
            }, config2.async);
          } else {
            run(e, dt2, button2, config2, function() {
            });
          }
        };
        var tag = config.tag || dom.tag;
        var clickBlurs = config.clickBlurs === void 0 ? true : config.clickBlurs;
        button = $11("<" + tag + "/>").addClass(dom.className).attr("tabindex", this.s.dt.settings()[0].iTabIndex).attr("aria-controls", this.s.dt.table().node().id).on("click.dtb", function(e) {
          e.preventDefault();
          if (!button.hasClass(dom.disabled) && config.action) {
            action(e, dt, button, config);
          }
          if (clickBlurs) {
            button.trigger("blur");
          }
        }).on("keypress.dtb", function(e) {
          if (e.keyCode === 13) {
            e.preventDefault();
            if (!button.hasClass(dom.disabled) && config.action) {
              action(e, dt, button, config);
            }
          }
        });
        if (tag.toLowerCase() === "a") {
          button.attr("href", "#");
        }
        if (tag.toLowerCase() === "button") {
          button.attr("type", "button");
        }
        if (dom.liner.tag) {
          var liner = $11("<" + dom.liner.tag + "/>").html(text(config.text)).addClass(dom.liner.className);
          if (dom.liner.tag.toLowerCase() === "a") {
            liner.attr("href", "#");
          }
          button.append(liner);
          textNode = liner;
        } else {
          button.html(text(config.text));
          textNode = button;
        }
        if (config.enabled === false) {
          button.addClass(dom.disabled);
        }
        if (config.className) {
          button.addClass(config.className);
        }
        if (config.titleAttr) {
          button.attr("title", text(config.titleAttr));
        }
        if (config.attr) {
          button.attr(config.attr);
        }
        if (!config.namespace) {
          config.namespace = ".dt-button-" + _buttonCounter++;
        }
        if (config.config !== void 0 && config.config.split) {
          config.split = config.config.split;
        }
      } else {
        button = $11(config.html);
      }
      var buttonContainer = this.c.dom.buttonContainer;
      var inserter;
      if (buttonContainer && buttonContainer.tag) {
        inserter = $11("<" + buttonContainer.tag + "/>").addClass(buttonContainer.className).append(button);
      } else {
        inserter = button;
      }
      this._addKey(config);
      if (this.c.buttonCreated) {
        inserter = this.c.buttonCreated(config, inserter);
      }
      var splitDiv;
      if (isSplit) {
        var dropdownConf = inCollection ? $11.extend(true, this.c.dom.split, this.c.dom.collection.split) : this.c.dom.split;
        var wrapperConf = dropdownConf.wrapper;
        splitDiv = $11("<" + wrapperConf.tag + "/>").addClass(wrapperConf.className).append(button);
        var dropButtonConfig = $11.extend(config, {
          align: dropdownConf.dropdown.align,
          attr: {
            "aria-haspopup": "dialog",
            "aria-expanded": false
          },
          className: dropdownConf.dropdown.className,
          closeButton: false,
          splitAlignClass: dropdownConf.dropdown.splitAlignClass,
          text: dropdownConf.dropdown.text
        });
        this._addKey(dropButtonConfig);
        var splitAction = function(e, dt2, button2, config2) {
          _dtButtons.split.action.call(
            dt2.button(splitDiv),
            e,
            dt2,
            button2,
            config2
          );
          $11(dt2.table().node()).triggerHandler("buttons-action.dt", [
            dt2.button(button2),
            dt2,
            button2,
            config2
          ]);
          button2.attr("aria-expanded", true);
        };
        var dropButton = $11(
          '<button class="' + dropdownConf.dropdown.className + ' dt-button"></button>'
        ).html(dropdownConf.dropdown.dropHtml).on("click.dtb", function(e) {
          e.preventDefault();
          e.stopPropagation();
          if (!dropButton.hasClass(dom.disabled)) {
            splitAction(e, dt, dropButton, dropButtonConfig);
          }
          if (clickBlurs) {
            dropButton.trigger("blur");
          }
        }).on("keypress.dtb", function(e) {
          if (e.keyCode === 13) {
            e.preventDefault();
            if (!dropButton.hasClass(dom.disabled)) {
              splitAction(e, dt, dropButton, dropButtonConfig);
            }
          }
        });
        if (config.split.length === 0) {
          dropButton.addClass("dtb-hide-drop");
        }
        splitDiv.append(dropButton).attr(dropButtonConfig.attr);
      }
      return {
        conf: config,
        node: isSplit ? splitDiv.get(0) : button.get(0),
        inserter: isSplit ? splitDiv : inserter,
        buttons: [],
        inCollection,
        isSplit,
        inSplit,
        collection: null,
        textNode
      };
    },
    /**
     * Get the button object from a node (recursive)
     * @param  {node} node Button node
     * @param  {array} [buttons] Button array, uses base if not defined
     * @return {object} Button object
     * @private
     */
    _nodeToButton: function(node, buttons) {
      if (!buttons) {
        buttons = this.s.buttons;
      }
      for (var i = 0, ien = buttons.length; i < ien; i++) {
        if (buttons[i].node === node) {
          return buttons[i];
        }
        if (buttons[i].buttons.length) {
          var ret = this._nodeToButton(node, buttons[i].buttons);
          if (ret) {
            return ret;
          }
        }
      }
    },
    /**
     * Get container array for a button from a button node (recursive)
     * @param  {node} node Button node
     * @param  {array} [buttons] Button array, uses base if not defined
     * @return {array} Button's host array
     * @private
     */
    _nodeToHost: function(node, buttons) {
      if (!buttons) {
        buttons = this.s.buttons;
      }
      for (var i = 0, ien = buttons.length; i < ien; i++) {
        if (buttons[i].node === node) {
          return buttons;
        }
        if (buttons[i].buttons.length) {
          var ret = this._nodeToHost(node, buttons[i].buttons);
          if (ret) {
            return ret;
          }
        }
      }
    },
    /**
     * Handle a key press - determine if any button's key configured matches
     * what was typed and trigger the action if so.
     * @param  {string} character The character pressed
     * @param  {object} e Key event that triggered this call
     * @private
     */
    _keypress: function(character, e) {
      if (e._buttonsHandled) {
        return;
      }
      var run = function(conf, node) {
        if (!conf.key) {
          return;
        }
        if (conf.key === character) {
          e._buttonsHandled = true;
          $11(node).click();
        } else if ($11.isPlainObject(conf.key)) {
          if (conf.key.key !== character) {
            return;
          }
          if (conf.key.shiftKey && !e.shiftKey) {
            return;
          }
          if (conf.key.altKey && !e.altKey) {
            return;
          }
          if (conf.key.ctrlKey && !e.ctrlKey) {
            return;
          }
          if (conf.key.metaKey && !e.metaKey) {
            return;
          }
          e._buttonsHandled = true;
          $11(node).click();
        }
      };
      var recurse = function(a) {
        for (var i = 0, ien = a.length; i < ien; i++) {
          run(a[i].conf, a[i].node);
          if (a[i].buttons.length) {
            recurse(a[i].buttons);
          }
        }
      };
      recurse(this.s.buttons);
    },
    /**
     * Remove a key from the key listener for this instance (to be used when a
     * button is removed)
     * @param  {object} conf Button configuration
     * @private
     */
    _removeKey: function(conf) {
      if (conf.key) {
        var character = $11.isPlainObject(conf.key) ? conf.key.key : conf.key;
        var a = this.s.listenKeys.split("");
        var idx = $11.inArray(character, a);
        a.splice(idx, 1);
        this.s.listenKeys = a.join("");
      }
    },
    /**
     * Resolve a button configuration
     * @param  {string|function|object} conf Button config to resolve
     * @return {object} Button configuration
     * @private
     */
    _resolveExtends: function(conf) {
      var that = this;
      var dt = this.s.dt;
      var i, ien;
      var toConfObject = function(base) {
        var loop = 0;
        while (!$11.isPlainObject(base) && !Array.isArray(base)) {
          if (base === void 0) {
            return;
          }
          if (typeof base === "function") {
            base = base.call(that, dt, conf);
            if (!base) {
              return false;
            }
          } else if (typeof base === "string") {
            if (!_dtButtons[base]) {
              return { html: base };
            }
            base = _dtButtons[base];
          }
          loop++;
          if (loop > 30) {
            throw "Buttons: Too many iterations";
          }
        }
        return Array.isArray(base) ? base : $11.extend({}, base);
      };
      conf = toConfObject(conf);
      while (conf && conf.extend) {
        if (!_dtButtons[conf.extend]) {
          throw "Cannot extend unknown button type: " + conf.extend;
        }
        var objArray = toConfObject(_dtButtons[conf.extend]);
        if (Array.isArray(objArray)) {
          return objArray;
        } else if (!objArray) {
          return false;
        }
        var originalClassName = objArray.className;
        if (conf.config !== void 0 && objArray.config !== void 0) {
          conf.config = $11.extend({}, objArray.config, conf.config);
        }
        conf = $11.extend({}, objArray, conf);
        if (originalClassName && conf.className !== originalClassName) {
          conf.className = originalClassName + " " + conf.className;
        }
        conf.extend = objArray.extend;
      }
      var postfixButtons = conf.postfixButtons;
      if (postfixButtons) {
        if (!conf.buttons) {
          conf.buttons = [];
        }
        for (i = 0, ien = postfixButtons.length; i < ien; i++) {
          conf.buttons.push(postfixButtons[i]);
        }
      }
      var prefixButtons = conf.prefixButtons;
      if (prefixButtons) {
        if (!conf.buttons) {
          conf.buttons = [];
        }
        for (i = 0, ien = prefixButtons.length; i < ien; i++) {
          conf.buttons.splice(i, 0, prefixButtons[i]);
        }
      }
      return conf;
    },
    /**
     * Display (and replace if there is an existing one) a popover attached to a button
     * @param {string|node} content Content to show
     * @param {DataTable.Api} hostButton DT API instance of the button
     * @param {object} inOpts Options (see object below for all options)
     */
    _popover: function(content, hostButton, inOpts) {
      var dt = hostButton;
      var c = this.c;
      var closed = false;
      var options = $11.extend(
        {
          align: "button-left",
          // button-right, dt-container, split-left, split-right
          autoClose: false,
          background: true,
          backgroundClassName: "dt-button-background",
          closeButton: true,
          containerClassName: c.dom.collection.container.className,
          contentClassName: c.dom.collection.container.content.className,
          collectionLayout: "",
          collectionTitle: "",
          dropup: false,
          fade: 400,
          popoverTitle: "",
          rightAlignClassName: "dt-button-right",
          tag: c.dom.collection.container.tag
        },
        inOpts
      );
      var containerSelector = options.tag + "." + options.containerClassName.replace(/ /g, ".");
      var hostNode = hostButton.node();
      var close = function() {
        closed = true;
        _fadeOut($11(containerSelector), options.fade, function() {
          $11(this).detach();
        });
        $11(
          dt.buttons('[aria-haspopup="dialog"][aria-expanded="true"]').nodes()
        ).attr("aria-expanded", "false");
        $11("div.dt-button-background").off("click.dtb-collection");
        Buttons.background(
          false,
          options.backgroundClassName,
          options.fade,
          hostNode
        );
        $11(window).off("resize.resize.dtb-collection");
        $11("body").off(".dtb-collection");
        dt.off("buttons-action.b-internal");
        dt.off("destroy");
      };
      if (content === false) {
        close();
        return;
      }
      var existingExpanded = $11(
        dt.buttons('[aria-haspopup="dialog"][aria-expanded="true"]').nodes()
      );
      if (existingExpanded.length) {
        if (hostNode.closest(containerSelector).length) {
          hostNode = existingExpanded.eq(0);
        }
        close();
      }
      var cnt = $11(".dt-button", content).length;
      var mod = "";
      if (cnt === 3) {
        mod = "dtb-b3";
      } else if (cnt === 2) {
        mod = "dtb-b2";
      } else if (cnt === 1) {
        mod = "dtb-b1";
      }
      var display = $11("<" + options.tag + "/>").addClass(options.containerClassName).addClass(options.collectionLayout).addClass(options.splitAlignClass).addClass(mod).css("display", "none").attr({
        "aria-modal": true,
        role: "dialog"
      });
      content = $11(content).addClass(options.contentClassName).attr("role", "menu").appendTo(display);
      hostNode.attr("aria-expanded", "true");
      if (hostNode.parents("body")[0] !== document.body) {
        hostNode = document.body.lastChild;
      }
      if (options.popoverTitle) {
        display.prepend(
          '<div class="dt-button-collection-title">' + options.popoverTitle + "</div>"
        );
      } else if (options.collectionTitle) {
        display.prepend(
          '<div class="dt-button-collection-title">' + options.collectionTitle + "</div>"
        );
      }
      if (options.closeButton) {
        display.prepend('<div class="dtb-popover-close">&times;</div>').addClass("dtb-collection-closeable");
      }
      _fadeIn(display.insertAfter(hostNode), options.fade);
      var tableContainer = $11(hostButton.table().container());
      var position = display.css("position");
      if (options.span === "container" || options.align === "dt-container") {
        hostNode = hostNode.parent();
        display.css("width", tableContainer.width());
      }
      if (position === "absolute") {
        var offsetParent = $11(hostNode[0].offsetParent);
        var buttonPosition = hostNode.position();
        var buttonOffset = hostNode.offset();
        var tableSizes = offsetParent.offset();
        var containerPosition = offsetParent.position();
        var computed = window.getComputedStyle(offsetParent[0]);
        tableSizes.height = offsetParent.outerHeight();
        tableSizes.width = offsetParent.width() + parseFloat(computed.paddingLeft);
        tableSizes.right = tableSizes.left + tableSizes.width;
        tableSizes.bottom = tableSizes.top + tableSizes.height;
        var top = buttonPosition.top + hostNode.outerHeight();
        var left = buttonPosition.left;
        display.css({
          top,
          left
        });
        computed = window.getComputedStyle(display[0]);
        var popoverSizes = display.offset();
        popoverSizes.height = display.outerHeight();
        popoverSizes.width = display.outerWidth();
        popoverSizes.right = popoverSizes.left + popoverSizes.width;
        popoverSizes.bottom = popoverSizes.top + popoverSizes.height;
        popoverSizes.marginTop = parseFloat(computed.marginTop);
        popoverSizes.marginBottom = parseFloat(computed.marginBottom);
        if (options.dropup) {
          top = buttonPosition.top - popoverSizes.height - popoverSizes.marginTop - popoverSizes.marginBottom;
        }
        if (options.align === "button-right" || display.hasClass(options.rightAlignClassName)) {
          left = buttonPosition.left - popoverSizes.width + hostNode.outerWidth();
        }
        if (options.align === "dt-container" || options.align === "container") {
          if (left < buttonPosition.left) {
            left = -buttonPosition.left;
          }
        }
        if (containerPosition.left + left + popoverSizes.width > $11(window).width()) {
          left = $11(window).width() - popoverSizes.width - containerPosition.left;
        }
        if (buttonOffset.left + left < 0) {
          left = -buttonOffset.left;
        }
        if (containerPosition.top + top + popoverSizes.height > $11(window).height() + $11(window).scrollTop()) {
          top = buttonPosition.top - popoverSizes.height - popoverSizes.marginTop - popoverSizes.marginBottom;
        }
        if (containerPosition.top + top < $11(window).scrollTop()) {
          top = buttonPosition.top + hostNode.outerHeight();
        }
        display.css({
          top,
          left
        });
      } else {
        var place = function() {
          var half = $11(window).height() / 2;
          var top2 = display.height() / 2;
          if (top2 > half) {
            top2 = half;
          }
          display.css("marginTop", top2 * -1);
        };
        place();
        $11(window).on("resize.dtb-collection", function() {
          place();
        });
      }
      if (options.background) {
        Buttons.background(
          true,
          options.backgroundClassName,
          options.fade,
          options.backgroundHost || hostNode
        );
      }
      $11("div.dt-button-background").on(
        "click.dtb-collection",
        function() {
        }
      );
      if (options.autoClose) {
        setTimeout(function() {
          dt.on("buttons-action.b-internal", function(e, btn, dt2, node) {
            if (node[0] === hostNode[0]) {
              return;
            }
            close();
          });
        }, 0);
      }
      $11(display).trigger("buttons-popover.dt");
      dt.on("destroy", close);
      setTimeout(function() {
        closed = false;
        $11("body").on("click.dtb-collection", function(e) {
          if (closed) {
            return;
          }
          var back = $11.fn.addBack ? "addBack" : "andSelf";
          var parent = $11(e.target).parent()[0];
          if (!$11(e.target).parents()[back]().filter(content).length && !$11(parent).hasClass("dt-buttons") || $11(e.target).hasClass("dt-button-background")) {
            close();
          }
        }).on("keyup.dtb-collection", function(e) {
          if (e.keyCode === 27) {
            close();
          }
        }).on("keydown.dtb-collection", function(e) {
          var elements = $11("a, button", content);
          var active = document.activeElement;
          if (e.keyCode !== 9) {
            return;
          }
          if (elements.index(active) === -1) {
            elements.first().focus();
            e.preventDefault();
          } else if (e.shiftKey) {
            if (active === elements[0]) {
              elements.last().focus();
              e.preventDefault();
            }
          } else {
            if (active === elements.last()[0]) {
              elements.first().focus();
              e.preventDefault();
            }
          }
        });
      }, 0);
    }
  });
  Buttons.background = function(show, className, fade, insertPoint) {
    if (fade === void 0) {
      fade = 400;
    }
    if (!insertPoint) {
      insertPoint = document.body;
    }
    if (show) {
      _fadeIn(
        $11("<div/>").addClass(className).css("display", "none").insertAfter(insertPoint),
        fade
      );
    } else {
      _fadeOut($11("div." + className), fade, function() {
        $11(this).removeClass(className).remove();
      });
    }
  };
  Buttons.instanceSelector = function(group, buttons) {
    if (group === void 0 || group === null) {
      return $11.map(buttons, function(v) {
        return v.inst;
      });
    }
    var ret = [];
    var names = $11.map(buttons, function(v) {
      return v.name;
    });
    var process = function(input) {
      if (Array.isArray(input)) {
        for (var i = 0, ien = input.length; i < ien; i++) {
          process(input[i]);
        }
        return;
      }
      if (typeof input === "string") {
        if (input.indexOf(",") !== -1) {
          process(input.split(","));
        } else {
          var idx = $11.inArray(input.trim(), names);
          if (idx !== -1) {
            ret.push(buttons[idx].inst);
          }
        }
      } else if (typeof input === "number") {
        ret.push(buttons[input].inst);
      } else if (typeof input === "object" && input.nodeName) {
        for (var j = 0; j < buttons.length; j++) {
          if (buttons[j].inst.dom.container[0] === input) {
            ret.push(buttons[j].inst);
          }
        }
      } else if (typeof input === "object") {
        ret.push(input);
      }
    };
    process(group);
    return ret;
  };
  Buttons.buttonSelector = function(insts, selector) {
    var ret = [];
    var nodeBuilder = function(a, buttons, baseIdx) {
      var button;
      var idx;
      for (var i2 = 0, ien2 = buttons.length; i2 < ien2; i2++) {
        button = buttons[i2];
        if (button) {
          idx = baseIdx !== void 0 ? baseIdx + i2 : i2 + "";
          a.push({
            node: button.node,
            name: button.conf.name,
            idx
          });
          if (button.buttons) {
            nodeBuilder(a, button.buttons, idx + "-");
          }
        }
      }
    };
    var run = function(selector2, inst2) {
      var i2, ien2;
      var buttons = [];
      nodeBuilder(buttons, inst2.s.buttons);
      var nodes = $11.map(buttons, function(v) {
        return v.node;
      });
      if (Array.isArray(selector2) || selector2 instanceof $11) {
        for (i2 = 0, ien2 = selector2.length; i2 < ien2; i2++) {
          run(selector2[i2], inst2);
        }
        return;
      }
      if (selector2 === null || selector2 === void 0 || selector2 === "*") {
        for (i2 = 0, ien2 = buttons.length; i2 < ien2; i2++) {
          ret.push({
            inst: inst2,
            node: buttons[i2].node
          });
        }
      } else if (typeof selector2 === "number") {
        if (inst2.s.buttons[selector2]) {
          ret.push({
            inst: inst2,
            node: inst2.s.buttons[selector2].node
          });
        }
      } else if (typeof selector2 === "string") {
        if (selector2.indexOf(",") !== -1) {
          var a = selector2.split(",");
          for (i2 = 0, ien2 = a.length; i2 < ien2; i2++) {
            run(a[i2].trim(), inst2);
          }
        } else if (selector2.match(/^\d+(\-\d+)*$/)) {
          var indexes = $11.map(buttons, function(v) {
            return v.idx;
          });
          ret.push({
            inst: inst2,
            node: buttons[$11.inArray(selector2, indexes)].node
          });
        } else if (selector2.indexOf(":name") !== -1) {
          var name = selector2.replace(":name", "");
          for (i2 = 0, ien2 = buttons.length; i2 < ien2; i2++) {
            if (buttons[i2].name === name) {
              ret.push({
                inst: inst2,
                node: buttons[i2].node
              });
            }
          }
        } else {
          $11(nodes).filter(selector2).each(function() {
            ret.push({
              inst: inst2,
              node: this
            });
          });
        }
      } else if (typeof selector2 === "object" && selector2.nodeName) {
        var idx = $11.inArray(selector2, nodes);
        if (idx !== -1) {
          ret.push({
            inst: inst2,
            node: nodes[idx]
          });
        }
      }
    };
    for (var i = 0, ien = insts.length; i < ien; i++) {
      var inst = insts[i];
      run(selector, inst);
    }
    return ret;
  };
  Buttons.stripData = function(str, config) {
    if (typeof str !== "string") {
      return str;
    }
    str = Buttons.stripHtmlScript(str);
    str = Buttons.stripHtmlComments(str);
    if (!config || config.stripHtml) {
      str = dataTables_default.util.stripHtml(str);
    }
    if (!config || config.trim) {
      str = str.trim();
    }
    if (!config || config.stripNewlines) {
      str = str.replace(/\n/g, " ");
    }
    if (!config || config.decodeEntities) {
      if (_entityDecoder) {
        str = _entityDecoder(str);
      } else {
        _exportTextarea.innerHTML = str;
        str = _exportTextarea.value;
      }
    }
    return str;
  };
  Buttons.entityDecoder = function(fn) {
    _entityDecoder = fn;
  };
  Buttons.stripHtmlComments = function(input) {
    var previous;
    do {
      previous = input;
      input = input.replace(/(<!--.*?--!?>)|(<!--[\S\s]+?--!?>)|(<!--[\S\s]*?$)/g, "");
    } while (input !== previous);
    return input;
  };
  Buttons.stripHtmlScript = function(input) {
    var previous;
    do {
      previous = input;
      input = input.replace(/<script\b[^<]*(?:(?!<\/script[^>]*>)<[^<]*)*<\/script[^>]*>/gi, "");
    } while (input !== previous);
    return input;
  };
  Buttons.defaults = {
    buttons: ["copy", "excel", "csv", "pdf", "print"],
    name: "main",
    tabIndex: 0,
    dom: {
      container: {
        tag: "div",
        className: "dt-buttons"
      },
      collection: {
        action: {
          // action button
          dropHtml: '<span class="dt-button-down-arrow">&#x25BC;</span>'
        },
        container: {
          // The element used for the dropdown
          className: "dt-button-collection",
          content: {
            className: "",
            tag: "div"
          },
          tag: "div"
        }
        // optionally
        // , button: IButton - buttons inside the collection container
        // , split: ISplit - splits inside the collection container
      },
      button: {
        tag: "button",
        className: "dt-button",
        active: "dt-button-active",
        // class name
        disabled: "disabled",
        // class name
        spacer: {
          className: "dt-button-spacer",
          tag: "span"
        },
        liner: {
          tag: "span",
          className: ""
        }
      },
      split: {
        action: {
          // action button
          className: "dt-button-split-drop-button dt-button",
          tag: "button"
        },
        dropdown: {
          // button to trigger the dropdown
          align: "split-right",
          className: "dt-button-split-drop",
          dropHtml: '<span class="dt-button-down-arrow">&#x25BC;</span>',
          splitAlignClass: "dt-button-split-left",
          tag: "button"
        },
        wrapper: {
          // wrap around both
          className: "dt-button-split",
          tag: "div"
        }
      }
    }
  };
  Buttons.version = "3.1.2";
  $11.extend(_dtButtons, {
    collection: {
      text: function(dt) {
        return dt.i18n("buttons.collection", "Collection");
      },
      className: "buttons-collection",
      closeButton: false,
      init: function(dt, button) {
        button.attr("aria-expanded", false);
      },
      action: function(e, dt, button, config) {
        if (config._collection.parents("body").length) {
          this.popover(false, config);
        } else {
          this.popover(config._collection, config);
        }
        if (e.type === "keypress") {
          $11("a, button", config._collection).eq(0).focus();
        }
      },
      attr: {
        "aria-haspopup": "dialog"
      }
      // Also the popover options, defined in Buttons.popover
    },
    split: {
      text: function(dt) {
        return dt.i18n("buttons.split", "Split");
      },
      className: "buttons-split",
      closeButton: false,
      init: function(dt, button) {
        return button.attr("aria-expanded", false);
      },
      action: function(e, dt, button, config) {
        this.popover(config._collection, config);
      },
      attr: {
        "aria-haspopup": "dialog"
      }
      // Also the popover options, defined in Buttons.popover
    },
    copy: function() {
      if (_dtButtons.copyHtml5) {
        return "copyHtml5";
      }
    },
    csv: function(dt, conf) {
      if (_dtButtons.csvHtml5 && _dtButtons.csvHtml5.available(dt, conf)) {
        return "csvHtml5";
      }
    },
    excel: function(dt, conf) {
      if (_dtButtons.excelHtml5 && _dtButtons.excelHtml5.available(dt, conf)) {
        return "excelHtml5";
      }
    },
    pdf: function(dt, conf) {
      if (_dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available(dt, conf)) {
        return "pdfHtml5";
      }
    },
    pageLength: function(dt) {
      var lengthMenu = dt.settings()[0].aLengthMenu;
      var vals = [];
      var lang = [];
      var text = function(dt2) {
        return dt2.i18n(
          "buttons.pageLength",
          {
            "-1": "Show all rows",
            _: "Show %d rows"
          },
          dt2.page.len()
        );
      };
      if (Array.isArray(lengthMenu[0])) {
        vals = lengthMenu[0];
        lang = lengthMenu[1];
      } else {
        for (var i = 0; i < lengthMenu.length; i++) {
          var option = lengthMenu[i];
          if ($11.isPlainObject(option)) {
            vals.push(option.value);
            lang.push(option.label);
          } else {
            vals.push(option);
            lang.push(option);
          }
        }
      }
      return {
        extend: "collection",
        text,
        className: "buttons-page-length",
        autoClose: true,
        buttons: $11.map(vals, function(val, i2) {
          return {
            text: lang[i2],
            className: "button-page-length",
            action: function(e, dt2) {
              dt2.page.len(val).draw();
            },
            init: function(dt2, node, conf) {
              var that = this;
              var fn = function() {
                that.active(dt2.page.len() === val);
              };
              dt2.on("length.dt" + conf.namespace, fn);
              fn();
            },
            destroy: function(dt2, node, conf) {
              dt2.off("length.dt" + conf.namespace);
            }
          };
        }),
        init: function(dt2, node, conf) {
          var that = this;
          dt2.on("length.dt" + conf.namespace, function() {
            that.text(conf.text);
          });
        },
        destroy: function(dt2, node, conf) {
          dt2.off("length.dt" + conf.namespace);
        }
      };
    },
    spacer: {
      style: "empty",
      spacer: true,
      text: function(dt) {
        return dt.i18n("buttons.spacer", "");
      }
    }
  });
  dataTables_default.Api.register("buttons()", function(group, selector) {
    if (selector === void 0) {
      selector = group;
      group = void 0;
    }
    this.selector.buttonGroup = group;
    var res = this.iterator(
      true,
      "table",
      function(ctx) {
        if (ctx._buttons) {
          return Buttons.buttonSelector(
            Buttons.instanceSelector(group, ctx._buttons),
            selector
          );
        }
      },
      true
    );
    res._groupSelector = group;
    return res;
  });
  dataTables_default.Api.register("button()", function(group, selector) {
    var buttons = this.buttons(group, selector);
    if (buttons.length > 1) {
      buttons.splice(1, buttons.length);
    }
    return buttons;
  });
  dataTables_default.Api.registerPlural(
    "buttons().active()",
    "button().active()",
    function(flag) {
      if (flag === void 0) {
        return this.map(function(set) {
          return set.inst.active(set.node);
        });
      }
      return this.each(function(set) {
        set.inst.active(set.node, flag);
      });
    }
  );
  dataTables_default.Api.registerPlural(
    "buttons().action()",
    "button().action()",
    function(action) {
      if (action === void 0) {
        return this.map(function(set) {
          return set.inst.action(set.node);
        });
      }
      return this.each(function(set) {
        set.inst.action(set.node, action);
      });
    }
  );
  dataTables_default.Api.registerPlural(
    "buttons().collectionRebuild()",
    "button().collectionRebuild()",
    function(buttons) {
      return this.each(function(set) {
        for (var i = 0; i < buttons.length; i++) {
          if (typeof buttons[i] === "object") {
            buttons[i].parentConf = set;
          }
        }
        set.inst.collectionRebuild(set.node, buttons);
      });
    }
  );
  dataTables_default.Api.register(
    ["buttons().enable()", "button().enable()"],
    function(flag) {
      return this.each(function(set) {
        set.inst.enable(set.node, flag);
      });
    }
  );
  dataTables_default.Api.register(
    ["buttons().disable()", "button().disable()"],
    function() {
      return this.each(function(set) {
        set.inst.disable(set.node);
      });
    }
  );
  dataTables_default.Api.register("button().index()", function() {
    var idx = null;
    this.each(function(set) {
      var res = set.inst.index(set.node);
      if (res !== null) {
        idx = res;
      }
    });
    return idx;
  });
  dataTables_default.Api.registerPlural(
    "buttons().nodes()",
    "button().node()",
    function() {
      var jq = $11();
      $11(
        this.each(function(set) {
          jq = jq.add(set.inst.node(set.node));
        })
      );
      return jq;
    }
  );
  dataTables_default.Api.registerPlural(
    "buttons().processing()",
    "button().processing()",
    function(flag) {
      if (flag === void 0) {
        return this.map(function(set) {
          return set.inst.processing(set.node);
        });
      }
      return this.each(function(set) {
        set.inst.processing(set.node, flag);
      });
    }
  );
  dataTables_default.Api.registerPlural(
    "buttons().text()",
    "button().text()",
    function(label) {
      if (label === void 0) {
        return this.map(function(set) {
          return set.inst.text(set.node);
        });
      }
      return this.each(function(set) {
        set.inst.text(set.node, label);
      });
    }
  );
  dataTables_default.Api.registerPlural(
    "buttons().trigger()",
    "button().trigger()",
    function() {
      return this.each(function(set) {
        set.inst.node(set.node).trigger("click");
      });
    }
  );
  dataTables_default.Api.register("button().popover()", function(content, options) {
    return this.map(function(set) {
      return set.inst._popover(content, this.button(this[0].node), options);
    });
  });
  dataTables_default.Api.register("buttons().containers()", function() {
    var jq = $11();
    var groupSelector = this._groupSelector;
    this.iterator(true, "table", function(ctx) {
      if (ctx._buttons) {
        var insts = Buttons.instanceSelector(groupSelector, ctx._buttons);
        for (var i = 0, ien = insts.length; i < ien; i++) {
          jq = jq.add(insts[i].container());
        }
      }
    });
    return jq;
  });
  dataTables_default.Api.register("buttons().container()", function() {
    return this.containers().eq(0);
  });
  dataTables_default.Api.register("button().add()", function(idx, conf, draw) {
    var ctx = this.context;
    if (ctx.length) {
      var inst = Buttons.instanceSelector(
        this._groupSelector,
        ctx[0]._buttons
      );
      if (inst.length) {
        inst[0].add(conf, idx, draw);
      }
    }
    return this.button(this._groupSelector, idx);
  });
  dataTables_default.Api.register("buttons().destroy()", function() {
    this.pluck("inst").unique().each(function(inst) {
      inst.destroy();
    });
    return this;
  });
  dataTables_default.Api.registerPlural(
    "buttons().remove()",
    "buttons().remove()",
    function() {
      this.each(function(set) {
        set.inst.remove(set.node);
      });
      return this;
    }
  );
  var _infoTimer;
  dataTables_default.Api.register("buttons.info()", function(title, message, time) {
    var that = this;
    if (title === false) {
      this.off("destroy.btn-info");
      _fadeOut($11("#datatables_buttons_info"), 400, function() {
        $11(this).remove();
      });
      clearTimeout(_infoTimer);
      _infoTimer = null;
      return this;
    }
    if (_infoTimer) {
      clearTimeout(_infoTimer);
    }
    if ($11("#datatables_buttons_info").length) {
      $11("#datatables_buttons_info").remove();
    }
    title = title ? "<h2>" + title + "</h2>" : "";
    _fadeIn(
      $11('<div id="datatables_buttons_info" class="dt-button-info"/>').html(title).append(
        $11("<div/>")[typeof message === "string" ? "html" : "append"](
          message
        )
      ).css("display", "none").appendTo("body")
    );
    if (time !== void 0 && time !== 0) {
      _infoTimer = setTimeout(function() {
        that.buttons.info(false);
      }, time);
    }
    this.on("destroy.btn-info", function() {
      that.buttons.info(false);
    });
    return this;
  });
  dataTables_default.Api.register("buttons.exportData()", function(options) {
    if (this.context.length) {
      return _exportData(new dataTables_default.Api(this.context[0]), options);
    }
  });
  dataTables_default.Api.register("buttons.exportInfo()", function(conf) {
    if (!conf) {
      conf = {};
    }
    return {
      filename: _filename(conf, this),
      title: _title(conf, this),
      messageTop: _message(this, conf, conf.message || conf.messageTop, "top"),
      messageBottom: _message(this, conf, conf.messageBottom, "bottom")
    };
  });
  var _filename = function(config, dt) {
    var filename = config.filename === "*" && config.title !== "*" && config.title !== void 0 && config.title !== null && config.title !== "" ? config.title : config.filename;
    if (typeof filename === "function") {
      filename = filename(config, dt);
    }
    if (filename === void 0 || filename === null) {
      return null;
    }
    if (filename.indexOf("*") !== -1) {
      filename = filename.replace(/\*/g, $11("head > title").text()).trim();
    }
    filename = filename.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "");
    var extension = _stringOrFunction(config.extension, config, dt);
    if (!extension) {
      extension = "";
    }
    return filename + extension;
  };
  var _stringOrFunction = function(option, config, dt) {
    if (option === null || option === void 0) {
      return null;
    } else if (typeof option === "function") {
      return option(config, dt);
    }
    return option;
  };
  var _title = function(config, dt) {
    var title = _stringOrFunction(config.title, config, dt);
    return title === null ? null : title.indexOf("*") !== -1 ? title.replace(/\*/g, $11("head > title").text() || "Exported data") : title;
  };
  var _message = function(dt, config, option, position) {
    var message = _stringOrFunction(option, config, dt);
    if (message === null) {
      return null;
    }
    var caption = $11("caption", dt.table().container()).eq(0);
    if (message === "*") {
      var side = caption.css("caption-side");
      if (side !== position) {
        return null;
      }
      return caption.length ? caption.text() : "";
    }
    return message;
  };
  var _exportTextarea = $11("<textarea/>")[0];
  var _exportData = function(dt, inOpts) {
    var config = $11.extend(
      true,
      {},
      {
        rows: null,
        columns: "",
        modifier: {
          search: "applied",
          order: "applied"
        },
        orthogonal: "display",
        stripHtml: true,
        stripNewlines: true,
        decodeEntities: true,
        trim: true,
        format: {
          header: function(d) {
            return Buttons.stripData(d, config);
          },
          footer: function(d) {
            return Buttons.stripData(d, config);
          },
          body: function(d) {
            return Buttons.stripData(d, config);
          }
        },
        customizeData: null,
        customizeZip: null
      },
      inOpts
    );
    var header = dt.columns(config.columns).indexes().map(function(idx) {
      var col = dt.column(idx);
      return config.format.header(col.title(), idx, col.header());
    }).toArray();
    var footer = dt.table().footer() ? dt.columns(config.columns).indexes().map(function(idx) {
      var el = dt.column(idx).footer();
      var val = "";
      if (el) {
        var inner = $11(".dt-column-title", el);
        val = inner.length ? inner.html() : $11(el).html();
      }
      return config.format.footer(val, idx, el);
    }).toArray() : null;
    var modifier = $11.extend({}, config.modifier);
    if (dt.select && typeof dt.select.info === "function" && modifier.selected === void 0) {
      if (dt.rows(config.rows, $11.extend({ selected: true }, modifier)).any()) {
        $11.extend(modifier, { selected: true });
      }
    }
    var rowIndexes = dt.rows(config.rows, modifier).indexes().toArray();
    var selectedCells = dt.cells(rowIndexes, config.columns, {
      order: modifier.order
    });
    var cells = selectedCells.render(config.orthogonal).toArray();
    var cellNodes = selectedCells.nodes().toArray();
    var cellIndexes = selectedCells.indexes().toArray();
    var columns = dt.columns(config.columns).count();
    var rows = columns > 0 ? cells.length / columns : 0;
    var body = [];
    var cellCounter = 0;
    for (var i = 0, ien = rows; i < ien; i++) {
      var row = [columns];
      for (var j = 0; j < columns; j++) {
        row[j] = config.format.body(
          cells[cellCounter],
          cellIndexes[cellCounter].row,
          cellIndexes[cellCounter].column,
          cellNodes[cellCounter]
        );
        cellCounter++;
      }
      body[i] = row;
    }
    var data = {
      header,
      headerStructure: _headerFormatter(
        config.format.header,
        dt.table().header.structure(config.columns)
      ),
      footer,
      footerStructure: _headerFormatter(
        config.format.footer,
        dt.table().footer.structure(config.columns)
      ),
      body
    };
    if (config.customizeData) {
      config.customizeData(data);
    }
    return data;
  };
  function _headerFormatter(formatter, struct) {
    for (var i = 0; i < struct.length; i++) {
      for (var j = 0; j < struct[i].length; j++) {
        var item = struct[i][j];
        if (item) {
          item.title = formatter(
            item.title,
            j,
            item.cell
          );
        }
      }
    }
    return struct;
  }
  $11.fn.dataTable.Buttons = Buttons;
  $11.fn.DataTable.Buttons = Buttons;
  $11(document).on("init.dt plugin-init.dt", function(e, settings) {
    if (e.namespace !== "dt") {
      return;
    }
    var opts = settings.oInit.buttons || dataTables_default.defaults.buttons;
    if (opts && !settings._buttons) {
      new Buttons(settings, opts).container();
    }
  });
  function _init(settings, options) {
    var api = new dataTables_default.Api(settings);
    var opts = options ? options : api.init().buttons || dataTables_default.defaults.buttons;
    return new Buttons(api, opts).container();
  }
  dataTables_default.ext.feature.push({
    fnInit: _init,
    cFeature: "B"
  });
  if (dataTables_default.feature) {
    dataTables_default.feature.register("buttons", _init);
  }

  // node_modules/datatables.net-buttons-bs5/js/buttons.bootstrap5.mjs
  var $12 = import_jquery14.default;
  $12.extend(true, dataTables_bootstrap5_default.Buttons.defaults, {
    dom: {
      container: {
        className: "dt-buttons btn-group flex-wrap"
      },
      button: {
        className: "btn btn-secondary",
        active: "active"
      },
      collection: {
        action: {
          dropHtml: ""
        },
        container: {
          tag: "div",
          className: "dropdown-menu dt-button-collection"
        },
        closeButton: false,
        button: {
          tag: "a",
          className: "dt-button dropdown-item",
          active: "dt-button-active",
          disabled: "disabled",
          spacer: {
            className: "dropdown-divider",
            tag: "hr"
          }
        }
      },
      split: {
        action: {
          tag: "a",
          className: "btn btn-secondary dt-button-split-drop-button",
          closeButton: false
        },
        dropdown: {
          tag: "button",
          dropHtml: "",
          className: "btn btn-secondary dt-button-split-drop dropdown-toggle dropdown-toggle-split",
          closeButton: false,
          align: "split-left",
          splitAlignClass: "dt-button-split-left"
        },
        wrapper: {
          tag: "div",
          className: "dt-button-split btn-group",
          closeButton: false
        }
      }
    },
    buttonCreated: function(config, button) {
      return config.buttons ? $12('<div class="btn-group"/>').append(button) : button;
    }
  });
  dataTables_bootstrap5_default.ext.buttons.collection.className += " dropdown-toggle";
  dataTables_bootstrap5_default.ext.buttons.collection.rightAlignClassName = "dropdown-menu-right";

  // node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.mjs
  var import_jquery16 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-responsive/js/dataTables.responsive.mjs
  var import_jquery15 = __toESM(require_jquery(), 1);
  var $13 = import_jquery15.default;
  var Responsive = function(settings, opts) {
    if (!dataTables_default.versionCheck || !dataTables_default.versionCheck("2")) {
      throw "DataTables Responsive requires DataTables 2 or newer";
    }
    this.s = {
      childNodeStore: {},
      columns: [],
      current: [],
      dt: new dataTables_default.Api(settings)
    };
    if (this.s.dt.settings()[0].responsive) {
      return;
    }
    if (opts && typeof opts.details === "string") {
      opts.details = { type: opts.details };
    } else if (opts && opts.details === false) {
      opts.details = { type: false };
    } else if (opts && opts.details === true) {
      opts.details = { type: "inline" };
    }
    this.c = $13.extend(
      true,
      {},
      Responsive.defaults,
      dataTables_default.defaults.responsive,
      opts
    );
    settings.responsive = this;
    this._constructor();
  };
  $13.extend(Responsive.prototype, {
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Constructor
     */
    /**
     * Initialise the Responsive instance
     *
     * @private
     */
    _constructor: function() {
      var that = this;
      var dt = this.s.dt;
      var oldWindowWidth = $13(window).innerWidth();
      dt.settings()[0]._responsive = this;
      $13(window).on(
        "orientationchange.dtr",
        dataTables_default.util.throttle(function() {
          var width = $13(window).innerWidth();
          if (width !== oldWindowWidth) {
            that._resize();
            oldWindowWidth = width;
          }
        })
      );
      dt.on("row-created.dtr", function(e, tr, data, idx) {
        if ($13.inArray(false, that.s.current) !== -1) {
          $13(">td, >th", tr).each(function(i) {
            var idx2 = dt.column.index("toData", i);
            if (that.s.current[idx2] === false) {
              $13(this).css("display", "none").addClass("dtr-hidden");
            }
          });
        }
      });
      dt.on("destroy.dtr", function() {
        dt.off(".dtr");
        $13(dt.table().body()).off(".dtr");
        $13(window).off("resize.dtr orientationchange.dtr");
        dt.cells(".dtr-control").nodes().to$().removeClass("dtr-control");
        $13(dt.table().node()).removeClass("dtr-inline collapsed");
        $13.each(that.s.current, function(i, val) {
          if (val === false) {
            that._setColumnVis(i, true);
          }
        });
      });
      this.c.breakpoints.sort(function(a, b) {
        return a.width < b.width ? 1 : a.width > b.width ? -1 : 0;
      });
      this._classLogic();
      var details = this.c.details;
      if (details.type !== false) {
        that._detailsInit();
        dt.on("column-visibility.dtr", function() {
          if (that._timer) {
            clearTimeout(that._timer);
          }
          that._timer = setTimeout(function() {
            that._timer = null;
            that._classLogic();
            that._resizeAuto();
            that._resize(true);
            that._redrawChildren();
          }, 100);
        });
        dt.on("draw.dtr", function() {
          that._redrawChildren();
        });
        $13(dt.table().node()).addClass("dtr-" + details.type);
      }
      dt.on("column-calc.dt", function(e, d) {
        var curr = that.s.current;
        for (var i = 0; i < curr.length; i++) {
          var idx = d.visible.indexOf(i);
          if (curr[i] === false && idx >= 0) {
            d.visible.splice(idx, 1);
          }
        }
      });
      dt.on("preXhr.dtr", function() {
        var rowIds = [];
        dt.rows().every(function() {
          if (this.child.isShown()) {
            rowIds.push(this.id(true));
          }
        });
        dt.one("draw.dtr", function() {
          that._resizeAuto();
          that._resize();
          dt.rows(rowIds).every(function() {
            that._detailsDisplay(this, false);
          });
        });
      });
      dt.on("draw.dtr", function() {
        that._controlClass();
      }).ready(function() {
        that._resizeAuto();
        that._resize();
        dt.on("column-reorder.dtr", function(e, settings, details2) {
          that._classLogic();
          that._resizeAuto();
          that._resize(true);
        });
        dt.on("column-sizing.dtr", function() {
          that._resizeAuto();
          that._resize();
        });
      });
    },
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Private methods
     */
    /**
     * Insert a `col` tag into the correct location in a `colgroup`.
     *
     * @param {jQuery} colGroup The `colgroup` tag
     * @param {jQuery} colEl The `col` tag
     */
    _colGroupAttach: function(colGroup, colEls, idx) {
      var found = null;
      if (colEls[idx].get(0).parentNode === colGroup[0]) {
        return;
      }
      for (var i = idx + 1; i < colEls.length; i++) {
        if (colGroup[0] === colEls[i].get(0).parentNode) {
          found = i;
          break;
        }
      }
      if (found !== null) {
        colEls[idx].insertBefore(colEls[found][0]);
      } else {
        colGroup.append(colEls[idx]);
      }
    },
    /**
     * Get and store nodes from a cell - use for node moving renderers
     *
     * @param {*} dt DT instance
     * @param {*} row Row index
     * @param {*} col Column index
     */
    _childNodes: function(dt, row, col) {
      var name = row + "-" + col;
      if (this.s.childNodeStore[name]) {
        return this.s.childNodeStore[name];
      }
      var nodes = [];
      var children = dt.cell(row, col).node().childNodes;
      for (var i = 0, ien = children.length; i < ien; i++) {
        nodes.push(children[i]);
      }
      this.s.childNodeStore[name] = nodes;
      return nodes;
    },
    /**
     * Restore nodes from the cache to a table cell
     *
     * @param {*} dt DT instance
     * @param {*} row Row index
     * @param {*} col Column index
     */
    _childNodesRestore: function(dt, row, col) {
      var name = row + "-" + col;
      if (!this.s.childNodeStore[name]) {
        return;
      }
      var node = dt.cell(row, col).node();
      var store = this.s.childNodeStore[name];
      if (store.length > 0) {
        var parent = store[0].parentNode;
        var parentChildren = parent.childNodes;
        var a = [];
        for (var i = 0, ien = parentChildren.length; i < ien; i++) {
          a.push(parentChildren[i]);
        }
        for (var j = 0, jen = a.length; j < jen; j++) {
          node.appendChild(a[j]);
        }
      }
      this.s.childNodeStore[name] = void 0;
    },
    /**
     * Calculate the visibility for the columns in a table for a given
     * breakpoint. The result is pre-determined based on the class logic if
     * class names are used to control all columns, but the width of the table
     * is also used if there are columns which are to be automatically shown
     * and hidden.
     *
     * @param  {string} breakpoint Breakpoint name to use for the calculation
     * @return {array} Array of boolean values initiating the visibility of each
     *   column.
     *  @private
     */
    _columnsVisiblity: function(breakpoint) {
      var dt = this.s.dt;
      var columns = this.s.columns;
      var i, ien;
      var order = columns.map(function(col, idx) {
        return {
          columnIdx: idx,
          priority: col.priority
        };
      }).sort(function(a, b) {
        if (a.priority !== b.priority) {
          return a.priority - b.priority;
        }
        return a.columnIdx - b.columnIdx;
      });
      var display = $13.map(columns, function(col, i2) {
        if (dt.column(i2).visible() === false) {
          return "not-visible";
        }
        return col.auto && col.minWidth === null ? false : col.auto === true ? "-" : $13.inArray(breakpoint, col.includeIn) !== -1;
      });
      var requiredWidth = 0;
      for (i = 0, ien = display.length; i < ien; i++) {
        if (display[i] === true) {
          requiredWidth += columns[i].minWidth;
        }
      }
      var scrolling = dt.settings()[0].oScroll;
      var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;
      var widthAvailable = dt.table().container().offsetWidth - bar;
      var usedWidth = widthAvailable - requiredWidth;
      for (i = 0, ien = display.length; i < ien; i++) {
        if (columns[i].control) {
          usedWidth -= columns[i].minWidth;
        }
      }
      var empty = false;
      for (i = 0, ien = order.length; i < ien; i++) {
        var colIdx = order[i].columnIdx;
        if (display[colIdx] === "-" && !columns[colIdx].control && columns[colIdx].minWidth) {
          if (empty || usedWidth - columns[colIdx].minWidth < 0) {
            empty = true;
            display[colIdx] = false;
          } else {
            display[colIdx] = true;
          }
          usedWidth -= columns[colIdx].minWidth;
        }
      }
      var showControl = false;
      for (i = 0, ien = columns.length; i < ien; i++) {
        if (!columns[i].control && !columns[i].never && display[i] === false) {
          showControl = true;
          break;
        }
      }
      for (i = 0, ien = columns.length; i < ien; i++) {
        if (columns[i].control) {
          display[i] = showControl;
        }
        if (display[i] === "not-visible") {
          display[i] = false;
        }
      }
      if ($13.inArray(true, display) === -1) {
        display[0] = true;
      }
      return display;
    },
    /**
     * Create the internal `columns` array with information about the columns
     * for the table. This includes determining which breakpoints the column
     * will appear in, based upon class names in the column, which makes up the
     * vast majority of this method.
     *
     * @private
     */
    _classLogic: function() {
      var that = this;
      var breakpoints = this.c.breakpoints;
      var dt = this.s.dt;
      var columns = dt.columns().eq(0).map(function(i) {
        var column2 = this.column(i);
        var className = column2.header().className;
        var priority = column2.init().responsivePriority;
        var dataPriority = column2.header().getAttribute("data-priority");
        if (priority === void 0) {
          priority = dataPriority === void 0 || dataPriority === null ? 1e4 : dataPriority * 1;
        }
        return {
          className,
          includeIn: [],
          auto: false,
          control: false,
          never: className.match(/\b(dtr\-)?never\b/) ? true : false,
          priority
        };
      });
      var add = function(colIdx, name) {
        var includeIn = columns[colIdx].includeIn;
        if ($13.inArray(name, includeIn) === -1) {
          includeIn.push(name);
        }
      };
      var column = function(colIdx, name, operator, matched) {
        var size, i, ien;
        if (!operator) {
          columns[colIdx].includeIn.push(name);
        } else if (operator === "max-") {
          size = that._find(name).width;
          for (i = 0, ien = breakpoints.length; i < ien; i++) {
            if (breakpoints[i].width <= size) {
              add(colIdx, breakpoints[i].name);
            }
          }
        } else if (operator === "min-") {
          size = that._find(name).width;
          for (i = 0, ien = breakpoints.length; i < ien; i++) {
            if (breakpoints[i].width >= size) {
              add(colIdx, breakpoints[i].name);
            }
          }
        } else if (operator === "not-") {
          for (i = 0, ien = breakpoints.length; i < ien; i++) {
            if (breakpoints[i].name.indexOf(matched) === -1) {
              add(colIdx, breakpoints[i].name);
            }
          }
        }
      };
      columns.each(function(col, i) {
        var classNames = col.className.split(" ");
        var hasClass = false;
        for (var k = 0, ken = classNames.length; k < ken; k++) {
          var className = classNames[k].trim();
          if (className === "all" || className === "dtr-all") {
            hasClass = true;
            col.includeIn = $13.map(breakpoints, function(a) {
              return a.name;
            });
            return;
          } else if (className === "none" || className === "dtr-none" || col.never) {
            hasClass = true;
            return;
          } else if (className === "control" || className === "dtr-control") {
            hasClass = true;
            col.control = true;
            return;
          }
          $13.each(breakpoints, function(j, breakpoint) {
            var brokenPoint = breakpoint.name.split("-");
            var re = new RegExp(
              "(min\\-|max\\-|not\\-)?(" + brokenPoint[0] + ")(\\-[_a-zA-Z0-9])?"
            );
            var match = className.match(re);
            if (match) {
              hasClass = true;
              if (match[2] === brokenPoint[0] && match[3] === "-" + brokenPoint[1]) {
                column(
                  i,
                  breakpoint.name,
                  match[1],
                  match[2] + match[3]
                );
              } else if (match[2] === brokenPoint[0] && !match[3]) {
                column(i, breakpoint.name, match[1], match[2]);
              }
            }
          });
        }
        if (!hasClass) {
          col.auto = true;
        }
      });
      this.s.columns = columns;
    },
    /**
     * Update the cells to show the correct control class / button
     * @private
     */
    _controlClass: function() {
      if (this.c.details.type === "inline") {
        var dt = this.s.dt;
        var columnsVis = this.s.current;
        var firstVisible = $13.inArray(true, columnsVis);
        dt.cells(
          null,
          function(idx) {
            return idx !== firstVisible;
          },
          { page: "current" }
        ).nodes().to$().filter(".dtr-control").removeClass("dtr-control");
        dt.cells(null, firstVisible, { page: "current" }).nodes().to$().addClass("dtr-control");
      }
    },
    /**
     * Show the details for the child row
     *
     * @param  {DataTables.Api} row    API instance for the row
     * @param  {boolean}        update Update flag
     * @private
     */
    _detailsDisplay: function(row, update) {
      var that = this;
      var dt = this.s.dt;
      var details = this.c.details;
      var event = function(res2) {
        $13(row.node()).toggleClass("dtr-expanded", res2 !== false);
        $13(dt.table().node()).triggerHandler("responsive-display.dt", [
          dt,
          row,
          res2,
          update
        ]);
      };
      if (details && details.type !== false) {
        var renderer = typeof details.renderer === "string" ? Responsive.renderer[details.renderer]() : details.renderer;
        var res = details.display(
          row,
          update,
          function() {
            return renderer.call(
              that,
              dt,
              row[0][0],
              that._detailsObj(row[0])
            );
          },
          function() {
            event(false);
          }
        );
        if (typeof res === "boolean") {
          event(res);
        }
      }
    },
    /**
     * Initialisation for the details handler
     *
     * @private
     */
    _detailsInit: function() {
      var that = this;
      var dt = this.s.dt;
      var details = this.c.details;
      if (details.type === "inline") {
        details.target = "td.dtr-control, th.dtr-control";
      }
      dt.on("draw.dtr", function() {
        that._tabIndexes();
      });
      that._tabIndexes();
      $13(dt.table().body()).on("keyup.dtr", "td, th", function(e) {
        if (e.keyCode === 13 && $13(this).data("dtr-keyboard")) {
          $13(this).click();
        }
      });
      var target = details.target;
      var selector = typeof target === "string" ? target : "td, th";
      if (target !== void 0 || target !== null) {
        $13(dt.table().body()).on(
          "click.dtr mousedown.dtr mouseup.dtr",
          selector,
          function(e) {
            if (!$13(dt.table().node()).hasClass("collapsed")) {
              return;
            }
            if ($13.inArray(
              $13(this).closest("tr").get(0),
              dt.rows().nodes().toArray()
            ) === -1) {
              return;
            }
            if (typeof target === "number") {
              var targetIdx = target < 0 ? dt.columns().eq(0).length + target : target;
              if (dt.cell(this).index().column !== targetIdx) {
                return;
              }
            }
            var row = dt.row($13(this).closest("tr"));
            if (e.type === "click") {
              that._detailsDisplay(row, false);
            } else if (e.type === "mousedown") {
              $13(this).css("outline", "none");
            } else if (e.type === "mouseup") {
              $13(this).trigger("blur").css("outline", "");
            }
          }
        );
      }
    },
    /**
     * Get the details to pass to a renderer for a row
     * @param  {int} rowIdx Row index
     * @private
     */
    _detailsObj: function(rowIdx) {
      var that = this;
      var dt = this.s.dt;
      return $13.map(this.s.columns, function(col, i) {
        if (col.never || col.control) {
          return;
        }
        var dtCol = dt.settings()[0].aoColumns[i];
        return {
          className: dtCol.sClass,
          columnIndex: i,
          data: dt.cell(rowIdx, i).render(that.c.orthogonal),
          hidden: dt.column(i).visible() && !that.s.current[i],
          rowIndex: rowIdx,
          title: dt.column(i).title()
        };
      });
    },
    /**
     * Find a breakpoint object from a name
     *
     * @param  {string} name Breakpoint name to find
     * @return {object}      Breakpoint description object
     * @private
     */
    _find: function(name) {
      var breakpoints = this.c.breakpoints;
      for (var i = 0, ien = breakpoints.length; i < ien; i++) {
        if (breakpoints[i].name === name) {
          return breakpoints[i];
        }
      }
    },
    /**
     * Re-create the contents of the child rows as the display has changed in
     * some way.
     *
     * @private
     */
    _redrawChildren: function() {
      var that = this;
      var dt = this.s.dt;
      dt.rows({ page: "current" }).iterator("row", function(settings, idx) {
        that._detailsDisplay(dt.row(idx), true);
      });
    },
    /**
     * Alter the table display for a resized viewport. This involves first
     * determining what breakpoint the window currently is in, getting the
     * column visibilities to apply and then setting them.
     *
     * @param  {boolean} forceRedraw Force a redraw
     * @private
     */
    _resize: function(forceRedraw) {
      var that = this;
      var dt = this.s.dt;
      var width = $13(window).innerWidth();
      var breakpoints = this.c.breakpoints;
      var breakpoint = breakpoints[0].name;
      var columns = this.s.columns;
      var i, ien;
      var oldVis = this.s.current.slice();
      for (i = breakpoints.length - 1; i >= 0; i--) {
        if (width <= breakpoints[i].width) {
          breakpoint = breakpoints[i].name;
          break;
        }
      }
      var columnsVis = this._columnsVisiblity(breakpoint);
      this.s.current = columnsVis;
      var collapsedClass = false;
      for (i = 0, ien = columns.length; i < ien; i++) {
        if (columnsVis[i] === false && !columns[i].never && !columns[i].control && !dt.column(i).visible() === false) {
          collapsedClass = true;
          break;
        }
      }
      $13(dt.table().node()).toggleClass("collapsed", collapsedClass);
      var changed = false;
      var visible = 0;
      var dtSettings = dt.settings()[0];
      var colGroup = $13(dt.table().node()).children("colgroup");
      var colEls = dtSettings.aoColumns.map(function(col) {
        return col.colEl;
      });
      dt.columns().eq(0).each(function(colIdx, i2) {
        if (!dt.column(colIdx).visible()) {
          return;
        }
        if (columnsVis[i2] === true) {
          visible++;
        }
        if (forceRedraw || columnsVis[i2] !== oldVis[i2]) {
          changed = true;
          that._setColumnVis(colIdx, columnsVis[i2]);
        }
        if (!columnsVis[i2]) {
          colEls[i2].detach();
        } else {
          that._colGroupAttach(colGroup, colEls, i2);
        }
      });
      if (changed) {
        dt.columns.adjust();
        this._redrawChildren();
        $13(dt.table().node()).trigger("responsive-resize.dt", [
          dt,
          this._responsiveOnlyHidden()
        ]);
        if (dt.page.info().recordsDisplay === 0) {
          $13("td", dt.table().body()).eq(0).attr("colspan", visible);
        }
      }
      that._controlClass();
    },
    /**
     * Determine the width of each column in the table so the auto column hiding
     * has that information to work with. This method is never going to be 100%
     * perfect since column widths can change slightly per page, but without
     * seriously compromising performance this is quite effective.
     *
     * @private
     */
    _resizeAuto: function() {
      var dt = this.s.dt;
      var columns = this.s.columns;
      var that = this;
      var visibleColumns = dt.columns().indexes().filter(function(idx) {
        return dt.column(idx).visible();
      });
      if (!this.c.auto) {
        return;
      }
      if ($13.inArray(
        true,
        $13.map(columns, function(c) {
          return c.auto;
        })
      ) === -1) {
        return;
      }
      var clonedTable = dt.table().node().cloneNode(false);
      var clonedHeader = $13(dt.table().header().cloneNode(false)).appendTo(
        clonedTable
      );
      var clonedFooter = $13(dt.table().footer().cloneNode(false)).appendTo(
        clonedTable
      );
      var clonedBody = $13(dt.table().body()).clone(false, false).empty().appendTo(clonedTable);
      clonedTable.style.width = "auto";
      dt.table().header.structure(visibleColumns).forEach((row) => {
        var cells = row.filter(function(el) {
          return el ? true : false;
        }).map(function(el) {
          return $13(el.cell).clone(false).css("display", "table-cell").css("width", "auto").css("min-width", 0);
        });
        $13("<tr/>").append(cells).appendTo(clonedHeader);
      });
      var emptyRow = $13("<tr/>").appendTo(clonedBody);
      for (var i = 0; i < visibleColumns.count(); i++) {
        emptyRow.append("<td/>");
      }
      if (this.c.details.renderer._responsiveMovesNodes) {
        dt.rows({ page: "current" }).every(function(rowIdx) {
          var node = this.node();
          if (!node) {
            return;
          }
          var tr = node.cloneNode(false);
          dt.cells(rowIdx, visibleColumns).every(function(rowIdx2, colIdx) {
            var store = that.s.childNodeStore[rowIdx + "-" + colIdx];
            if (store) {
              $13(this.node().cloneNode(false)).append($13(store).clone()).appendTo(tr);
            } else {
              $13(this.node()).clone(false).appendTo(tr);
            }
          });
          clonedBody.append(tr);
        });
      } else {
        $13(clonedBody).append($13(dt.rows({ page: "current" }).nodes()).clone(false)).find("th, td").css("display", "");
      }
      clonedBody.find("th, td").css("display", "");
      dt.table().footer.structure(visibleColumns).forEach((row) => {
        var cells = row.filter(function(el) {
          return el ? true : false;
        }).map(function(el) {
          return $13(el.cell).clone(false).css("display", "table-cell").css("width", "auto").css("min-width", 0);
        });
        $13("<tr/>").append(cells).appendTo(clonedFooter);
      });
      if (this.c.details.type === "inline") {
        $13(clonedTable).addClass("dtr-inline collapsed");
      }
      $13(clonedTable).find("[name]").removeAttr("name");
      $13(clonedTable).css("position", "relative");
      var inserted = $13("<div/>").css({
        width: 1,
        height: 1,
        overflow: "hidden",
        clear: "both"
      }).append(clonedTable);
      inserted.insertBefore(dt.table().node());
      emptyRow.children().each(function(i2) {
        var idx = dt.column.index("fromVisible", i2);
        columns[idx].minWidth = this.offsetWidth || 0;
      });
      inserted.remove();
    },
    /**
     * Get the state of the current hidden columns - controlled by Responsive only
     */
    _responsiveOnlyHidden: function() {
      var dt = this.s.dt;
      return $13.map(this.s.current, function(v, i) {
        if (dt.column(i).visible() === false) {
          return true;
        }
        return v;
      });
    },
    /**
     * Set a column's visibility.
     *
     * We don't use DataTables' column visibility controls in order to ensure
     * that column visibility can Responsive can no-exist. Since only IE8+ is
     * supported (and all evergreen browsers of course) the control of the
     * display attribute works well.
     *
     * @param {integer} col      Column index
     * @param {boolean} showHide Show or hide (true or false)
     * @private
     */
    _setColumnVis: function(col, showHide) {
      var that = this;
      var dt = this.s.dt;
      var display = showHide ? "" : "none";
      this._setHeaderVis(col, showHide, dt.table().header.structure());
      this._setHeaderVis(col, showHide, dt.table().footer.structure());
      dt.column(col).nodes().to$().css("display", display).toggleClass("dtr-hidden", !showHide);
      if (!$13.isEmptyObject(this.s.childNodeStore)) {
        dt.cells(null, col).indexes().each(function(idx) {
          that._childNodesRestore(dt, idx.row, idx.column);
        });
      }
    },
    /**
     * Set the a column's visibility, taking into account multiple rows
     * in a header / footer and colspan attributes
     * @param {*} col
     * @param {*} showHide
     * @param {*} structure
     */
    _setHeaderVis: function(col, showHide, structure) {
      var that = this;
      var display = showHide ? "" : "none";
      structure.forEach(function(row) {
        if (row[col]) {
          $13(row[col].cell).css("display", display).toggleClass("dtr-hidden", !showHide);
        } else {
          var search = col;
          while (search >= 0) {
            if (row[search]) {
              row[search].cell.colSpan = that._colspan(row, search);
              break;
            }
            search--;
          }
        }
      });
    },
    /**
     * How many columns should this cell span
     *
     * @param {*} row Header structure row
     * @param {*} idx The column index of the cell to span
     */
    _colspan: function(row, idx) {
      var colspan = 1;
      for (var col = idx + 1; col < row.length; col++) {
        if (row[col] === null && this.s.current[col]) {
          colspan++;
        } else if (row[col]) {
          break;
        }
      }
      return colspan;
    },
    /**
     * Update the cell tab indexes for keyboard accessibility. This is called on
     * every table draw - that is potentially inefficient, but also the least
     * complex option given that column visibility can change on the fly. Its a
     * shame user-focus was removed from CSS 3 UI, as it would have solved this
     * issue with a single CSS statement.
     *
     * @private
     */
    _tabIndexes: function() {
      var dt = this.s.dt;
      var cells = dt.cells({ page: "current" }).nodes().to$();
      var ctx = dt.settings()[0];
      var target = this.c.details.target;
      cells.filter("[data-dtr-keyboard]").removeData("[data-dtr-keyboard]");
      if (typeof target === "number") {
        dt.cells(null, target, { page: "current" }).nodes().to$().attr("tabIndex", ctx.iTabIndex).data("dtr-keyboard", 1);
      } else {
        if (target === "td:first-child, th:first-child") {
          target = ">td:first-child, >th:first-child";
        }
        $13(target, dt.rows({ page: "current" }).nodes()).attr("tabIndex", ctx.iTabIndex).data("dtr-keyboard", 1);
      }
    }
  });
  Responsive.breakpoints = [
    { name: "desktop", width: Infinity },
    { name: "tablet-l", width: 1024 },
    { name: "tablet-p", width: 768 },
    { name: "mobile-l", width: 480 },
    { name: "mobile-p", width: 320 }
  ];
  Responsive.display = {
    childRow: function(row, update, render) {
      var rowNode = $13(row.node());
      if (update) {
        if (rowNode.hasClass("dtr-expanded")) {
          row.child(render(), "child").show();
          return true;
        }
      } else {
        if (!rowNode.hasClass("dtr-expanded")) {
          var rendered = render();
          if (rendered === false) {
            return false;
          }
          row.child(rendered, "child").show();
          return true;
        } else {
          row.child(false);
          return false;
        }
      }
    },
    childRowImmediate: function(row, update, render) {
      var rowNode = $13(row.node());
      if (!update && rowNode.hasClass("dtr-expanded") || !row.responsive.hasHidden()) {
        row.child(false);
        return false;
      } else {
        var rendered = render();
        if (rendered === false) {
          return false;
        }
        row.child(rendered, "child").show();
        return true;
      }
    },
    // This is a wrapper so the modal options for Bootstrap and jQuery UI can
    // have options passed into them. This specific one doesn't need to be a
    // function but it is for consistency in the `modal` name
    modal: function(options) {
      return function(row, update, render, closeCallback) {
        var modal2;
        var rendered = render();
        if (rendered === false) {
          return false;
        }
        if (!update) {
          var close = function() {
            modal2.remove();
            $13(document).off("keypress.dtr");
            $13(row.node()).removeClass("dtr-expanded");
            closeCallback();
          };
          modal2 = $13('<div class="dtr-modal"/>').append(
            $13('<div class="dtr-modal-display"/>').append(
              $13('<div class="dtr-modal-content"/>').data("dtr-row-idx", row.index()).append(rendered)
            ).append(
              $13(
                '<div class="dtr-modal-close">&times;</div>'
              ).click(function() {
                close();
              })
            )
          ).append(
            $13('<div class="dtr-modal-background"/>').click(
              function() {
                close();
              }
            )
          ).appendTo("body");
          $13(row.node()).addClass("dtr-expanded");
          $13(document).on("keyup.dtr", function(e) {
            if (e.keyCode === 27) {
              e.stopPropagation();
              close();
            }
          });
        } else {
          modal2 = $13("div.dtr-modal-content");
          if (modal2.length && row.index() === modal2.data("dtr-row-idx")) {
            modal2.empty().append(rendered);
          } else {
            return null;
          }
        }
        if (options && options.header) {
          $13("div.dtr-modal-content").prepend(
            "<h2>" + options.header(row) + "</h2>"
          );
        }
        return true;
      };
    }
  };
  Responsive.renderer = {
    listHiddenNodes: function() {
      var fn = function(api, rowIdx, columns) {
        var that = this;
        var ul = $13(
          '<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>'
        );
        var found = false;
        $13.each(columns, function(i, col) {
          if (col.hidden) {
            var klass = col.className ? 'class="' + col.className + '"' : "";
            $13(
              "<li " + klass + ' data-dtr-index="' + col.columnIndex + '" data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '"><span class="dtr-title">' + col.title + "</span> </li>"
            ).append(
              $13('<span class="dtr-data"/>').append(
                that._childNodes(
                  api,
                  col.rowIndex,
                  col.columnIndex
                )
              )
            ).appendTo(ul);
            found = true;
          }
        });
        return found ? ul : false;
      };
      fn._responsiveMovesNodes = true;
      return fn;
    },
    listHidden: function() {
      return function(api, rowIdx, columns) {
        var data = $13.map(columns, function(col) {
          var klass = col.className ? 'class="' + col.className + '"' : "";
          return col.hidden ? "<li " + klass + ' data-dtr-index="' + col.columnIndex + '" data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '"><span class="dtr-title">' + col.title + '</span> <span class="dtr-data">' + col.data + "</span></li>" : "";
        }).join("");
        return data ? $13(
          '<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>'
        ).append(data) : false;
      };
    },
    tableAll: function(options) {
      options = $13.extend(
        {
          tableClass: ""
        },
        options
      );
      return function(api, rowIdx, columns) {
        var data = $13.map(columns, function(col) {
          var klass = col.className ? 'class="' + col.className + '"' : "";
          return "<tr " + klass + ' data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '"><td>' + col.title + ":</td> <td>" + col.data + "</td></tr>";
        }).join("");
        return $13(
          '<table class="' + options.tableClass + ' dtr-details" width="100%"/>'
        ).append(data);
      };
    }
  };
  Responsive.defaults = {
    /**
     * List of breakpoints for the instance. Note that this means that each
     * instance can have its own breakpoints. Additionally, the breakpoints
     * cannot be changed once an instance has been creased.
     *
     * @type {Array}
     * @default Takes the value of `Responsive.breakpoints`
     */
    breakpoints: Responsive.breakpoints,
    /**
     * Enable / disable auto hiding calculations. It can help to increase
     * performance slightly if you disable this option, but all columns would
     * need to have breakpoint classes assigned to them
     *
     * @type {Boolean}
     * @default  `true`
     */
    auto: true,
    /**
     * Details control. If given as a string value, the `type` property of the
     * default object is set to that value, and the defaults used for the rest
     * of the object - this is for ease of implementation.
     *
     * The object consists of the following properties:
     *
     * * `display` - A function that is used to show and hide the hidden details
     * * `renderer` - function that is called for display of the child row data.
     *   The default function will show the data from the hidden columns
     * * `target` - Used as the selector for what objects to attach the child
     *   open / close to
     * * `type` - `false` to disable the details display, `inline` or `column`
     *   for the two control types
     *
     * @type {Object|string}
     */
    details: {
      display: Responsive.display.childRow,
      renderer: Responsive.renderer.listHidden(),
      target: 0,
      type: "inline"
    },
    /**
     * Orthogonal data request option. This is used to define the data type
     * requested when Responsive gets the data to show in the child row.
     *
     * @type {String}
     */
    orthogonal: "display"
  };
  var Api = $13.fn.dataTable.Api;
  Api.register("responsive()", function() {
    return this;
  });
  Api.register("responsive.index()", function(li) {
    li = $13(li);
    return {
      column: li.data("dtr-index"),
      row: li.parent().data("dtr-index")
    };
  });
  Api.register("responsive.rebuild()", function() {
    return this.iterator("table", function(ctx) {
      if (ctx._responsive) {
        ctx._responsive._classLogic();
      }
    });
  });
  Api.register("responsive.recalc()", function() {
    return this.iterator("table", function(ctx) {
      if (ctx._responsive) {
        ctx._responsive._resizeAuto();
        ctx._responsive._resize();
      }
    });
  });
  Api.register("responsive.hasHidden()", function() {
    var ctx = this.context[0];
    return ctx._responsive ? $13.inArray(false, ctx._responsive._responsiveOnlyHidden()) !== -1 : false;
  });
  Api.registerPlural(
    "columns().responsiveHidden()",
    "column().responsiveHidden()",
    function() {
      return this.iterator(
        "column",
        function(settings, column) {
          return settings._responsive ? settings._responsive._responsiveOnlyHidden()[column] : false;
        },
        1
      );
    }
  );
  Responsive.version = "3.0.3";
  $13.fn.dataTable.Responsive = Responsive;
  $13.fn.DataTable.Responsive = Responsive;
  $13(document).on("preInit.dt.dtr", function(e, settings, json) {
    if (e.namespace !== "dt") {
      return;
    }
    if ($13(settings.nTable).hasClass("responsive") || $13(settings.nTable).hasClass("dt-responsive") || settings.oInit.responsive || dataTables_default.defaults.responsive) {
      var init2 = settings.oInit.responsive;
      if (init2 !== false) {
        new Responsive(settings, $13.isPlainObject(init2) ? init2 : {});
      }
    }
  });

  // node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.mjs
  var $14 = import_jquery16.default;
  var _display = dataTables_bootstrap5_default.Responsive.display;
  var _original = _display.modal;
  var _modal = $14(
    '<div class="modal fade dtr-bs-modal" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div><div class="modal-body"/></div></div></div>'
  );
  var modal;
  var _bs = window.bootstrap;
  dataTables_bootstrap5_default.Responsive.bootstrap = function(bs) {
    _bs = bs;
  };
  _display.modal = function(options) {
    if (!modal && _bs.Modal) {
      modal = new _bs.Modal(_modal[0]);
    }
    return function(row, update, render, closeCallback) {
      if (!modal) {
        return _original(row, update, render, closeCallback);
      } else {
        var rendered = render();
        if (rendered === false) {
          return false;
        }
        if (!update) {
          if (options && options.header) {
            var header = _modal.find("div.modal-header");
            var button = header.find("button").detach();
            header.empty().append('<h4 class="modal-title">' + options.header(row) + "</h4>").append(button);
          }
          _modal.find("div.modal-body").empty().append(rendered);
          _modal.data("dtr-row-idx", row.index()).one("hidden.bs.modal", closeCallback).appendTo("body");
          modal.show();
        } else {
          if ($14.contains(document, _modal[0]) && row.index() === _modal.data("dtr-row-idx")) {
            _modal.find("div.modal-body").empty().append(rendered);
          } else {
            return null;
          }
        }
        return true;
      }
    };
  };

  // node_modules/datatables.net-rowgroup-bs5/js/rowGroup.bootstrap5.mjs
  var import_jquery21 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-rowgroup-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs
  var import_jquery18 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-rowgroup-bs5/node_modules/datatables.net-bs5/node_modules/datatables.net/js/dataTables.mjs
  var import_jquery17 = __toESM(require_jquery(), 1);
  var $15 = import_jquery17.default;
  var DataTable6 = function(selector, options) {
    if (DataTable6.factory(selector, options)) {
      return DataTable6;
    }
    if (this instanceof DataTable6) {
      return $15(selector).DataTable(options);
    } else {
      options = selector;
    }
    var _that = this;
    var emptyInit = options === void 0;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.api = function() {
      return new _Api6(this);
    };
    this.each(function() {
      var o = {};
      var oInit = len > 1 ? (
        // optimisation for single table case
        _fnExtend6(o, options, true)
      ) : options;
      var i = 0, iLen;
      var sId = this.getAttribute("id");
      var bInitHandedOff = false;
      var defaults = DataTable6.defaults;
      var $this = $15(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog6(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      $15(this).trigger("options.dt", oInit);
      _fnCompatOpts6(defaults);
      _fnCompatCols6(defaults.column);
      _fnCamelToHungarian6(defaults, defaults, true);
      _fnCamelToHungarian6(defaults.column, defaults.column, true);
      _fnCamelToHungarian6(defaults, $15.extend(oInit, $this.data()), true);
      var allSettings = DataTable6.settings;
      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            new DataTable6.Api(s).destroy();
            break;
          } else {
            _fnLog6(s, 0, "Cannot reinitialise DataTable", 3);
            return;
          }
        }
        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable6.ext._unique++;
        this.id = sId;
      }
      var oSettings = $15.extend(true, {}, DataTable6.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId,
        colgroup: $15("<colgroup>").prependTo(this),
        fastData: function(row, column, type) {
          return _fnGetCellData6(oSettings, row, column, type);
        }
      });
      oSettings.nTable = this;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.api = new _Api6(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts6(oInit);
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : $15.isPlainObject(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0].value : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend6($15.extend(true, {}, defaults), oInit);
      _fnMap6(oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ]);
      _fnMap6(oSettings, oInit, [
        "ajax",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "iStateDuration",
        "bSortCellsTop",
        "iTabIndex",
        "sDom",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        "caption",
        "layout",
        ["iCookieDuration", "iStateDuration"],
        // backwards compat
        ["oSearch", "oPreviousSearch"],
        ["aoSearchCols", "aoPreSearchCols"],
        ["iDisplayLength", "_iDisplayLength"]
      ]);
      _fnMap6(oSettings.oScroll, oInit, [
        ["sScrollX", "sX"],
        ["sScrollXInner", "sXInner"],
        ["sScrollY", "sY"],
        ["bScrollCollapse", "bCollapse"]
      ]);
      _fnMap6(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg6(oSettings, "aoDrawCallback", oInit.fnDrawCallback);
      _fnCallbackReg6(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams);
      _fnCallbackReg6(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams);
      _fnCallbackReg6(oSettings, "aoStateLoaded", oInit.fnStateLoaded);
      _fnCallbackReg6(oSettings, "aoRowCallback", oInit.fnRowCallback);
      _fnCallbackReg6(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow);
      _fnCallbackReg6(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback);
      _fnCallbackReg6(oSettings, "aoFooterCallback", oInit.fnFooterCallback);
      _fnCallbackReg6(oSettings, "aoInitComplete", oInit.fnInitComplete);
      _fnCallbackReg6(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback);
      oSettings.rowIdFn = _fnGetObjectDataFn6(oInit.rowId);
      _fnBrowserDetect6(oSettings);
      var oClasses = oSettings.oClasses;
      $15.extend(oClasses, DataTable6.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.table);
      if (!oSettings.oFeatures.bPaginate) {
        oInit.iDisplayStart = 0;
      }
      if (oSettings.iInitDisplayStart === void 0) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      var oLanguage = oSettings.oLanguage;
      $15.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl) {
        $15.ajax({
          dataType: "json",
          url: oLanguage.sUrl,
          success: function(json) {
            _fnCamelToHungarian6(defaults.oLanguage, json);
            $15.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
            _fnCallbackFire6(oSettings, null, "i18n", [oSettings], true);
            _fnInitialise6(oSettings);
          },
          error: function() {
            _fnLog6(oSettings, 0, "i18n file loading error", 21);
            _fnInitialise6(oSettings);
          }
        });
        bInitHandedOff = true;
      } else {
        _fnCallbackFire6(oSettings, null, "i18n", [oSettings]);
      }
      var columnsInit = [];
      var thead = this.getElementsByTagName("thead");
      var initHeaderLayout = _fnDetectHeader6(oSettings, thead[0]);
      if (oInit.aoColumns) {
        columnsInit = oInit.aoColumns;
      } else if (initHeaderLayout.length) {
        for (i = 0, iLen = initHeaderLayout[0].length; i < iLen; i++) {
          columnsInit.push(null);
        }
      }
      for (i = 0, iLen = columnsInit.length; i < iLen; i++) {
        _fnAddColumn6(oSettings);
      }
      _fnApplyColumnDefs6(oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function(iCol, oDef) {
        _fnColumnOptions6(oSettings, iCol, oDef);
      });
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if (rowOne.length) {
        var a = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $15(rowOne[0]).children("th, td").each(function(i2, cell) {
          var col = oSettings.aoColumns[i2];
          if (!col) {
            _fnLog6(oSettings, 0, "Incorrect column count", 18);
          }
          if (col.mData === i2) {
            var sort = a(cell, "sort") || a(cell, "order");
            var filter = a(cell, "filter") || a(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {
                _: i2 + ".display",
                sort: sort !== null ? i2 + ".@data-" + sort : void 0,
                type: sort !== null ? i2 + ".@data-" + sort : void 0,
                filter: filter !== null ? i2 + ".@data-" + filter : void 0
              };
              col._isArrayHost = true;
              _fnColumnOptions6(oSettings, i2);
            }
          }
        });
      }
      var features = oSettings.oFeatures;
      var loadedInit = function() {
        if (oInit.aaSorting === void 0) {
          var sorting = oSettings.aaSorting;
          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        _fnSortingClasses6(oSettings);
        _fnCallbackReg6(oSettings, "aoDrawCallback", function() {
          if (oSettings.bSorted || _fnDataSource6(oSettings) === "ssp" || features.bDeferRender) {
            _fnSortingClasses6(oSettings);
          }
        });
        var caption = $this.children("caption");
        if (oSettings.caption) {
          if (caption.length === 0) {
            caption = $15("<caption/>").appendTo($this);
          }
          caption.html(oSettings.caption);
        }
        if (caption.length) {
          caption[0]._captionSide = caption.css("caption-side");
          oSettings.captionNode = caption[0];
        }
        if (thead.length === 0) {
          thead = $15("<thead/>").appendTo($this);
        }
        oSettings.nTHead = thead[0];
        $15("tr", thead).addClass(oClasses.thead.row);
        var tbody = $this.children("tbody");
        if (tbody.length === 0) {
          tbody = $15("<tbody/>").insertAfter(thead);
        }
        oSettings.nTBody = tbody[0];
        var tfoot = $this.children("tfoot");
        if (tfoot.length === 0) {
          tfoot = $15("<tfoot/>").appendTo($this);
        }
        oSettings.nTFoot = tfoot[0];
        $15("tr", tfoot).addClass(oClasses.tfoot.row);
        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData6(oSettings, oInit.aaData[i]);
          }
        } else if (_fnDataSource6(oSettings) == "dom") {
          _fnAddTr6(oSettings, $15(oSettings.nTBody).children("tr"));
        }
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        oSettings.bInitialised = true;
        if (bInitHandedOff === false) {
          _fnInitialise6(oSettings);
        }
      };
      _fnCallbackReg6(oSettings, "aoDrawCallback", _fnSaveState6);
      if (oInit.bStateSave) {
        features.bStateSave = true;
        _fnLoadState6(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  DataTable6.ext = _ext6 = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",
    /**
     * Legacy so v1 plug-ins don't throw js errors on load
     */
    feature: [],
    /**
     * Feature plug-ins.
     * 
     * This is an object of callbacks which provide the features for DataTables
     * to be initialised via the `layout` option.
     */
    features: {},
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Automatic column class assignment
       */
      className: {},
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
      /**
       * Automatic renderer assignment
       */
      render: {},
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatibility only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable6.fnVersionCheck,
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable6.version
  };
  $15.extend(_ext6, {
    afnFiltering: _ext6.search,
    aTypes: _ext6.type.detect,
    ofnSearch: _ext6.type.search,
    oSort: _ext6.type.order,
    afnSortData: _ext6.order,
    aoFeatures: _ext6.feature,
    oStdClasses: _ext6.classes,
    oPagination: _ext6.pager
  });
  $15.extend(DataTable6.ext.classes, {
    container: "dt-container",
    empty: {
      row: "dt-empty"
    },
    info: {
      container: "dt-info"
    },
    length: {
      container: "dt-length",
      select: "dt-input"
    },
    order: {
      canAsc: "dt-orderable-asc",
      canDesc: "dt-orderable-desc",
      isAsc: "dt-ordering-asc",
      isDesc: "dt-ordering-desc",
      none: "dt-orderable-none",
      position: "sorting_"
    },
    processing: {
      container: "dt-processing"
    },
    scrolling: {
      body: "dt-scroll-body",
      container: "dt-scroll",
      footer: {
        self: "dt-scroll-foot",
        inner: "dt-scroll-footInner"
      },
      header: {
        self: "dt-scroll-head",
        inner: "dt-scroll-headInner"
      }
    },
    search: {
      container: "dt-search",
      input: "dt-input"
    },
    table: "dataTable",
    tbody: {
      cell: "",
      row: ""
    },
    thead: {
      cell: "",
      row: ""
    },
    tfoot: {
      cell: "",
      row: ""
    },
    paging: {
      active: "current",
      button: "dt-paging-button",
      container: "dt-paging",
      disabled: "disabled"
    }
  });
  var _ext6;
  var _Api6;
  var _api_register6;
  var _api_registerPlural6;
  var _re_dic6 = {};
  var _re_new_lines6 = /[\r\n\u2028]/g;
  var _re_html6 = /<([^>]*>)/g;
  var _max_str_len6 = Math.pow(2, 28);
  var _re_date6 = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;
  var _re_escape_regex6 = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric6 = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty6 = function(d) {
    return !d || d === true || d === "-" ? true : false;
  };
  var _intVal6 = function(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  var _numToDecimal6 = function(num, decimalPoint) {
    if (!_re_dic6[decimalPoint]) {
      _re_dic6[decimalPoint] = new RegExp(_fnEscapeRegex6(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic6[decimalPoint], ".") : num;
  };
  var _isNumber6 = function(d, decimalPoint, formatted) {
    var type = typeof d;
    var strType = type === "string";
    if (type === "number" || type === "bigint") {
      return true;
    }
    if (_empty6(d)) {
      return true;
    }
    if (decimalPoint && strType) {
      d = _numToDecimal6(d, decimalPoint);
    }
    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric6, "");
    }
    return !isNaN(parseFloat(d)) && isFinite(d);
  };
  var _isHtml6 = function(d) {
    return _empty6(d) || typeof d === "string";
  };
  var _htmlNumeric6 = function(d, decimalPoint, formatted) {
    if (_empty6(d)) {
      return true;
    }
    if (typeof d === "string" && d.match(/<(input|select)/i)) {
      return null;
    }
    var html = _isHtml6(d);
    return !html ? null : _isNumber6(_stripHtml6(d), decimalPoint, formatted) ? true : null;
  };
  var _pluck6 = function(a, prop, prop2) {
    var out = [];
    var i = 0, ien = a.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order6 = function(a, order, prop, prop2) {
    var out = [];
    var i = 0, ien = order.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[order[i]]) {
          out.push(a[order[i]][prop]);
        }
      }
    }
    return out;
  };
  var _range6 = function(len, start) {
    var out = [];
    var end;
    if (start === void 0) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }
    for (var i = start; i < end; i++) {
      out.push(i);
    }
    return out;
  };
  var _removeEmpty6 = function(a) {
    var out = [];
    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        out.push(a[i]);
      }
    }
    return out;
  };
  var _stripHtml6 = function(input) {
    if (input.length > _max_str_len6) {
      throw new Error("Exceeded max str len");
    }
    var previous;
    input = input.replace(_re_html6, "");
    do {
      previous = input;
      input = input.replace(/<script/i, "");
    } while (input !== previous);
    return previous;
  };
  var _escapeHtml6 = function(d) {
    if (Array.isArray(d)) {
      d = d.join(",");
    }
    return typeof d === "string" ? d.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d;
  };
  var _normalize6 = function(str, both) {
    if (typeof str !== "string") {
      return str;
    }
    var res = str.normalize("NFD");
    return res.length !== str.length ? (both === true ? str + " " : "") + res.replace(/[\u0300-\u036f]/g, "") : res;
  };
  var _areAllUnique6 = function(src) {
    if (src.length < 2) {
      return true;
    }
    var sorted = src.slice().sort();
    var last = sorted[0];
    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }
      last = sorted[i];
    }
    return true;
  };
  var _unique6 = function(src) {
    if (Array.from && Set) {
      return Array.from(new Set(src));
    }
    if (_areAllUnique6(src)) {
      return src.slice();
    }
    var out = [], val, i, ien = src.length, j, k = 0;
    again: for (i = 0; i < ien; i++) {
      val = src[i];
      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }
      out.push(val);
      k++;
    }
    return out;
  };
  var _flatten6 = function(out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten6(out, val[i]);
      }
    } else {
      out.push(val);
    }
    return out;
  };
  function _addClass6(el, name) {
    if (name) {
      name.split(" ").forEach(function(n) {
        if (n) {
          el.classList.add(n);
        }
      });
    }
  }
  DataTable6.util = {
    /**
     * Return a string with diacritic characters decomposed
     * @param {*} mixed Function or string to normalize
     * @param {*} both Return original string and the normalized string
     * @returns String or undefined
     */
    diacritics: function(mixed, both) {
      var type = typeof mixed;
      if (type !== "function") {
        return _normalize6(mixed, both);
      }
      _normalize6 = mixed;
    },
    /**
     * Debounce a function
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    debounce: function(fn, timeout) {
      var timer;
      return function() {
        var that = this;
        var args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(that, args);
        }, timeout || 250);
      };
    },
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function(fn, freq) {
      var frequency = freq !== void 0 ? freq : 200, last, timer;
      return function() {
        var that = this, now = +/* @__PURE__ */ new Date(), args = arguments;
        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            last = void 0;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },
    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function(val) {
      return val.replace(_re_escape_regex6, "\\$1");
    },
    /**
     * Create a function that will write to a nested object or array
     * @param {*} source JSON notation string
     * @returns Write function
     */
    set: function(source) {
      if ($15.isPlainObject(source)) {
        return DataTable6.util.set(source._);
      } else if (source === null) {
        return function() {
        };
      } else if (typeof source === "function") {
        return function(data, val, meta) {
          source(data, "set", val, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var setData = function(data, val, src) {
          var a = _fnSplitObjNotation6(src), b;
          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;
          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            if (a[i] === "__proto__" || a[i] === "constructor") {
              throw new Error("Cannot set prototype values");
            }
            arrayNotation = a[i].match(__reArray6);
            funcNotation = a[i].match(__reFn6);
            if (arrayNotation) {
              a[i] = a[i].replace(__reArray6, "");
              data[a[i]] = [];
              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join(".");
              if (Array.isArray(val)) {
                for (var j = 0, jLen = val.length; j < jLen; j++) {
                  o = {};
                  setData(o, val[j], innerSrc);
                  data[a[i]].push(o);
                }
              } else {
                data[a[i]] = val;
              }
              return;
            } else if (funcNotation) {
              a[i] = a[i].replace(__reFn6, "");
              data = data[a[i]](val);
            }
            if (data[a[i]] === null || data[a[i]] === void 0) {
              data[a[i]] = {};
            }
            data = data[a[i]];
          }
          if (aLast.match(__reFn6)) {
            data = data[aLast.replace(__reFn6, "")](val);
          } else {
            data[aLast.replace(__reArray6, "")] = val;
          }
        };
        return function(data, val) {
          return setData(data, val, source);
        };
      } else {
        return function(data, val) {
          data[source] = val;
        };
      }
    },
    /**
     * Create a function that will read nested objects from arrays, based on JSON notation
     * @param {*} source JSON notation string
     * @returns Value read
     */
    get: function(source) {
      if ($15.isPlainObject(source)) {
        var o = {};
        $15.each(source, function(key, val) {
          if (val) {
            o[key] = DataTable6.util.get(val);
          }
        });
        return function(data, type, row, meta) {
          var t = o[type] || o._;
          return t !== void 0 ? t(data, type, row, meta) : data;
        };
      } else if (source === null) {
        return function(data) {
          return data;
        };
      } else if (typeof source === "function") {
        return function(data, type, row, meta) {
          return source(data, type, row, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var fetchData = function(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== "") {
            var a = _fnSplitObjNotation6(src);
            for (var i = 0, iLen = a.length; i < iLen; i++) {
              arrayNotation = a[i].match(__reArray6);
              funcNotation = a[i].match(__reFn6);
              if (arrayNotation) {
                a[i] = a[i].replace(__reArray6, "");
                if (a[i] !== "") {
                  data = data[a[i]];
                }
                out = [];
                a.splice(0, i + 1);
                innerSrc = a.join(".");
                if (Array.isArray(data)) {
                  for (var j = 0, jLen = data.length; j < jLen; j++) {
                    out.push(fetchData(data[j], type, innerSrc));
                  }
                }
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join);
                break;
              } else if (funcNotation) {
                a[i] = a[i].replace(__reFn6, "");
                data = data[a[i]]();
                continue;
              }
              if (data === null || data[a[i]] === null) {
                return null;
              } else if (data === void 0 || data[a[i]] === void 0) {
                return void 0;
              }
              data = data[a[i]];
            }
          }
          return data;
        };
        return function(data, type) {
          return fetchData(data, type, source);
        };
      } else {
        return function(data) {
          return data[source];
        };
      }
    },
    stripHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _stripHtml6 = mixed;
        return;
      } else if (type === "string") {
        return _stripHtml6(mixed);
      }
      return mixed;
    },
    escapeHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _escapeHtml6 = mixed;
        return;
      } else if (type === "string" || Array.isArray(mixed)) {
        return _escapeHtml6(mixed);
      }
      return mixed;
    },
    unique: _unique6
  };
  function _fnHungarianMap6(o) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map2 = {};
    $15.each(o, function(key) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map2[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap6(o[key]);
        }
      }
    });
    o._hungarianMap = map2;
  }
  function _fnCamelToHungarian6(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap6(src);
    }
    var hungarianKey;
    $15.each(user, function(key) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $15.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian6(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  var _fnCompatMap6 = function(o, knew, old) {
    if (o[knew] !== void 0) {
      o[old] = o[knew];
    }
  };
  function _fnCompatOpts6(init2) {
    _fnCompatMap6(init2, "ordering", "bSort");
    _fnCompatMap6(init2, "orderMulti", "bSortMulti");
    _fnCompatMap6(init2, "orderClasses", "bSortClasses");
    _fnCompatMap6(init2, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap6(init2, "order", "aaSorting");
    _fnCompatMap6(init2, "orderFixed", "aaSortingFixed");
    _fnCompatMap6(init2, "paging", "bPaginate");
    _fnCompatMap6(init2, "pagingType", "sPaginationType");
    _fnCompatMap6(init2, "pageLength", "iDisplayLength");
    _fnCompatMap6(init2, "searching", "bFilter");
    if (typeof init2.sScrollX === "boolean") {
      init2.sScrollX = init2.sScrollX ? "100%" : "";
    }
    if (typeof init2.scrollX === "boolean") {
      init2.scrollX = init2.scrollX ? "100%" : "";
    }
    var searchCols = init2.aoSearchCols;
    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian6(DataTable6.models.oSearch, searchCols[i]);
        }
      }
    }
    if (init2.serverSide && !init2.searchDelay) {
      init2.searchDelay = 400;
    }
  }
  function _fnCompatCols6(init2) {
    _fnCompatMap6(init2, "orderable", "bSortable");
    _fnCompatMap6(init2, "orderData", "aDataSort");
    _fnCompatMap6(init2, "orderSequence", "asSorting");
    _fnCompatMap6(init2, "orderDataType", "sortDataType");
    var dataSort = init2.aDataSort;
    if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
      init2.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect6(settings) {
    if (!DataTable6.__browser) {
      var browser = {};
      DataTable6.__browser = browser;
      var n = $15("<div/>").css({
        position: "fixed",
        top: 0,
        left: -1 * window.pageXOffset,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(
        $15("<div/>").css({
          position: "absolute",
          top: 1,
          left: 1,
          width: 100,
          overflow: "scroll"
        }).append(
          $15("<div/>").css({
            width: "100%",
            height: 10
          })
        )
      ).appendTo("body");
      var outer = n.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      n.remove();
    }
    $15.extend(settings.oBrowser, DataTable6.__browser);
    settings.oScroll.iBarWidth = DataTable6.__browser.barWidth;
  }
  function _fnAddColumn6(oSettings) {
    var oDefaults = DataTable6.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $15.extend({}, DataTable6.models.oColumn, oDefaults, {
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol,
      searchFixed: {},
      colEl: $15("<col>").attr("data-dt-column", iCol)
    });
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $15.extend({}, DataTable6.models.oSearch, searchCols[iCol]);
  }
  function _fnColumnOptions6(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    if (oOptions !== void 0 && oOptions !== null) {
      _fnCompatCols6(oOptions);
      _fnCamelToHungarian6(DataTable6.defaults.column, oOptions, true);
      if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      var origClass = oCol.sClass;
      $15.extend(oCol, oOptions);
      _fnMap6(oCol, oOptions, "sWidth", "sWidthOrig");
      if (origClass !== oCol.sClass) {
        oCol.sClass = origClass + " " + oCol.sClass;
      }
      if (oOptions.iDataSort !== void 0) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap6(oCol, oOptions, "aDataSort");
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn6(mDataSrc);
    if (oCol.mRender && Array.isArray(oCol.mRender)) {
      var copy = oCol.mRender.slice();
      var name = copy.shift();
      oCol.mRender = DataTable6.render[name].apply(window, copy);
    }
    oCol._render = oCol.mRender ? _fnGetObjectDataFn6(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $15.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, void 0, meta);
      return oCol._render && type ? oCol._render(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn6(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
    }
  }
  function _fnAdjustColumnSizing6(settings) {
    _fnCalculateColumnWidths6(settings);
    _fnColumnSizes6(settings);
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw6(settings);
    }
    _fnCallbackFire6(settings, null, "column-sizing", [settings]);
  }
  function _fnColumnSizes6(settings) {
    var cols = settings.aoColumns;
    for (var i = 0; i < cols.length; i++) {
      var width = _fnColumnsSumWidth6(settings, [i], false, false);
      cols[i].colEl.css("width", width);
    }
  }
  function _fnVisibleToColumnIndex6(oSettings, iMatch) {
    var aiVis = _fnGetColumns6(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible6(oSettings, iMatch) {
    var aiVis = _fnGetColumns6(oSettings, "bVisible");
    var iPos = aiVis.indexOf(iMatch);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns6(settings) {
    var layout = settings.aoHeader;
    var columns = settings.aoColumns;
    var vis = 0;
    if (layout.length) {
      for (var i = 0, ien = layout[0].length; i < ien; i++) {
        if (columns[i].bVisible && $15(layout[0][i].cell).css("display") !== "none") {
          vis++;
        }
      }
    }
    return vis;
  }
  function _fnGetColumns6(oSettings, sParam) {
    var a = [];
    oSettings.aoColumns.map(function(val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  function _fnColumnTypes6(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable6.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, detectedType, cache;
    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            if (!data[k]) {
              continue;
            }
            if (cache[k] === void 0) {
              cache[k] = _fnGetCellData6(settings, k, i, "type");
            }
            detectedType = types[j](cache[k], settings);
            if (!detectedType && j !== types.length - 2) {
              break;
            }
            if (detectedType === "html" && !_empty6(cache[k])) {
              break;
            }
          }
          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        if (!col.sType) {
          col.sType = "string";
        }
      }
      var autoClass = _ext6.type.className[col.sType];
      if (autoClass) {
        _columnAutoClass6(settings.aoHeader, i, autoClass);
        _columnAutoClass6(settings.aoFooter, i, autoClass);
      }
      var renderer = _ext6.type.render[col.sType];
      if (renderer && !col._render) {
        col._render = DataTable6.util.get(renderer);
        _columnAutoRender6(settings, i);
      }
    }
  }
  function _columnAutoRender6(settings, colIdx) {
    var data = settings.aoData;
    for (var i = 0; i < data.length; i++) {
      if (data[i].nTr) {
        var display = _fnGetCellData6(settings, i, colIdx, "display");
        data[i].displayData[colIdx] = display;
        _fnWriteCell6(data[i].anCells[colIdx], display);
      }
    }
  }
  function _columnAutoClass6(container, colIdx, className) {
    container.forEach(function(row) {
      if (row[colIdx] && row[colIdx].unique) {
        _addClass6(row[colIdx].cell, className);
      }
    });
  }
  function _fnApplyColumnDefs6(oSettings, aoColDefs, aoCols, headerLayout, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        if (aoCols[i] && aoCols[i].name) {
          columns[i].sName = aoCols[i].name;
        }
      }
    }
    if (aoColDefs) {
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        var aTargets = def.target !== void 0 ? def.target : def.targets !== void 0 ? def.targets : def.aTargets;
        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          var target = aTargets[j];
          if (typeof target === "number" && target >= 0) {
            while (columns.length <= target) {
              _fnAddColumn6(oSettings);
            }
            fn(target, def);
          } else if (typeof target === "number" && target < 0) {
            fn(columns.length + target, def);
          } else if (typeof target === "string") {
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (target === "_all") {
                fn(k, def);
              } else if (target.indexOf(":name") !== -1) {
                if (columns[k].sName === target.replace(":name", "")) {
                  fn(k, def);
                }
              } else {
                headerLayout.forEach(function(row) {
                  if (row[k]) {
                    var cell = $15(row[k].cell);
                    if (target.match(/^[a-z][\w-]*$/i)) {
                      target = "." + target;
                    }
                    if (cell.is(target)) {
                      fn(k, def);
                    }
                  }
                });
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  function _fnColumnsSumWidth6(settings, targets, original, incVisible) {
    if (!Array.isArray(targets)) {
      targets = _fnColumnsFromHeader6(targets);
    }
    var sum = 0;
    var unit;
    var columns = settings.aoColumns;
    for (var i = 0, ien = targets.length; i < ien; i++) {
      var column = columns[targets[i]];
      var definedWidth = original ? column.sWidthOrig : column.sWidth;
      if (!incVisible && column.bVisible === false) {
        continue;
      }
      if (definedWidth === null || definedWidth === void 0) {
        return null;
      } else if (typeof definedWidth === "number") {
        unit = "px";
        sum += definedWidth;
      } else {
        var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);
        if (matched) {
          sum += matched[1] * 1;
          unit = matched.length === 3 ? matched[2] : "px";
        }
      }
    }
    return sum + unit;
  }
  function _fnColumnsFromHeader6(cell) {
    var attr = $15(cell).closest("[data-dt-column]").attr("data-dt-column");
    if (!attr) {
      return [];
    }
    return attr.split(",").map(function(val) {
      return val * 1;
    });
  }
  function _fnAddData6(settings, dataIn, tr, tds) {
    var rowIdx = settings.aoData.length;
    var rowModel = $15.extend(true, {}, DataTable6.models.oRow, {
      src: tr ? "dom" : "data",
      idx: rowIdx
    });
    rowModel._aData = dataIn;
    settings.aoData.push(rowModel);
    var columns = settings.aoColumns;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    settings.aiDisplayMaster.push(rowIdx);
    var id = settings.rowIdFn(dataIn);
    if (id !== void 0) {
      settings.aIds[id] = rowModel;
    }
    if (tr || !settings.oFeatures.bDeferRender) {
      _fnCreateTr6(settings, rowIdx, tr, tds);
    }
    return rowIdx;
  }
  function _fnAddTr6(settings, trs) {
    var row;
    if (!(trs instanceof $15)) {
      trs = $15(trs);
    }
    return trs.map(function(i, el) {
      row = _fnGetRowElements6(settings, el);
      return _fnAddData6(settings, row.data, el, row.cells);
    });
  }
  function _fnGetCellData6(settings, rowIdx, colIdx, type) {
    if (type === "search") {
      type = "filter";
    } else if (type === "order") {
      type = "sort";
    }
    var row = settings.aoData[rowIdx];
    if (!row) {
      return void 0;
    }
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = row._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings,
      row: rowIdx,
      col: colIdx
    });
    if (type !== "display" && cellData && typeof cellData === "object" && cellData.nodeName) {
      cellData = cellData.innerHTML;
    }
    if (cellData === void 0) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog6(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
      cellData = defaultContent;
    } else if (typeof cellData === "function") {
      return cellData.call(rowData);
    }
    if (cellData === null && type === "display") {
      return "";
    }
    if (type === "filter") {
      var fomatters = DataTable6.ext.type.search;
      if (fomatters[col.sType]) {
        cellData = fomatters[col.sType](cellData);
      }
    }
    return cellData;
  }
  function _fnSetCellData6(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings,
      row: rowIdx,
      col: colIdx
    });
  }
  function _fnWriteCell6(td, val) {
    if (val && typeof val === "object" && val.nodeName) {
      $15(td).empty().append(val);
    } else {
      td.innerHTML = val;
    }
  }
  var __reArray6 = /\[.*?\]$/;
  var __reFn6 = /\(\)$/;
  function _fnSplitObjNotation6(str) {
    var parts = str.match(/(\\.|[^.])+/g) || [""];
    return parts.map(function(s) {
      return s.replace(/\\\./g, ".");
    });
  }
  var _fnGetObjectDataFn6 = DataTable6.util.get;
  var _fnSetObjectDataFn6 = DataTable6.util.set;
  function _fnGetDataMaster6(settings) {
    return _pluck6(settings.aoData, "_aData");
  }
  function _fnClearTable6(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnInvalidate6(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;
    row._aSortData = null;
    row._aFilterData = null;
    row.displayData = null;
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements6(
        settings,
        row,
        colIdx,
        colIdx === void 0 ? void 0 : row._aData
      ).data;
    } else {
      var cells = row.anCells;
      var display = _fnGetRowDisplay6(settings, rowIdx);
      if (cells) {
        if (colIdx !== void 0) {
          _fnWriteCell6(cells[colIdx], display[colIdx]);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            _fnWriteCell6(cells[i], display[i]);
          }
        }
      }
    }
    var cols = settings.aoColumns;
    if (colIdx !== void 0) {
      cols[colIdx].sType = null;
      cols[colIdx].maxLenString = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
        cols[i].maxLenString = null;
      }
      _fnRowAttributes6(settings, row);
    }
  }
  function _fnGetRowElements6(settings, row, colIdx, d) {
    var tds = [], td = row.firstChild, name, col, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d = d !== void 0 ? d : objectRead ? {} : [];
    var attr = function(str, td2) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr2 = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn6(str);
          setter(d, td2.getAttribute(attr2));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === void 0 || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn6(col.mData._);
          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn6(col.mData);
            }
            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }
      i++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn6(settings.rowId)(d, id);
      }
    }
    return {
      data: d,
      cells: tds
    };
  }
  function _fnGetRowDisplay6(settings, rowIdx) {
    let rowModal = settings.aoData[rowIdx];
    let columns = settings.aoColumns;
    if (!rowModal.displayData) {
      rowModal.displayData = [];
      for (var colIdx = 0, len = columns.length; colIdx < len; colIdx++) {
        rowModal.displayData.push(
          _fnGetCellData6(settings, rowIdx, colIdx, "display")
        );
      }
    }
    return rowModal.displayData;
  }
  function _fnCreateTr6(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create, trClass = oSettings.oClasses.tbody.row;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      _addClass6(nTr, trClass);
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes6(oSettings, row);
      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn && anTds[i] ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        if (!nTd) {
          _fnLog6(oSettings, 0, "Incorrect column count", 18);
        }
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd);
        var display = _fnGetRowDisplay6(oSettings, iRow);
        if (create || (oCol.mRender || oCol.mData !== i) && (!$15.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
          _fnWriteCell6(nTd, display[i]);
        }
        if (oCol.bVisible && create) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && !create) {
          nTd.parentNode.removeChild(nTd);
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(
            oSettings.oInstance,
            nTd,
            _fnGetCellData6(oSettings, iRow, i),
            rowData,
            iRow,
            i
          );
        }
      }
      _fnCallbackFire6(oSettings, "aoRowCreatedCallback", "row-created", [nTr, rowData, iRow, cells]);
    } else {
      _addClass6(row.nTr, trClass);
    }
  }
  function _fnRowAttributes6(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique6(row.__rowc.concat(a)) : a;
        $15(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $15(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $15(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead6(settings, side) {
    var classes = settings.oClasses;
    var columns = settings.aoColumns;
    var i, ien, row;
    var target = side === "header" ? settings.nTHead : settings.nTFoot;
    var titleProp = side === "header" ? "sTitle" : side;
    if (!target) {
      return;
    }
    if (side === "header" || _pluck6(settings.aoColumns, titleProp).join("")) {
      row = $15("tr", target);
      if (!row.length) {
        row = $15("<tr/>").appendTo(target);
      }
      if (row.length === 1) {
        var cells = $15("td, th", row);
        for (i = cells.length, ien = columns.length; i < ien; i++) {
          $15("<th/>").html(columns[i][titleProp] || "").appendTo(row);
        }
      }
    }
    var detected = _fnDetectHeader6(settings, target, true);
    if (side === "header") {
      settings.aoHeader = detected;
    } else {
      settings.aoFooter = detected;
    }
    $15(target).children("tr").attr("role", "row");
    $15(target).children("tr").children("th, td").each(function() {
      _fnRenderer6(settings, side)(
        settings,
        $15(this),
        classes
      );
    });
  }
  function _fnHeaderLayout6(settings, source, incColumns) {
    var row, column, cell;
    var local = [];
    var structure = [];
    var columns = settings.aoColumns;
    var columnCount = columns.length;
    var rowspan, colspan;
    if (!source) {
      return;
    }
    if (!incColumns) {
      incColumns = _range6(columnCount).filter(function(idx) {
        return columns[idx].bVisible;
      });
    }
    for (row = 0; row < source.length; row++) {
      local[row] = source[row].slice().filter(function(cell2, i) {
        return incColumns.includes(i);
      });
      structure.push([]);
    }
    for (row = 0; row < local.length; row++) {
      for (column = 0; column < local[row].length; column++) {
        rowspan = 1;
        colspan = 1;
        if (structure[row][column] === void 0) {
          cell = local[row][column].cell;
          while (local[row + rowspan] !== void 0 && local[row][column].cell == local[row + rowspan][column].cell) {
            structure[row + rowspan][column] = null;
            rowspan++;
          }
          while (local[row][column + colspan] !== void 0 && local[row][column].cell == local[row][column + colspan].cell) {
            for (var k = 0; k < rowspan; k++) {
              structure[row + k][column + colspan] = null;
            }
            colspan++;
          }
          var titleSpan = $15("span.dt-column-title", cell);
          structure[row][column] = {
            cell,
            colspan,
            rowspan,
            title: titleSpan.length ? titleSpan.html() : $15(cell).html()
          };
        }
      }
    }
    return structure;
  }
  function _fnDrawHead6(settings, source) {
    var layout = _fnHeaderLayout6(settings, source);
    var tr, n;
    for (var row = 0; row < source.length; row++) {
      tr = source[row].row;
      if (tr) {
        while (n = tr.firstChild) {
          tr.removeChild(n);
        }
      }
      for (var column = 0; column < layout[row].length; column++) {
        var point = layout[row][column];
        if (point) {
          $15(point.cell).appendTo(tr).attr("rowspan", point.rowspan).attr("colspan", point.colspan);
        }
      }
    }
  }
  function _fnDraw6(oSettings, ajaxComplete) {
    _fnStart6(oSettings);
    var aPreDraw = _fnCallbackFire6(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if (aPreDraw.indexOf(false) !== -1) {
      _fnProcessingDisplay6(oSettings, false);
      return;
    }
    var anRows = [];
    var iRowCount = 0;
    var bServerSide = _fnDataSource6(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    var columns = oSettings.aoColumns;
    var body = $15(oSettings.nTBody);
    oSettings.bDrawing = true;
    if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !ajaxComplete) {
      if (oSettings.iDraw === 0) {
        body.empty().append(_emptyRow6(oSettings));
      }
      _fnAjaxUpdate6(oSettings);
      return;
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr6(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        for (var i = 0; i < columns.length; i++) {
          var col = columns[i];
          var td = aoData.anCells[i];
          _addClass6(td, _ext6.type.className[col.sType]);
          _addClass6(td, col.sClass);
          _addClass6(td, oSettings.oClasses.tbody.cell);
        }
        _fnCallbackFire6(
          oSettings,
          "aoRowCallback",
          null,
          [nRow, aoData._aData, iRowCount, j, iDataIndex]
        );
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      anRows[0] = _emptyRow6(oSettings);
    }
    _fnCallbackFire6(oSettings, "aoHeaderCallback", "header", [
      $15(oSettings.nTHead).children("tr")[0],
      _fnGetDataMaster6(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    _fnCallbackFire6(oSettings, "aoFooterCallback", "footer", [
      $15(oSettings.nTFoot).children("tr")[0],
      _fnGetDataMaster6(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    if (body[0].replaceChildren) {
      body[0].replaceChildren.apply(body[0], anRows);
    } else {
      body.children().detach();
      body.append($15(anRows));
    }
    $15(oSettings.nTableWrapper).toggleClass("dt-empty-footer", $15("tr", oSettings.nTFoot).length === 0);
    _fnCallbackFire6(oSettings, "aoDrawCallback", "draw", [oSettings], true);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw6(settings, holdPosition, recompute) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (recompute === void 0 || recompute === true) {
      if (sort) {
        _fnSort6(settings);
      }
      if (filter) {
        _fnFilterComplete6(settings, settings.oPreviousSearch);
      } else {
        settings.aiDisplay = settings.aiDisplayMaster.slice();
      }
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw6(settings);
    settings._drawHold = false;
  }
  function _emptyRow6(settings) {
    var oLang = settings.oLanguage;
    var zero = oLang.sZeroRecords;
    var dataSrc = _fnDataSource6(settings);
    if (settings.iDraw < 1 && dataSrc === "ssp" || settings.iDraw <= 1 && dataSrc === "ajax") {
      zero = oLang.sLoadingRecords;
    } else if (oLang.sEmptyTable && settings.fnRecordsTotal() === 0) {
      zero = oLang.sEmptyTable;
    }
    return $15("<tr/>").append($15("<td />", {
      "colSpan": _fnVisbleColumns6(settings),
      "class": settings.oClasses.empty.row
    }).html(zero))[0];
  }
  function _layoutArray6(settings, layout, side) {
    var groups = {};
    $15.each(layout, function(pos, val) {
      if (val === null) {
        return;
      }
      var splitPos = pos.replace(/([A-Z])/g, " $1").split(" ");
      if (!groups[splitPos[0]]) {
        groups[splitPos[0]] = {};
      }
      var align = splitPos.length === 1 ? "full" : splitPos[1].toLowerCase();
      var group = groups[splitPos[0]];
      var groupRun = function(contents, innerVal) {
        if ($15.isPlainObject(innerVal)) {
          Object.keys(innerVal).map(function(key) {
            contents.push({
              feature: key,
              opts: innerVal[key]
            });
          });
        } else {
          contents.push(innerVal);
        }
      };
      if (!group[align] || !group[align].contents) {
        group[align] = { contents: [] };
      }
      if (Array.isArray(val)) {
        for (var i2 = 0; i2 < val.length; i2++) {
          groupRun(group[align].contents, val[i2]);
        }
      } else {
        groupRun(group[align].contents, val);
      }
      if (!Array.isArray(group[align].contents)) {
        group[align].contents = [group[align].contents];
      }
    });
    var filtered = Object.keys(groups).map(function(pos) {
      if (pos.indexOf(side) !== 0) {
        return null;
      }
      return {
        name: pos,
        val: groups[pos]
      };
    }).filter(function(item) {
      return item !== null;
    });
    filtered.sort(function(a, b) {
      var order1 = a.name.replace(/[^0-9]/g, "") * 1;
      var order2 = b.name.replace(/[^0-9]/g, "") * 1;
      return order2 - order1;
    });
    if (side === "bottom") {
      filtered.reverse();
    }
    var rows = [];
    for (var i = 0, ien = filtered.length; i < ien; i++) {
      if (filtered[i].val.full) {
        rows.push({ full: filtered[i].val.full });
        _layoutResolve6(settings, rows[rows.length - 1]);
        delete filtered[i].val.full;
      }
      if (Object.keys(filtered[i].val).length) {
        rows.push(filtered[i].val);
        _layoutResolve6(settings, rows[rows.length - 1]);
      }
    }
    return rows;
  }
  function _layoutResolve6(settings, row) {
    var getFeature = function(feature, opts) {
      if (!_ext6.features[feature]) {
        _fnLog6(settings, 0, "Unknown feature: " + feature);
      }
      return _ext6.features[feature].apply(this, [settings, opts]);
    };
    var resolve = function(item) {
      var line = row[item].contents;
      for (var i = 0, ien = line.length; i < ien; i++) {
        if (!line[i]) {
          continue;
        } else if (typeof line[i] === "string") {
          line[i] = getFeature(line[i], null);
        } else if ($15.isPlainObject(line[i])) {
          line[i] = getFeature(line[i].feature, line[i].opts);
        } else if (typeof line[i].node === "function") {
          line[i] = line[i].node(settings);
        } else if (typeof line[i] === "function") {
          var inst = line[i](settings);
          line[i] = typeof inst.node === "function" ? inst.node() : inst;
        }
      }
    };
    $15.each(row, function(key) {
      resolve(key);
    });
  }
  function _fnAddOptionsHtml6(settings) {
    var classes = settings.oClasses;
    var table = $15(settings.nTable);
    var insert = $15("<div/>").attr({
      id: settings.sTableId + "_wrapper",
      "class": classes.container
    }).insertBefore(table);
    settings.nTableWrapper = insert[0];
    if (settings.sDom) {
      _fnLayoutDom6(settings, settings.sDom, insert);
    } else {
      var top = _layoutArray6(settings, settings.layout, "top");
      var bottom = _layoutArray6(settings, settings.layout, "bottom");
      var renderer = _fnRenderer6(settings, "layout");
      top.forEach(function(item) {
        renderer(settings, insert, item);
      });
      renderer(settings, insert, {
        full: {
          table: true,
          contents: [_fnFeatureHtmlTable6(settings)]
        }
      });
      bottom.forEach(function(item) {
        renderer(settings, insert, item);
      });
    }
    _processingHtml6(settings);
  }
  function _fnLayoutDom6(settings, dom, insert) {
    var parts = dom.match(/(".*?")|('.*?')|./g);
    var featureNode, option, newNode, next, attr;
    for (var i = 0; i < parts.length; i++) {
      featureNode = null;
      option = parts[i];
      if (option == "<") {
        newNode = $15("<div/>");
        next = parts[i + 1];
        if (next[0] == "'" || next[0] == '"') {
          attr = next.replace(/['"]/g, "");
          var id = "", className;
          if (attr.indexOf(".") != -1) {
            var split = attr.split(".");
            id = split[0];
            className = split[1];
          } else if (attr[0] == "#") {
            id = attr;
          } else {
            className = attr;
          }
          newNode.attr("id", id.substring(1)).addClass(className);
          i++;
        }
        insert.append(newNode);
        insert = newNode;
      } else if (option == ">") {
        insert = insert.parent();
      } else if (option == "t") {
        featureNode = _fnFeatureHtmlTable6(settings);
      } else {
        DataTable6.ext.feature.forEach(function(feature) {
          if (option == feature.cFeature) {
            featureNode = feature.fnInit(settings);
          }
        });
      }
      if (featureNode) {
        insert.append(featureNode);
      }
    }
  }
  function _fnDetectHeader6(settings, thead, write) {
    var columns = settings.aoColumns;
    var rows = $15(thead).children("tr");
    var row, cell;
    var i, k, l, iLen, shifted, column, colspan, rowspan;
    var isHeader = thead && thead.nodeName.toLowerCase() === "thead";
    var layout = [];
    var unique;
    var shift = function(a, i2, j) {
      var k2 = a[i2];
      while (k2[j]) {
        j++;
      }
      return j;
    };
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      layout.push([]);
    }
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      row = rows[i];
      column = 0;
      cell = row.firstChild;
      while (cell) {
        if (cell.nodeName.toUpperCase() == "TD" || cell.nodeName.toUpperCase() == "TH") {
          var cols = [];
          colspan = cell.getAttribute("colspan") * 1;
          rowspan = cell.getAttribute("rowspan") * 1;
          colspan = !colspan || colspan === 0 || colspan === 1 ? 1 : colspan;
          rowspan = !rowspan || rowspan === 0 || rowspan === 1 ? 1 : rowspan;
          shifted = shift(layout, i, column);
          unique = colspan === 1 ? true : false;
          if (write) {
            if (unique) {
              _fnColumnOptions6(settings, shifted, $15(cell).data());
              var columnDef = columns[shifted];
              var width = cell.getAttribute("width") || null;
              var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
              if (t) {
                width = t[1];
              }
              columnDef.sWidthOrig = columnDef.sWidth || width;
              if (isHeader) {
                if (columnDef.sTitle !== null && !columnDef.autoTitle) {
                  cell.innerHTML = columnDef.sTitle;
                }
                if (!columnDef.sTitle && unique) {
                  columnDef.sTitle = _stripHtml6(cell.innerHTML);
                  columnDef.autoTitle = true;
                }
              } else {
                if (columnDef.footer) {
                  cell.innerHTML = columnDef.footer;
                }
              }
              if (!columnDef.ariaTitle) {
                columnDef.ariaTitle = $15(cell).attr("aria-label") || columnDef.sTitle;
              }
              if (columnDef.className) {
                $15(cell).addClass(columnDef.className);
              }
            }
            if ($15("span.dt-column-title", cell).length === 0) {
              $15("<span>").addClass("dt-column-title").append(cell.childNodes).appendTo(cell);
            }
            if (isHeader && $15("span.dt-column-order", cell).length === 0) {
              $15("<span>").addClass("dt-column-order").appendTo(cell);
            }
          }
          for (l = 0; l < colspan; l++) {
            for (k = 0; k < rowspan; k++) {
              layout[i + k][shifted + l] = {
                cell,
                unique
              };
              layout[i + k].row = row;
            }
            cols.push(shifted + l);
          }
          cell.setAttribute("data-dt-column", _unique6(cols).join(","));
        }
        cell = cell.nextSibling;
      }
    }
    return layout;
  }
  function _fnStart6(oSettings) {
    var bServerSide = _fnDataSource6(oSettings) == "ssp";
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
  }
  function _fnBuildAjax6(oSettings, data, fn) {
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
      if (json === null || typeof status === "number" && status == 204) {
        json = {};
        _fnAjaxDataSrc6(oSettings, json, []);
      }
      var error = json.error || json.sError;
      if (error) {
        _fnLog6(oSettings, 0, error);
      }
      oSettings.json = json;
      _fnCallbackFire6(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR], true);
      fn(json);
    };
    if ($15.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === "function" ? ajaxData(data, oSettings) : (
        // fn can manipulate data or return
        ajaxData
      );
      data = typeof ajaxData === "function" && newData ? newData : $15.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {
      "url": typeof ajax === "string" ? ajax : "",
      "data": data,
      "success": callback,
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function(xhr, error) {
        var ret = _fnCallbackFire6(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR], true);
        if (ret.indexOf(true) === -1) {
          if (error == "parsererror") {
            _fnLog6(oSettings, 0, "Invalid JSON response", 1);
          } else if (xhr.readyState === 4) {
            _fnLog6(oSettings, 0, "Ajax error", 7);
          }
        }
        _fnProcessingDisplay6(oSettings, false);
      }
    };
    if ($15.isPlainObject(ajax)) {
      $15.extend(baseAjax, ajax);
    }
    oSettings.oAjaxData = data;
    _fnCallbackFire6(oSettings, null, "preXhr", [oSettings, data, baseAjax], true);
    if (typeof ajax === "function") {
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else if (ajax.url === "") {
      var empty = {};
      DataTable6.util.set(ajax.dataSrc)(empty, []);
      callback(empty);
    } else {
      oSettings.jqXHR = $15.ajax(baseAjax);
      if (ajaxData) {
        ajax.data = ajaxData;
      }
    }
  }
  function _fnAjaxUpdate6(settings) {
    settings.iDraw++;
    _fnProcessingDisplay6(settings, true);
    _fnBuildAjax6(
      settings,
      _fnAjaxParameters6(settings),
      function(json) {
        _fnAjaxUpdateDraw6(settings, json);
      }
    );
  }
  function _fnAjaxParameters6(settings) {
    var columns = settings.aoColumns, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, colData = function(idx, prop) {
      return typeof columns[idx][prop] === "function" ? "function" : columns[idx][prop];
    };
    return {
      draw: settings.iDraw,
      columns: columns.map(function(column, i) {
        return {
          data: colData(i, "mData"),
          name: column.sName,
          searchable: column.bSearchable,
          orderable: column.bSortable,
          search: {
            value: preColSearch[i].search,
            regex: preColSearch[i].regex,
            fixed: Object.keys(column.searchFixed).map(function(name) {
              return {
                name,
                term: column.searchFixed[name].toString()
              };
            })
          }
        };
      }),
      order: _fnSortFlatten6(settings).map(function(val) {
        return {
          column: val.col,
          dir: val.dir,
          name: colData(val.col, "sName")
        };
      }),
      start: settings._iDisplayStart,
      length: features.bPaginate ? settings._iDisplayLength : -1,
      search: {
        value: preSearch.search,
        regex: preSearch.regex,
        fixed: Object.keys(settings.searchFixed).map(function(name) {
          return {
            name,
            term: settings.searchFixed[name].toString()
          };
        })
      }
    };
  }
  function _fnAjaxUpdateDraw6(settings, json) {
    var data = _fnAjaxDataSrc6(settings, json);
    var draw = _fnAjaxDataSrcParam6(settings, "draw", json);
    var recordsTotal = _fnAjaxDataSrcParam6(settings, "recordsTotal", json);
    var recordsFiltered = _fnAjaxDataSrcParam6(settings, "recordsFiltered", json);
    if (draw !== void 0) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    if (!data) {
      data = [];
    }
    _fnClearTable6(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData6(settings, data[i]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnDraw6(settings, true);
    _fnInitComplete6(settings);
    _fnProcessingDisplay6(settings, false);
  }
  function _fnAjaxDataSrc6(settings, json, write) {
    var dataProp = "data";
    if ($15.isPlainObject(settings.ajax) && settings.ajax.dataSrc !== void 0) {
      var dataSrc = settings.ajax.dataSrc;
      if (typeof dataSrc === "string" || typeof dataSrc === "function") {
        dataProp = dataSrc;
      } else if (dataSrc.data !== void 0) {
        dataProp = dataSrc.data;
      }
    }
    if (!write) {
      if (dataProp === "data") {
        return json.aaData || json[dataProp];
      }
      return dataProp !== "" ? _fnGetObjectDataFn6(dataProp)(json) : json;
    }
    _fnSetObjectDataFn6(dataProp)(json, write);
  }
  function _fnAjaxDataSrcParam6(settings, param, json) {
    var dataSrc = $15.isPlainObject(settings.ajax) ? settings.ajax.dataSrc : null;
    if (dataSrc && dataSrc[param]) {
      return _fnGetObjectDataFn6(dataSrc[param])(json);
    }
    var old = "";
    if (param === "draw") {
      old = "sEcho";
    } else if (param === "recordsTotal") {
      old = "iTotalRecords";
    } else if (param === "recordsFiltered") {
      old = "iTotalDisplayRecords";
    }
    return json[old] !== void 0 ? json[old] : json[param];
  }
  function _fnFilterComplete6(settings, input) {
    var columnsSearch = settings.aoPreSearchCols;
    _fnColumnTypes6(settings);
    if (_fnDataSource6(settings) != "ssp") {
      _fnFilterData6(settings);
      settings.aiDisplay = settings.aiDisplayMaster.slice();
      _fnFilter6(settings.aiDisplay, settings, input.search, input);
      $15.each(settings.searchFixed, function(name, term) {
        _fnFilter6(settings.aiDisplay, settings, term, {});
      });
      for (var i = 0; i < columnsSearch.length; i++) {
        var col = columnsSearch[i];
        _fnFilter6(
          settings.aiDisplay,
          settings,
          col.search,
          col,
          i
        );
        $15.each(settings.aoColumns[i].searchFixed, function(name, term) {
          _fnFilter6(settings.aiDisplay, settings, term, {}, i);
        });
      }
      _fnFilterCustom6(settings);
    }
    settings.bFiltered = true;
    _fnCallbackFire6(settings, null, "search", [settings]);
  }
  function _fnFilterCustom6(settings) {
    var filters = DataTable6.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = [];
      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];
        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      displayRows.push.apply(displayRows, rows);
    }
  }
  function _fnFilter6(searchRows, settings, input, options, column) {
    if (input === "") {
      return;
    }
    var i = 0;
    var searchFunc = typeof input === "function" ? input : null;
    var rpSearch = input instanceof RegExp ? input : searchFunc ? null : _fnFilterCreateSearch6(input, options);
    while (i < searchRows.length) {
      var row = settings.aoData[searchRows[i]];
      var data = column === void 0 ? row._sFilterRow : row._aFilterData[column];
      if (searchFunc && !searchFunc(data, row._aData, searchRows[i], column) || rpSearch && !rpSearch.test(data)) {
        searchRows.splice(i, 1);
        i--;
      }
      i++;
    }
  }
  function _fnFilterCreateSearch6(search, inOpts) {
    var not = [];
    var options = $15.extend({}, {
      boundary: false,
      caseInsensitive: true,
      exact: false,
      regex: false,
      smart: true
    }, inOpts);
    if (typeof search !== "string") {
      search = search.toString();
    }
    search = _normalize6(search);
    if (options.exact) {
      return new RegExp(
        "^" + _fnEscapeRegex6(search) + "$",
        options.caseInsensitive ? "i" : ""
      );
    }
    search = options.regex ? search : _fnEscapeRegex6(search);
    if (options.smart) {
      var parts = search.match(/!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""];
      var a = parts.map(function(word) {
        var negative = false;
        var m2;
        if (word.charAt(0) === "!") {
          negative = true;
          word = word.substring(1);
        }
        if (word.charAt(0) === '"') {
          m2 = word.match(/^"(.*)"$/);
          word = m2 ? m2[1] : word;
        } else if (word.charAt(0) === "\u201C") {
          m2 = word.match(/^\u201C(.*)\u201D$/);
          word = m2 ? m2[1] : word;
        }
        if (negative) {
          if (word.length > 1) {
            not.push("(?!" + word + ")");
          }
          word = "";
        }
        return word.replace(/"/g, "");
      });
      var match = not.length ? not.join("") : "";
      var boundary = options.boundary ? "\\b" : "";
      search = "^(?=.*?" + boundary + a.join(")(?=.*?" + boundary) + ")(" + match + ".)*$";
    }
    return new RegExp(search, options.caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex6 = DataTable6.util.escapeRegex;
  var __filter_div6 = $15("<div>")[0];
  var __filter_div_textContent6 = __filter_div6.textContent !== void 0;
  function _fnFilterData6(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var column;
    var j, jen, filterData, cellData, row;
    var wasInvalidated = false;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aFilterData) {
        filterData = [];
        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];
          if (column.bSearchable) {
            cellData = _fnGetCellData6(settings, rowIdx, j, "filter");
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div6.innerHTML = cellData;
            cellData = __filter_div_textContent6 ? __filter_div6.textContent : __filter_div6.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnInitialise6(settings) {
    var i, iAjaxStart = settings.iInitDisplayStart;
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise6(settings);
      }, 200);
      return;
    }
    _fnBuildHead6(settings, "header");
    _fnBuildHead6(settings, "footer");
    _fnDrawHead6(settings, settings.aoHeader);
    _fnDrawHead6(settings, settings.aoFooter);
    _fnAddOptionsHtml6(settings);
    _fnSortInit6(settings);
    _colGroup6(settings);
    _fnProcessingDisplay6(settings, true);
    _fnCallbackFire6(settings, null, "preInit", [settings], true);
    _fnReDraw6(settings);
    var dataSrc = _fnDataSource6(settings);
    if (dataSrc != "ssp") {
      if (dataSrc == "ajax") {
        _fnBuildAjax6(settings, {}, function(json) {
          var aData = _fnAjaxDataSrc6(settings, json);
          for (i = 0; i < aData.length; i++) {
            _fnAddData6(settings, aData[i]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw6(settings);
          _fnProcessingDisplay6(settings, false);
          _fnInitComplete6(settings);
        }, settings);
      } else {
        _fnInitComplete6(settings);
        _fnProcessingDisplay6(settings, false);
      }
    }
  }
  function _fnInitComplete6(settings) {
    if (settings._bInitComplete) {
      return;
    }
    var args = [settings, settings.json];
    settings._bInitComplete = true;
    _fnAdjustColumnSizing6(settings);
    _fnCallbackFire6(settings, null, "plugin-init", args, true);
    _fnCallbackFire6(settings, "aoInitComplete", "init", args, true);
  }
  function _fnLengthChange6(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow6(settings);
    _fnCallbackFire6(settings, null, "length", [settings, len]);
  }
  function _fnPageChange6(settings, action, redraw) {
    var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;
      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;
      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else if (action === "ellipsis") {
      return;
    } else {
      _fnLog6(settings, 0, "Unknown paging action: " + action, 5);
    }
    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;
    _fnCallbackFire6(settings, null, changed ? "page" : "page-nc", [settings]);
    if (changed && redraw) {
      _fnDraw6(settings);
    }
    return changed;
  }
  function _processingHtml6(settings) {
    var table = settings.nTable;
    if (settings.oFeatures.bProcessing) {
      var n = $15("<div/>", {
        "id": settings.sTableId + "_processing",
        "class": settings.oClasses.processing.container,
        "role": "status"
      }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>").insertBefore(table);
      $15(table).on("processing.dt.DT", function(e, s, show) {
        n.css("display", show ? "block" : "none");
      });
    }
  }
  function _fnProcessingDisplay6(settings, show) {
    _fnCallbackFire6(settings, null, "processing", [settings, show]);
  }
  function _fnFeatureHtmlTable6(settings) {
    var table = $15(settings.nTable);
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses.scrolling;
    var caption = settings.captionNode;
    var captionSide = caption ? caption._captionSide : null;
    var headerClone = $15(table[0].cloneNode(false));
    var footerClone = $15(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size = function(s) {
      return !s ? null : _fnStringToCss6(s);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $15(_div, { "class": classes.container }).append(
      $15(_div, { "class": classes.header.self }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: scrollX ? size(scrollX) : "100%"
      }).append(
        $15(_div, { "class": classes.header.inner }).css({
          "box-sizing": "content-box",
          width: scroll.sXInner || "100%"
        }).append(
          headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
            table.children("thead")
          )
        )
      )
    ).append(
      $15(_div, { "class": classes.body }).css({
        position: "relative",
        overflow: "auto",
        width: size(scrollX)
      }).append(table)
    );
    if (footer) {
      scroller.append(
        $15(_div, { "class": classes.footer.self }).css({
          overflow: "hidden",
          border: 0,
          width: scrollX ? size(scrollX) : "100%"
        }).append(
          $15(_div, { "class": classes.footer.inner }).append(
            footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
              table.children("tfoot")
            )
          )
        )
      );
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    $15(scrollBody).on("scroll.DT", function() {
      var scrollLeft = this.scrollLeft;
      scrollHead.scrollLeft = scrollLeft;
      if (footer) {
        scrollFoot.scrollLeft = scrollLeft;
      }
    });
    $15("th, td", scrollHead).on("focus", function() {
      var scrollLeft = scrollHead.scrollLeft;
      scrollBody.scrollLeft = scrollLeft;
      if (footer) {
        scrollBody.scrollLeft = scrollLeft;
      }
    });
    $15(scrollBody).css("max-height", scrollY);
    if (!scroll.bCollapse) {
      $15(scrollBody).css("height", scrollY);
    }
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push(_fnScrollDraw6);
    return scroller[0];
  }
  function _fnScrollDraw6(settings) {
    var scroll = settings.oScroll, barWidth = scroll.iBarWidth, divHeader = $15(settings.nScrollHead), divHeaderInner = divHeader.children("div"), divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $15(divBodyEl), divFooter = $15(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $15(settings.nTHead), table = $15(settings.nTable), footer = settings.nTFoot && $15("th, td", settings.nTFoot).length ? $15(settings.nTFoot) : null, browser = settings.oBrowser, headerCopy, footerCopy;
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing6(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    headerCopy = header.clone().prependTo(table);
    headerCopy.find("th, td").removeAttr("tabindex");
    headerCopy.find("[id]").removeAttr("id");
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerCopy.find("[id]").removeAttr("id");
    }
    if (settings.aiDisplay.length) {
      var colSizes = table.find("tbody tr").eq(0).find("th, td").map(function(vis) {
        return {
          idx: _fnVisibleToColumnIndex6(settings, vis),
          width: $15(this).outerWidth()
        };
      });
      for (var i = 0; i < colSizes.length; i++) {
        var colEl = settings.aoColumns[colSizes[i].idx].colEl[0];
        var colWidth = colEl.style.width.replace("px", "");
        if (colWidth !== colSizes[i].width) {
          colEl.style.width = colSizes[i].width + "px";
        }
      }
    }
    divHeaderTable.find("colgroup").remove();
    divHeaderTable.append(settings.colgroup.clone());
    if (footer) {
      divFooterTable.find("colgroup").remove();
      divFooterTable.append(settings.colgroup.clone());
    }
    $15("th, td", headerCopy).each(function() {
      $15(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
    });
    if (footer) {
      $15("th, td", footerCopy).each(function() {
        $15(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
      });
    }
    var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var paddingSide = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    var outerWidth = table.outerWidth();
    divHeaderTable.css("width", _fnStringToCss6(outerWidth));
    divHeaderInner.css("width", _fnStringToCss6(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    if (footer) {
      divFooterTable.css("width", _fnStringToCss6(outerWidth));
      divFooterInner.css("width", _fnStringToCss6(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    }
    table.children("colgroup").prependTo(table);
    divBody.trigger("scroll");
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnCalculateColumnWidths6(settings) {
    if (!settings.oFeatures.bAutoWidth) {
      return;
    }
    var table = settings.nTable, columns = settings.aoColumns, scroll = settings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, visibleColumns = _fnGetColumns6(settings, "bVisible"), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, i, column, columnIdx;
    var styleWidth = table.style.width;
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    _fnCallbackFire6(
      settings,
      null,
      "column-calc",
      { visible: visibleColumns },
      false
    );
    var tmpTable = $15(table.cloneNode()).css("visibility", "hidden").removeAttr("id");
    tmpTable.append("<tbody>");
    var tr = $15("<tr/>").appendTo(tmpTable.find("tbody"));
    tmpTable.append($15(settings.nTHead).clone()).append($15(settings.nTFoot).clone());
    tmpTable.find("tfoot th, tfoot td").css("width", "");
    tmpTable.find("thead th, thead td").each(function() {
      var width = _fnColumnsSumWidth6(settings, this, true, false);
      if (width) {
        this.style.width = width;
        if (scrollX) {
          $15(this).append($15("<div/>").css({
            width,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } else {
        this.style.width = "";
      }
    });
    for (i = 0; i < visibleColumns.length; i++) {
      columnIdx = visibleColumns[i];
      column = columns[columnIdx];
      var longest = _fnGetMaxLenString6(settings, columnIdx);
      var autoClass = _ext6.type.className[column.sType];
      var text = longest + column.sContentPadding;
      var insert = longest.indexOf("<") === -1 ? document.createTextNode(text) : text;
      $15("<td/>").addClass(autoClass).addClass(column.sClass).append(insert).appendTo(tr);
    }
    $15("[name]", tmpTable).removeAttr("name");
    var holder = $15("<div/>").css(
      scrollX || scrollY ? {
        position: "absolute",
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: "hidden"
      } : {}
    ).append(tmpTable).appendTo(tableContainer);
    if (scrollX && scrollXInner) {
      tmpTable.width(scrollXInner);
    } else if (scrollX) {
      tmpTable.css("width", "auto");
      tmpTable.removeAttr("width");
      if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
        tmpTable.width(tableContainer.clientWidth);
      }
    } else if (scrollY) {
      tmpTable.width(tableContainer.clientWidth);
    } else if (tableWidthAttr) {
      tmpTable.width(tableWidthAttr);
    }
    var total = 0;
    var bodyCells = tmpTable.find("tbody tr").eq(0).children();
    for (i = 0; i < visibleColumns.length; i++) {
      var bounding = bodyCells[i].getBoundingClientRect().width;
      total += bounding;
      columns[visibleColumns[i]].sWidth = _fnStringToCss6(bounding);
    }
    table.style.width = _fnStringToCss6(total);
    holder.remove();
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss6(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !settings._reszEvt) {
      var bindResize = function() {
        $15(window).on("resize.DT-" + settings.sInstance, DataTable6.util.throttle(function() {
          if (!settings.bDestroying) {
            _fnAdjustColumnSizing6(settings);
          }
        }));
      };
      bindResize();
      settings._reszEvt = true;
    }
  }
  function _fnGetMaxLenString6(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    if (!column.maxLenString) {
      var s, max = "", maxLen = -1;
      for (var i = 0, ien = settings.aiDisplayMaster.length; i < ien; i++) {
        var rowIdx = settings.aiDisplayMaster[i];
        var data = _fnGetRowDisplay6(settings, rowIdx)[colIdx];
        var cellString = data && typeof data === "object" && data.nodeType ? data.innerHTML : data + "";
        cellString = cellString.replace(/id=".*?"/g, "").replace(/name=".*?"/g, "");
        s = _stripHtml6(cellString).replace(/&nbsp;/g, " ");
        if (s.length > maxLen) {
          max = cellString;
          maxLen = s.length;
        }
      }
      column.maxLenString = max;
    }
    return column.maxLenString;
  }
  function _fnStringToCss6(s) {
    if (s === null) {
      return "0px";
    }
    if (typeof s == "number") {
      return s < 0 ? "0px" : s + "px";
    }
    return s.match(/\d$/) ? s + "px" : s;
  }
  function _colGroup6(settings) {
    var cols = settings.aoColumns;
    settings.colgroup.empty();
    for (i = 0; i < cols.length; i++) {
      if (cols[i].bVisible) {
        settings.colgroup.append(cols[i].colEl);
      }
    }
  }
  function _fnSortInit6(settings) {
    var target = settings.nTHead;
    var headerRows = target.querySelectorAll("tr");
    var legacyTop = settings.bSortCellsTop;
    var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
    if (legacyTop === true) {
      target = headerRows[0];
    } else if (legacyTop === false) {
      target = headerRows[headerRows.length - 1];
    }
    _fnSortAttachListener6(
      settings,
      target,
      target === settings.nTHead ? "tr" + notSelector + " th" + notSelector + ", tr" + notSelector + " td" + notSelector : "th" + notSelector + ", td" + notSelector
    );
    var order = [];
    _fnSortResolve6(settings, order, settings.aaSorting);
    settings.aaSorting = order;
  }
  function _fnSortAttachListener6(settings, node, selector, column, callback) {
    _fnBindAction6(node, selector, function(e) {
      var run = false;
      var columns = column === void 0 ? _fnColumnsFromHeader6(e.target) : [column];
      if (columns.length) {
        for (var i = 0, ien = columns.length; i < ien; i++) {
          var ret = _fnSortAdd6(settings, columns[i], i, e.shiftKey);
          if (ret !== false) {
            run = true;
          }
          if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === "") {
            break;
          }
        }
        if (run) {
          _fnProcessingDisplay6(settings, true);
          setTimeout(function() {
            _fnSort6(settings);
            _fnSortDisplay6(settings, settings.aiDisplay);
            _fnProcessingDisplay6(settings, false);
            _fnReDraw6(settings, false, false);
            if (callback) {
              callback();
            }
          }, 0);
        }
      }
    });
  }
  function _fnSortDisplay6(settings, display) {
    var master = settings.aiDisplayMaster;
    var masterMap = {};
    var map2 = {};
    var i;
    for (i = 0; i < master.length; i++) {
      masterMap[master[i]] = i;
    }
    for (i = 0; i < display.length; i++) {
      map2[display[i]] = masterMap[display[i]];
    }
    display.sort(function(a, b) {
      return map2[a] - map2[b];
    });
  }
  function _fnSortResolve6(settings, nestedSort, sort) {
    var push = function(a) {
      if ($15.isPlainObject(a)) {
        if (a.idx !== void 0) {
          nestedSort.push([a.idx, a.dir]);
        } else if (a.name) {
          var cols = _pluck6(settings.aoColumns, "sName");
          var idx = cols.indexOf(a.name);
          if (idx !== -1) {
            nestedSort.push([idx, a.dir]);
          }
        }
      } else {
        nestedSort.push(a);
      }
    };
    if ($15.isPlainObject(sort)) {
      push(sort);
    } else if (sort.length && typeof sort[0] === "number") {
      push(sort);
    } else if (sort.length) {
      for (var z = 0; z < sort.length; z++) {
        push(sort[z]);
      }
    }
  }
  function _fnSortFlatten6(settings) {
    var i, k, kLen, aSort = [], extSort = DataTable6.ext.type.order, aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $15.isPlainObject(fixed), nestedSort = [];
    if (!settings.oFeatures.bSort) {
      return aSort;
    }
    if (Array.isArray(fixed)) {
      _fnSortResolve6(settings, nestedSort, fixed);
    }
    if (fixedObj && fixed.pre) {
      _fnSortResolve6(settings, nestedSort, fixed.pre);
    }
    _fnSortResolve6(settings, nestedSort, settings.aaSorting);
    if (fixedObj && fixed.post) {
      _fnSortResolve6(settings, nestedSort, fixed.post);
    }
    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      if (aoColumns[srcCol]) {
        aDataSort = aoColumns[srcCol].aDataSort;
        for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
          iCol = aDataSort[k];
          sType = aoColumns[iCol].sType || "string";
          if (nestedSort[i]._idx === void 0) {
            nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
          }
          if (nestedSort[i][1]) {
            aSort.push({
              src: srcCol,
              col: iCol,
              dir: nestedSort[i][1],
              index: nestedSort[i]._idx,
              type: sType,
              formatter: extSort[sType + "-pre"],
              sorter: extSort[sType + "-" + nestedSort[i][1]]
            });
          }
        }
      }
    }
    return aSort;
  }
  function _fnSort6(oSettings, col, dir) {
    var i, ien, iLen, aiOrig = [], extSort = DataTable6.ext.type.order, aoData = oSettings.aoData, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    _fnColumnTypes6(oSettings);
    if (col !== void 0) {
      var srcCol = oSettings.aoColumns[col];
      aSort = [{
        src: col,
        col,
        dir,
        index: 0,
        type: srcCol.sType,
        formatter: extSort[srcCol.sType + "-pre"],
        sorter: extSort[srcCol.sType + "-" + dir]
      }];
      displayMaster = displayMaster.slice();
    } else {
      aSort = _fnSortFlatten6(oSettings);
    }
    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i];
      _fnSortData6(oSettings, sortCol.col);
    }
    if (_fnDataSource6(oSettings) != "ssp" && aSort.length !== 0) {
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[i] = i;
      }
      if (aSort.length && aSort[0].dir === "desc") {
        aiOrig.reverse();
      }
      displayMaster.sort(function(a, b) {
        var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
        for (k = 0; k < len; k++) {
          sort = aSort[k];
          x = dataA[sort.col];
          y = dataB[sort.col];
          if (sort.sorter) {
            test = sort.sorter(x, y);
            if (test !== 0) {
              return test;
            }
          } else {
            test = x < y ? -1 : x > y ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
        }
        x = aiOrig[a];
        y = aiOrig[b];
        return x < y ? -1 : x > y ? 1 : 0;
      });
    } else if (aSort.length === 0) {
      displayMaster.sort(function(x, y) {
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    if (col === void 0) {
      oSettings.bSorted = true;
      _fnCallbackFire6(oSettings, null, "order", [oSettings, aSort]);
    }
    return displayMaster;
  }
  function _fnSortAdd6(settings, colIdx, addIndex, shift) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a, overflow) {
      var idx = a._idx;
      if (idx === void 0) {
        idx = asSorting.indexOf(a[1]);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (!col.bSortable) {
      return false;
    }
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if ((shift || addIndex) && settings.oFeatures.bSortMulti) {
      var sortIdx = _pluck6(sorting, "0").indexOf(colIdx);
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else if (shift) {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      } else {
        sorting.push([colIdx, sorting[0][1], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    }
  }
  function _fnSortingClasses6(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.order.position;
    var sort = _fnSortFlatten6(settings);
    var features = settings.oFeatures;
    var i, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src;
        $15(_pluck6(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      }
      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $15(_pluck6(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData6(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    var customSort = DataTable6.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(
        settings.oInstance,
        settings,
        colIdx,
        _fnColumnIndexToVisible6(settings, colIdx)
      );
    }
    var row, cellData;
    var formatter = DataTable6.ext.type.order[column.sType + "-pre"];
    var data = settings.aoData;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[colIdx] || customSort) {
        cellData = customSort ? customData[rowIdx] : (
          // If there was a custom sort function, use data from there
          _fnGetCellData6(settings, rowIdx, colIdx, "sort")
        );
        row._aSortData[colIdx] = formatter ? formatter(cellData, settings) : cellData;
      }
    }
  }
  function _fnSaveState6(settings) {
    if (settings._bLoadingState) {
      return;
    }
    var state = {
      time: +/* @__PURE__ */ new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $15.extend(true, [], settings.aaSorting),
      search: $15.extend({}, settings.oPreviousSearch),
      columns: settings.aoColumns.map(function(col, i) {
        return {
          visible: col.bVisible,
          search: $15.extend({}, settings.aoPreSearchCols[i])
        };
      })
    };
    settings.oSavedState = state;
    _fnCallbackFire6(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
  }
  function _fnLoadState6(settings, init2, callback) {
    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }
    var loaded = function(state2) {
      _fnImplementState6(settings, state2, callback);
    };
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
    if (state !== void 0) {
      _fnImplementState6(settings, state, callback);
    }
    return true;
  }
  function _fnImplementState6(settings, s, callback) {
    var i, ien;
    var columns = settings.aoColumns;
    settings._bLoadingState = true;
    var api = settings._bInitComplete ? new DataTable6.Api(settings) : null;
    if (!s || !s.time) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && s.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var abStateLoad = _fnCallbackFire6(settings, "aoStateLoadParams", "stateLoadParams", [settings, s]);
    if (abStateLoad.indexOf(false) !== -1) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    if (s.columns && columns.length !== s.columns.length) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    settings.oLoadedState = $15.extend(true, {}, s);
    _fnCallbackFire6(settings, null, "stateLoadInit", [settings, s], true);
    if (s.length !== void 0) {
      if (api) {
        api.page.len(s.length);
      } else {
        settings._iDisplayLength = s.length;
      }
    }
    if (s.start !== void 0) {
      if (api === null) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      } else {
        _fnPageChange6(settings, s.start / settings._iDisplayLength);
      }
    }
    if (s.order !== void 0) {
      settings.aaSorting = [];
      $15.each(s.order, function(i2, col2) {
        settings.aaSorting.push(
          col2[0] >= columns.length ? [0, col2[1]] : col2
        );
      });
    }
    if (s.search !== void 0) {
      $15.extend(settings.oPreviousSearch, s.search);
    }
    if (s.columns) {
      for (i = 0, ien = s.columns.length; i < ien; i++) {
        var col = s.columns[i];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i).visible(col.visible, false);
          } else {
            columns[i].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $15.extend(settings.aoPreSearchCols[i], col.search);
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
    settings._bLoadingState = false;
    _fnCallbackFire6(settings, "aoStateLoaded", "stateLoaded", [settings, s]);
    callback();
  }
  function _fnLog6(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable6.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire6(settings, null, "dt-error", [settings, tn, msg], true);
      }
      if (type == "alert") {
        alert(msg);
      } else if (type == "throw") {
        throw new Error(msg);
      } else if (typeof type == "function") {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  function _fnMap6(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $15.each(name, function(i, val) {
        if (Array.isArray(val)) {
          _fnMap6(ret, src, val[0], val[1]);
        } else {
          _fnMap6(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === void 0) {
      mappedName = name;
    }
    if (src[name] !== void 0) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend6(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, prop)) {
        val = extender[prop];
        if ($15.isPlainObject(val)) {
          if (!$15.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $15.extend(true, out[prop], val);
        } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }
    return out;
  }
  function _fnBindAction6(n, selector, fn) {
    $15(n).on("click.DT", selector, function(e) {
      fn(e);
    }).on("keypress.DT", selector, function(e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on("selectstart.DT", selector, function() {
      return false;
    });
  }
  function _fnCallbackReg6(settings, store, fn) {
    if (fn) {
      settings[store].push(fn);
    }
  }
  function _fnCallbackFire6(settings, callbackArr, eventName, args, bubbles) {
    var ret = [];
    if (callbackArr) {
      ret = settings[callbackArr].slice().reverse().map(function(val) {
        return val.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e = $15.Event(eventName + ".dt");
      var table = $15(settings.nTable);
      e.dt = settings.api;
      table[bubbles ? "trigger" : "triggerHandler"](e, args);
      if (bubbles && table.parents("body").length === 0) {
        $15("body").trigger(e, args);
      }
      ret.push(e.result);
    }
    return ret;
  }
  function _fnLengthOverflow6(settings) {
    var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start >= end) {
      start = end - len;
    }
    start -= start % len;
    if (len === -1 || start < 0) {
      start = 0;
    }
    settings._iDisplayStart = start;
  }
  function _fnRenderer6(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable6.ext.renderer[type];
    if ($15.isPlainObject(renderer) && renderer[type]) {
      return host[renderer[type]] || host._;
    } else if (typeof renderer === "string") {
      return host[renderer] || host._;
    }
    return host._;
  }
  function _fnDataSource6(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else if (settings.ajax) {
      return "ajax";
    }
    return "dom";
  }
  function _fnMacros6(settings, str, entries) {
    var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), max = settings.fnRecordsTotal(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, max)).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len))).replace(/_ENTRIES_/g, settings.api.i18n("entries", "", entries)).replace(/_ENTRIES-MAX_/g, settings.api.i18n("entries", "", max)).replace(/_ENTRIES-TOTAL_/g, settings.api.i18n("entries", "", vis));
  }
  var __apiStruct6 = [];
  var __arrayProto6 = Array.prototype;
  var _toSettings6 = function(mixed) {
    var idx, jq;
    var settings = DataTable6.settings;
    var tables = _pluck6(settings, "nTable");
    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oFeatures) {
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
      idx = tables.indexOf(mixed);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === "function") {
      return mixed.settings().toArray();
    } else if (typeof mixed === "string") {
      jq = $15(mixed).get();
    } else if (mixed instanceof $15) {
      jq = mixed.get();
    }
    if (jq) {
      return settings.filter(function(v, idx2) {
        return jq.includes(tables[idx2]);
      });
    }
  };
  _Api6 = function(context, data) {
    if (!(this instanceof _Api6)) {
      return new _Api6(context, data);
    }
    var settings = [];
    var ctxSettings = function(o) {
      var a = _toSettings6(o);
      if (a) {
        settings.push.apply(settings, a);
      }
    };
    if (Array.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = settings.length > 1 ? _unique6(settings) : settings;
    if (data) {
      this.push.apply(this, data);
    }
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
    _Api6.extend(this, this, __apiStruct6);
  };
  DataTable6.Api = _Api6;
  $15.extend(_Api6.prototype, {
    any: function() {
      return this.count() !== 0;
    },
    context: [],
    // array of table settings objects
    count: function() {
      return this.flatten().length;
    },
    each: function(fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }
      return this;
    },
    eq: function(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api6(ctx[idx], this[idx]) : null;
    },
    filter: function(fn) {
      var a = __arrayProto6.filter.call(this, fn, this);
      return new _Api6(this.context, a);
    },
    flatten: function() {
      var a = [];
      return new _Api6(this.context, a.concat.apply(a, this.toArray()));
    },
    get: function(idx) {
      return this[idx];
    },
    join: __arrayProto6.join,
    includes: function(find) {
      return this.indexOf(find) === -1 ? false : true;
    },
    indexOf: __arrayProto6.indexOf,
    iterator: function(flatten, type, fn, alwaysNew) {
      var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
      if (typeof flatten === "string") {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }
      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api6(context[i]);
        if (type === "table") {
          ret = fn.call(apiInst, context[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "columns" || type === "rows") {
          ret = fn.call(apiInst, context[i], this[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "every" || type === "column" || type === "column-rows" || type === "row" || type === "cell") {
          items = this[i];
          if (type === "column-rows") {
            rows = _selector_row_indexes6(context[i], selector.opts);
          }
          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];
            if (type === "cell") {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }
            if (ret !== void 0) {
              a.push(ret);
            }
          }
        }
      }
      if (a.length || alwaysNew) {
        var api = new _Api6(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
    lastIndexOf: __arrayProto6.lastIndexOf,
    length: 0,
    map: function(fn) {
      var a = __arrayProto6.map.call(this, fn, this);
      return new _Api6(this.context, a);
    },
    pluck: function(prop) {
      var fn = DataTable6.util.get(prop);
      return this.map(function(el) {
        return fn(el);
      });
    },
    pop: __arrayProto6.pop,
    push: __arrayProto6.push,
    reduce: __arrayProto6.reduce,
    reduceRight: __arrayProto6.reduceRight,
    reverse: __arrayProto6.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto6.shift,
    slice: function() {
      return new _Api6(this.context, this);
    },
    sort: __arrayProto6.sort,
    splice: __arrayProto6.splice,
    toArray: function() {
      return __arrayProto6.slice.call(this);
    },
    to$: function() {
      return $15(this);
    },
    toJQuery: function() {
      return $15(this);
    },
    unique: function() {
      return new _Api6(this.context, _unique6(this.toArray()));
    },
    unshift: __arrayProto6.unshift
  });
  function _api_scope6(scope, fn, struc) {
    return function() {
      var ret = fn.apply(scope || this, arguments);
      _Api6.extend(ret, ret, struc.methodExt);
      return ret;
    };
  }
  function _api_find6(src, name) {
    for (var i = 0, ien = src.length; i < ien; i++) {
      if (src[i].name === name) {
        return src[i];
      }
    }
    return null;
  }
  window.__apiStruct = __apiStruct6;
  _Api6.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api6) && !obj.__dt_wrapper) {
      return;
    }
    var i, ien, struct;
    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i];
      if (struct.name === "__proto__") {
        continue;
      }
      obj[struct.name] = struct.type === "function" ? _api_scope6(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api6.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api6.register = _api_register6 = function(name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api6.register(name[j], val);
      }
      return;
    }
    var i, ien, heir = name.split("."), struct = __apiStruct6, key, method;
    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf("()") !== -1;
      key = method ? heir[i].replace("()", "") : heir[i];
      var src = _api_find6(struct, key);
      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: "object"
        };
        struct.push(src);
      }
      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === "function" ? "function" : $15.isPlainObject(val) ? "object" : "other";
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api6.registerPlural = _api_registerPlural6 = function(pluralName, singularName, val) {
    _Api6.register(pluralName, val);
    _Api6.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else if (ret instanceof _Api6) {
        return ret.length ? Array.isArray(ret[0]) ? new _Api6(ret.context, ret[0]) : (
          // Array results are 'enhanced'
          ret[0]
        ) : void 0;
      }
      return ret;
    });
  };
  var __table_selector6 = function(selector, a) {
    if (Array.isArray(selector)) {
      var result = [];
      selector.forEach(function(sel) {
        var inner = __table_selector6(sel, a);
        result.push.apply(result, inner);
      });
      return result.filter(function(item) {
        return item;
      });
    }
    if (typeof selector === "number") {
      return [a[selector]];
    }
    var nodes = a.map(function(el) {
      return el.nTable;
    });
    return $15(nodes).filter(selector).map(function() {
      var idx = nodes.indexOf(this);
      return a[idx];
    }).toArray();
  };
  _api_register6("tables()", function(selector) {
    return selector !== void 0 && selector !== null ? new _Api6(__table_selector6(selector, this.context)) : this;
  });
  _api_register6("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api6(ctx[0]) : tables;
  });
  [
    ["nodes", "node", "nTable"],
    ["body", "body", "nTBody"],
    ["header", "header", "nTHead"],
    ["footer", "footer", "nTFoot"]
  ].forEach(function(item) {
    _api_registerPlural6(
      "tables()." + item[0] + "()",
      "table()." + item[1] + "()",
      function() {
        return this.iterator("table", function(ctx) {
          return ctx[item[2]];
        }, 1);
      }
    );
  });
  [
    ["header", "aoHeader"],
    ["footer", "aoFooter"]
  ].forEach(function(item) {
    _api_register6("table()." + item[0] + ".structure()", function(selector) {
      var indexes = this.columns(selector).indexes().flatten();
      var ctx = this.context[0];
      return _fnHeaderLayout6(ctx, ctx[item[1]], indexes);
    });
  });
  _api_registerPlural6("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register6("tables().every()", function(fn) {
    var that = this;
    return this.iterator("table", function(s, i) {
      fn.call(that.table(i), i);
    });
  });
  _api_register6("caption()", function(value, side) {
    var context = this.context;
    if (value === void 0) {
      var caption = context[0].captionNode;
      return caption && context.length ? caption.innerHTML : null;
    }
    return this.iterator("table", function(ctx) {
      var table = $15(ctx.nTable);
      var caption2 = $15(ctx.captionNode);
      var container = $15(ctx.nTableWrapper);
      if (!caption2.length) {
        caption2 = $15("<caption/>").html(value);
        ctx.captionNode = caption2[0];
        if (!side) {
          table.prepend(caption2);
          side = caption2.css("caption-side");
        }
      }
      caption2.html(value);
      if (side) {
        caption2.css("caption-side", side);
        caption2[0]._captionSide = side;
      }
      if (container.find("div.dataTables_scroll").length) {
        var selector = side === "top" ? "Head" : "Foot";
        container.find("div.dataTables_scroll" + selector + " table").prepend(caption2);
      } else {
        table.prepend(caption2);
      }
    }, 1);
  });
  _api_register6("caption.node()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].captionNode : null;
  });
  _api_register6("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw6(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw6(settings, paging === false);
      }
    });
  });
  _api_register6("page()", function(action) {
    if (action === void 0) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange6(settings, action);
    });
  });
  _api_register6("page.info()", function() {
    if (this.context.length === 0) {
      return void 0;
    }
    var settings = this.context[0], start = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource6(settings) === "ssp"
    };
  });
  _api_register6("page.len()", function(len) {
    if (len === void 0) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange6(settings, len);
    });
  });
  var __reload6 = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api6(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource6(settings) == "ssp") {
      _fnReDraw6(settings, holdPosition);
    } else {
      _fnProcessingDisplay6(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax6(settings, {}, function(json) {
        _fnClearTable6(settings);
        var data = _fnAjaxDataSrc6(settings, json);
        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData6(settings, data[i]);
        }
        _fnReDraw6(settings, holdPosition);
        _fnInitComplete6(settings);
        _fnProcessingDisplay6(settings, false);
      });
    }
  };
  _api_register6("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register6("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register6("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload6(settings, resetPaging === false, callback);
    });
  });
  _api_register6("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === void 0) {
      if (ctx.length === 0) {
        return void 0;
      }
      ctx = ctx[0];
      return $15.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax;
    }
    return this.iterator("table", function(settings) {
      if ($15.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register6("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload6(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run6 = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
      selector = [selector];
    }
    for (i = 0, ien = selector.length; i < ien; i++) {
      a = selector[i] && selector[i].split && !selector[i].match(/[[(:]/) ? selector[i].split(",") : [selector[i]];
      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === "string" ? a[j].trim() : a[j]);
        res = res.filter(function(item) {
          return item !== null && item !== void 0;
        });
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext6.selector[type];
    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }
    return _unique6(out);
  };
  var _selector_opts6 = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === void 0) {
      opts.search = opts.filter;
    }
    return $15.extend({
      search: "none",
      order: "current",
      page: "all"
    }, opts);
  };
  var _selector_first6 = function(old) {
    let inst = new _Api6(old.context[0]);
    if (old.length) {
      inst.push(old[0]);
    }
    inst.selector = old.selector;
    if (inst.length && inst[0].length > 1) {
      inst[0].splice(1);
    }
    return inst;
  };
  var _selector_row_indexes6 = function(settings, opts) {
    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order = opts.order, page = opts.page;
    if (page == "current") {
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == "current" || order == "applied") {
      if (search == "none") {
        a = displayMaster.slice();
      } else if (search == "applied") {
        a = displayFiltered.slice();
      } else if (search == "removed") {
        var displayFilteredMap = {};
        for (i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }
        displayMaster.forEach(function(item) {
          if (!Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
            a.push(item);
          }
        });
      }
    } else if (order == "index" || order == "original") {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (!settings.aoData[i]) {
          continue;
        }
        if (search == "none") {
          a.push(i);
        } else {
          tmp = displayFiltered.indexOf(i);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(i);
          }
        }
      }
    } else if (typeof order === "number") {
      var ordered = _fnSort6(settings, order, "asc");
      if (search === "none") {
        a = ordered;
      } else {
        for (i = 0; i < ordered.length; i++) {
          tmp = displayFiltered.indexOf(ordered[i]);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(ordered[i]);
          }
        }
      }
    }
    return a;
  };
  var __row_selector6 = function(settings, selector, opts) {
    var rows;
    var run = function(sel) {
      var selInt = _intVal6(sel);
      var aoData = settings.aoData;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      if (!rows) {
        rows = _selector_row_indexes6(settings, opts);
      }
      if (selInt !== null && rows.indexOf(selInt) !== -1) {
        return [selInt];
      } else if (sel === null || sel === void 0 || sel === "") {
        return rows;
      }
      if (typeof sel === "function") {
        return rows.map(function(idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex;
        var cellIdx = sel._DT_CellIndex;
        if (rowIdx !== void 0) {
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $15(sel).closest("*[data-dt-row]");
          return host.length ? [host.data("dt-row")] : [];
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== void 0) {
          return [rowObj.idx];
        }
      }
      var nodes = _removeEmpty6(
        _pluck_order6(settings.aoData, rows, "nTr")
      );
      return $15(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    var matched = _selector_run6("row", selector, run, settings, opts);
    if (opts.order === "current" || opts.order === "applied") {
      _fnSortDisplay6(settings, matched);
    }
    return matched;
  };
  _api_register6("rows()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($15.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts6(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector6(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register6("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || void 0;
    }, 1);
  });
  _api_register6("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order6(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural6("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r = settings.aoData[row];
      return type === "search" ? r._aFilterData : r._aSortData;
    }, 1);
  });
  _api_registerPlural6("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate6(settings, row, src);
    });
  });
  _api_registerPlural6("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural6("rows().ids()", "row().id()", function(hash) {
    var a = [];
    var context = this.context;
    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? "#" : "") + id);
      }
    }
    return new _Api6(context, a);
  });
  _api_registerPlural6("rows().remove()", "row().remove()", function() {
    this.iterator("row", function(settings, row) {
      var data = settings.aoData;
      var rowData = data[row];
      var idx = settings.aiDisplayMaster.indexOf(row);
      if (idx !== -1) {
        settings.aiDisplayMaster.splice(idx, 1);
      }
      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      }
      _fnLengthOverflow6(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== void 0) {
        delete settings.aIds[id];
      }
      data[row] = null;
    });
    return this;
  });
  _api_register6("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i, ien;
      var out = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr6(settings, row)[0]);
        } else {
          out.push(_fnAddData6(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    modRows.push.apply(modRows, newRows);
    return modRows;
  });
  _api_register6("row()", function(selector, opts) {
    return _selector_first6(this.rows(selector, opts));
  });
  _api_register6("row().data()", function(data) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]]._aData : void 0;
    }
    var row = ctx[0].aoData[this[0]];
    row._aData = data;
    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn6(ctx[0].rowId)(data, row.nTr.id);
    }
    _fnInvalidate6(ctx[0], this[0], "data");
    return this;
  });
  _api_register6("row().node()", function() {
    var ctx = this.context;
    return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]].nTr || null : null;
  });
  _api_register6("row.add()", function(row) {
    if (row instanceof $15 && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr6(settings, row)[0];
      }
      return _fnAddData6(settings, row);
    });
    return this.row(rows[0]);
  });
  $15(document).on("plugin-init.dt", function(e, context) {
    var api = new _Api6(context);
    api.on("stateSaveParams.DT", function(e2, settings, d) {
      var idFn = settings.rowIdFn;
      var rows = settings.aiDisplayMaster;
      var ids = [];
      for (var i = 0; i < rows.length; i++) {
        var rowIdx = rows[i];
        var data = settings.aoData[rowIdx];
        if (data._detailsShow) {
          ids.push("#" + idFn(data._aData));
        }
      }
      d.childRows = ids;
    });
    api.on("stateLoaded.DT", function(e2, settings, state) {
      __details_state_load6(api, state);
    });
    __details_state_load6(api, api.state.loaded());
  });
  var __details_state_load6 = function(api, state) {
    if (state && state.childRows) {
      api.rows(state.childRows.map(function(id) {
        return id.replace(/(?<!\\):/g, "\\:");
      })).every(function() {
        _fnCallbackFire6(api.settings()[0], null, "requestChild", [this]);
      });
    }
  };
  var __details_add6 = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r, k) {
      if (Array.isArray(r) || r instanceof $15) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }
        return;
      }
      if (r.nodeName && r.nodeName.toLowerCase() === "tr") {
        r.setAttribute("data-dt-row", row.idx);
        rows.push(r);
      } else {
        var created = $15("<tr><td></td></tr>").attr("data-dt-row", row.idx).addClass(k);
        $15("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns6(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.detach();
    }
    row._details = $15(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_state6 = DataTable6.util.throttle(
    function(ctx) {
      _fnSaveState6(ctx[0]);
    },
    500
  );
  var __details_remove6 = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = void 0;
        row._details = void 0;
        $15(row.nTr).removeClass("dt-hasChild");
        __details_state6(ctx);
      }
    }
  };
  var __details_display6 = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
          $15(row.nTr).addClass("dt-hasChild");
        } else {
          row._details.detach();
          $15(row.nTr).removeClass("dt-hasChild");
        }
        _fnCallbackFire6(ctx[0], null, "childRow", [show, api.row(api[0])]);
        __details_events6(ctx[0]);
        __details_state6(ctx);
      }
    }
  };
  var __details_events6 = function(settings) {
    var api = new _Api6(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-sizing" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck6(data, "_details").length > 0) {
      api.on(drawEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({ page: "current" }).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns6(ctx);
        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];
          if (row && row._details) {
            row._details.each(function() {
              var el = $15(this).children("td");
              if (el.length == 1) {
                el.attr("colspan", visible);
              }
            });
          }
        }
      });
      api.on(destroyEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i] && data[i]._details) {
            __details_remove6(api, i);
          }
        }
      });
    }
  };
  var _emp6 = "";
  var _child_obj6 = _emp6 + "row().child";
  var _child_mth6 = _child_obj6 + "()";
  _api_register6(_child_mth6, function(data, klass) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && ctx[0].aoData[this[0]] ? ctx[0].aoData[this[0]]._details : void 0;
    } else if (data === true) {
      this.child.show();
    } else if (data === false) {
      __details_remove6(this);
    } else if (ctx.length && this.length) {
      __details_add6(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }
    return this;
  });
  _api_register6([
    _child_obj6 + ".show()",
    _child_mth6 + ".show()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display6(this, true);
    return this;
  });
  _api_register6([
    _child_obj6 + ".hide()",
    _child_mth6 + ".hide()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display6(this, false);
    return this;
  });
  _api_register6([
    _child_obj6 + ".remove()",
    _child_mth6 + ".remove()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_remove6(this);
    return this;
  });
  _api_register6(_child_obj6 + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector6 = /^([^:]+):(name|title|visIdx|visible)$/;
  var __columnData6 = function(settings, column, r1, r2, rows, type) {
    var a = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData6(settings, rows[row], column, type));
    }
    return a;
  };
  var __column_header6 = function(settings, column, row) {
    var header = settings.aoHeader;
    var target = row !== void 0 ? row : settings.bSortCellsTop ? 0 : header.length - 1;
    return header[target][column].cell;
  };
  var __column_selector6 = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck6(columns, "sName"), titles = _pluck6(columns, "sTitle"), cells = DataTable6.util.get("[].[].cell")(settings.aoHeader), nodes = _unique6(_flatten6([], cells));
    var run = function(s) {
      var selInt = _intVal6(s);
      if (s === "") {
        return _range6(columns.length);
      }
      if (selInt !== null) {
        return [
          selInt >= 0 ? selInt : (
            // Count from left
            columns.length + selInt
          )
          // Count from right (+ because its a negative value)
        ];
      }
      if (typeof s === "function") {
        var rows = _selector_row_indexes6(settings, opts);
        return columns.map(function(col, idx2) {
          return s(
            idx2,
            __columnData6(settings, idx2, 0, 0, rows),
            __column_header6(settings, idx2)
          ) ? idx2 : null;
        });
      }
      var match = typeof s === "string" ? s.match(__re_column_selector6) : "";
      if (match) {
        switch (match[2]) {
          case "visIdx":
          case "visible":
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = columns.map(function(col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex6(settings, idx)];
          case "name":
            return names.map(function(name, i) {
              return name === match[1] ? i : null;
            });
          case "title":
            return titles.map(function(title, i) {
              return title === match[1] ? i : null;
            });
          default:
            return [];
        }
      }
      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      }
      var jqResult = $15(nodes).filter(s).map(function() {
        return _fnColumnsFromHeader6(this);
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      var host = $15(s).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run6("column", selector, run, settings, opts);
  };
  var __setColumnVis6 = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, cells, i, ien, tr;
    if (vis === void 0) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return false;
    }
    if (vis) {
      var insertBefore = _pluck6(cols, "bVisible").indexOf(true, column + 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        if (data[i]) {
          tr = data[i].nTr;
          cells = data[i].anCells;
          if (tr) {
            tr.insertBefore(cells[column], cells[insertBefore] || null);
          }
        }
      }
    } else {
      $15(_pluck6(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
    _colGroup6(settings);
    return true;
  };
  _api_register6("columns()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($15.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts6(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector6(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural6("columns().header()", "column().header()", function(row) {
    return this.iterator("column", function(settings, column) {
      return __column_header6(settings, column, row);
    }, 1);
  });
  _api_registerPlural6("columns().footer()", "column().footer()", function(row) {
    return this.iterator("column", function(settings, column) {
      var footer = settings.aoFooter;
      if (!footer.length) {
        return null;
      }
      return settings.aoFooter[row !== void 0 ? row : 0][column].cell;
    }, 1);
  });
  _api_registerPlural6("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData6, 1);
  });
  _api_registerPlural6("columns().render()", "column().render()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return __columnData6(settings, column, i, j, rows, type);
    }, 1);
  });
  _api_registerPlural6("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural6("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order6(
        settings.aoData,
        rows,
        type === "search" ? "_aFilterData" : "_aSortData",
        column
      );
    }, 1);
  });
  _api_registerPlural6("columns().init()", "column().init()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column];
    }, 1);
  });
  _api_registerPlural6("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order6(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural6("columns().titles()", "column().title()", function(title, row) {
    return this.iterator("column", function(settings, column) {
      if (typeof title === "number") {
        row = title;
        title = void 0;
      }
      var span = $15("span.dt-column-title", this.column(column).header(row));
      if (title !== void 0) {
        span.html(title);
        return this;
      }
      return span.html();
    }, 1);
  });
  _api_registerPlural6("columns().types()", "column().type()", function() {
    return this.iterator("column", function(settings, column) {
      var type = settings.aoColumns[column].sType;
      if (!type) {
        _fnColumnTypes6(settings);
      }
      return type;
    }, 1);
  });
  _api_registerPlural6("columns().visible()", "column().visible()", function(vis, calc) {
    var that = this;
    var changed = [];
    var ret = this.iterator("column", function(settings, column) {
      if (vis === void 0) {
        return settings.aoColumns[column].bVisible;
      }
      if (__setColumnVis6(settings, column, vis)) {
        changed.push(column);
      }
    });
    if (vis !== void 0) {
      this.iterator("table", function(settings) {
        _fnDrawHead6(settings, settings.aoHeader);
        _fnDrawHead6(settings, settings.aoFooter);
        if (!settings.aiDisplay.length) {
          $15(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns6(settings));
        }
        _fnSaveState6(settings);
        that.iterator("column", function(settings2, column) {
          if (changed.includes(column)) {
            _fnCallbackFire6(settings2, null, "column-visibility", [settings2, column, vis, calc]);
          }
        });
        if (changed.length && (calc === void 0 || calc)) {
          that.columns.adjust();
        }
      });
    }
    return ret;
  });
  _api_registerPlural6("columns().widths()", "column().width()", function() {
    var columns = this.columns(":visible").count();
    var row = $15("<tr>").html("<td>" + Array(columns).join("</td><td>") + "</td>");
    $15(this.table().body()).append(row);
    var widths = row.children().map(function() {
      return $15(this).outerWidth();
    });
    row.remove();
    return this.iterator("column", function(settings, column) {
      var visIdx = _fnColumnIndexToVisible6(settings, column);
      return visIdx !== null ? widths[visIdx] : 0;
    }, 1);
  });
  _api_registerPlural6("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible6(settings, column) : column;
    }, 1);
  });
  _api_register6("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing6(settings);
    }, 1);
  });
  _api_register6("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex6(ctx, idx);
      } else if (type === "fromData" || type === "toVisible") {
        return _fnColumnIndexToVisible6(ctx, idx);
      }
    }
  });
  _api_register6("column()", function(selector, opts) {
    return _selector_first6(this.columns(selector, opts));
  });
  var __cell_selector6 = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes6(settings, opts);
    var cells = _removeEmpty6(_pluck_order6(data, rows, "anCells"));
    var allCells = $15(_flatten6([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;
    var run = function(s) {
      var fnSelector = typeof s === "function";
      if (s === null || s === void 0 || fnSelector) {
        a = [];
        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];
          for (j = 0; j < columns; j++) {
            o = {
              row,
              column: j
            };
            if (fnSelector) {
              host = data[row];
              if (s(o, _fnGetCellData6(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              a.push(o);
            }
          }
        }
        return a;
      }
      if ($15.isPlainObject(s)) {
        return s.column !== void 0 && s.row !== void 0 && rows.indexOf(s.row) !== -1 ? [s] : [];
      }
      var jqResult = allCells.filter(s).map(function(i2, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      host = $15(s).closest("*[data-dt-row]");
      return host.length ? [{
        row: host.data("dt-row"),
        column: host.data("dt-column")
      }] : [];
    };
    return _selector_run6("cell", selector, run, settings, opts);
  };
  _api_register6("cells()", function(rowSelector, columnSelector, opts) {
    if ($15.isPlainObject(rowSelector)) {
      if (rowSelector.row === void 0) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($15.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === void 0) {
      return this.iterator("table", function(settings) {
        return __cell_selector6(settings, rowSelector, _selector_opts6(opts));
      });
    }
    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {};
    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator("table", function(settings, idx) {
      var a = [];
      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }
      return a;
    }, 1);
    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $15.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts
    });
    return cells;
  });
  _api_registerPlural6("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : void 0;
    }, 1);
  });
  _api_register6("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData6(settings, row, column);
    }, 1);
  });
  _api_registerPlural6("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural6("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData6(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural6("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {
        row,
        column,
        columnVisible: _fnColumnIndexToVisible6(settings, column)
      };
    }, 1);
  });
  _api_registerPlural6("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate6(settings, row, src, column);
    });
  });
  _api_register6("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first6(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register6("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === void 0) {
      return ctx.length && cell.length ? _fnGetCellData6(ctx[0], cell[0].row, cell[0].column) : void 0;
    }
    _fnSetCellData6(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate6(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register6("order()", function(order, dir) {
    var ctx = this.context;
    var args = Array.prototype.slice.call(arguments);
    if (order === void 0) {
      return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
    }
    if (typeof order === "number") {
      order = [[order, dir]];
    } else if (args.length > 1) {
      order = args;
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = Array.isArray(order) ? order.slice() : order;
    });
  });
  _api_register6("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener6(settings, node, {}, column, callback);
    });
  });
  _api_register6("order.fixed()", function(set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
      return Array.isArray(fixed) ? { pre: fixed } : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $15.extend(true, {}, set);
    });
  });
  _api_register6([
    "columns().order()",
    "column().order()"
  ], function(dir) {
    var that = this;
    if (!dir) {
      return this.iterator("column", function(settings, idx) {
        var sort = _fnSortFlatten6(settings);
        for (var i = 0, ien = sort.length; i < ien; i++) {
          if (sort[i].col === idx) {
            return sort[i].dir;
          }
        }
        return null;
      }, 1);
    } else {
      return this.iterator("table", function(settings, i) {
        settings.aaSorting = that[i].map(function(col) {
          return [col, dir];
        });
      });
    }
  });
  _api_registerPlural6("columns().orderable()", "column().orderable()", function(directions) {
    return this.iterator("column", function(settings, idx) {
      var col = settings.aoColumns[idx];
      return directions ? col.asSorting : col.bSortable;
    }, 1);
  });
  _api_register6("processing()", function(show) {
    return this.iterator("table", function(ctx) {
      _fnProcessingDisplay6(ctx, show);
    });
  });
  _api_register6("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === void 0) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.search : void 0;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      if (typeof regex === "object") {
        _fnFilterComplete6(settings, $15.extend(settings.oPreviousSearch, regex, {
          search: input
        }));
      } else {
        _fnFilterComplete6(settings, $15.extend(settings.oPreviousSearch, {
          search: input,
          regex: regex === null ? false : regex,
          smart: smart === null ? true : smart,
          caseInsensitive: caseInsen === null ? true : caseInsen
        }));
      }
    });
  });
  _api_register6("search.fixed()", function(name, search) {
    var ret = this.iterator(true, "table", function(settings) {
      var fixed = settings.searchFixed;
      if (!name) {
        return Object.keys(fixed);
      } else if (search === void 0) {
        return fixed[name];
      } else if (search === null) {
        delete fixed[name];
      } else {
        fixed[name] = search;
      }
      return this;
    });
    return name !== void 0 && search === void 0 ? ret[0] : ret;
  });
  _api_registerPlural6(
    "columns().search()",
    "column().search()",
    function(input, regex, smart, caseInsen) {
      return this.iterator("column", function(settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === void 0) {
          return preSearch[column].search;
        }
        if (!settings.oFeatures.bFilter) {
          return;
        }
        if (typeof regex === "object") {
          $15.extend(preSearch[column], regex, {
            search: input
          });
        } else {
          $15.extend(preSearch[column], {
            search: input,
            regex: regex === null ? false : regex,
            smart: smart === null ? true : smart,
            caseInsensitive: caseInsen === null ? true : caseInsen
          });
        }
        _fnFilterComplete6(settings, settings.oPreviousSearch);
      });
    }
  );
  _api_register6(
    [
      "columns().search.fixed()",
      "column().search.fixed()"
    ],
    function(name, search) {
      var ret = this.iterator(true, "column", function(settings, colIdx) {
        var fixed = settings.aoColumns[colIdx].searchFixed;
        if (!name) {
          return Object.keys(fixed);
        } else if (search === void 0) {
          return fixed[name];
        } else if (search === null) {
          delete fixed[name];
        } else {
          fixed[name] = search;
        }
        return this;
      });
      return name !== void 0 && search === void 0 ? ret[0] : ret;
    }
  );
  _api_register6("state()", function(set, ignoreTime) {
    if (!set) {
      return this.context.length ? this.context[0].oSavedState : null;
    }
    var setMutate = $15.extend(true, {}, set);
    return this.iterator("table", function(settings) {
      if (ignoreTime !== false) {
        setMutate.time = +/* @__PURE__ */ new Date() + 100;
      }
      _fnImplementState6(settings, setMutate, function() {
      });
    });
  });
  _api_register6("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register6("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register6("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState6(settings);
    });
  });
  DataTable6.use = function(module, type) {
    if (type === "lib" || module.fn) {
      $15 = module;
    } else if (type == "win" || module.document) {
      window = module;
      document = module.document;
    } else if (type === "datetime" || module.type === "DateTime") {
      DataTable6.DateTime = module;
    }
  };
  DataTable6.factory = function(root, jq) {
    var is = false;
    if (root && root.document) {
      window = root;
      document = root.document;
    }
    if (jq && jq.fn && jq.fn.jquery) {
      $15 = jq;
      is = true;
    }
    return is;
  };
  DataTable6.versionCheck = function(version, version2) {
    var aThis = version2 ? version2.split(".") : DataTable6.version.split(".");
    var aThat = version.split(".");
    var iThis, iThat;
    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable6.isDataTable = function(table) {
    var t = $15(table).get(0);
    var is = false;
    if (table instanceof DataTable6.Api) {
      return true;
    }
    $15.each(DataTable6.settings, function(i, o) {
      var head = o.nScrollHead ? $15("table", o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $15("table", o.nScrollFoot)[0] : null;
      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  DataTable6.tables = function(visible) {
    var api = false;
    if ($15.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a = DataTable6.settings.filter(function(o) {
      return !visible || visible && $15(o.nTable).is(":visible") ? true : false;
    }).map(function(o) {
      return o.nTable;
    });
    return api ? new _Api6(a) : a;
  };
  DataTable6.camelToHungarian = _fnCamelToHungarian6;
  _api_register6("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $15(rows);
    return $15([].concat(
      jqRows.filter(selector).toArray(),
      jqRows.find(selector).toArray()
    ));
  });
  $15.each(["on", "one", "off"], function(i, key) {
    _api_register6(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      args[0] = args[0].split(/\s/).map(function(e) {
        return !e.match(/\.dt\b/) ? e + ".dt" : e;
      }).join(" ");
      var inst = $15(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register6("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable6(settings);
    });
  });
  _api_register6("error()", function(msg) {
    return this.iterator("table", function(settings) {
      _fnLog6(settings, 0, msg);
    });
  });
  _api_register6("settings()", function() {
    return new _Api6(this.context, this.context);
  });
  _api_register6("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register6("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck6(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register6("trigger()", function(name, args, bubbles) {
    return this.iterator("table", function(settings) {
      return _fnCallbackFire6(settings, null, name, args, bubbles);
    }).flatten();
  });
  _api_register6("ready()", function(fn) {
    var ctx = this.context;
    if (!fn) {
      return ctx.length ? ctx[0]._bInitComplete || false : null;
    }
    return this.tables().every(function() {
      if (this.context[0]._bInitComplete) {
        fn.call(this);
      } else {
        this.on("init", function() {
          fn.call(this);
        });
      }
    });
  });
  _api_register6("destroy()", function(remove) {
    remove = remove || false;
    return this.iterator("table", function(settings) {
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $15(table);
      var jqTbody = $15(tbody);
      var jqWrapper = $15(settings.nTableWrapper);
      var rows = settings.aoData.map(function(r) {
        return r ? r.nTr : null;
      });
      var orderClasses = classes.order;
      settings.bDestroying = true;
      _fnCallbackFire6(settings, "aoDestroyCallback", "destroy", [settings], true);
      if (!remove) {
        new _Api6(settings).columns().visible(true);
      }
      jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
      $15(window).off(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.colgroup.remove();
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses6(settings);
      $15("th, td", thead).removeClass(
        orderClasses.canAsc + " " + orderClasses.canDesc + " " + orderClasses.isAsc + " " + orderClasses.isDesc
      ).css("width", "");
      jqTbody.children().detach();
      jqTbody.append(rows);
      var orig = settings.nTableWrapper.parentNode;
      var insertBefore = settings.nTableWrapper.nextSibling;
      var removedMethod = remove ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove && orig) {
        orig.insertBefore(table, insertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.table);
      }
      var idx = DataTable6.settings.indexOf(settings);
      if (idx !== -1) {
        DataTable6.settings.splice(idx, 1);
      }
    });
  });
  $15.each(["column", "row", "cell"], function(i, type) {
    _api_register6(type + "s().every()", function(fn) {
      var opts = this.selector.opts;
      var api = this;
      var inst;
      var counter = 0;
      return this.iterator("every", function(settings, selectedIdx, tableIdx) {
        inst = api[type](selectedIdx, opts);
        if (type === "cell") {
          fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
        } else {
          fn.call(inst, selectedIdx, tableIdx, counter);
        }
        counter++;
      });
    });
  });
  _api_register6("i18n()", function(token, def, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn6(token)(ctx.oLanguage);
    if (resolved === void 0) {
      resolved = def;
    }
    if ($15.isPlainObject(resolved)) {
      resolved = plural !== void 0 && resolved[plural] !== void 0 ? resolved[plural] : resolved._;
    }
    return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
  });
  DataTable6.version = "2.0.5";
  DataTable6.settings = [];
  DataTable6.models = {};
  DataTable6.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     */
    "caseInsensitive": true,
    /**
     * Applied search term
     */
    "search": "",
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     */
    "regex": false,
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     */
    "smart": true,
    /**
     * Flag to indicate if DataTables should only trigger a search when
     * the return key is pressed.
     */
    "return": false
  };
  DataTable6.models.oRow = {
    /**
     * TR element for the row
     */
    "nTr": null,
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     */
    "anCells": null,
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     */
    "_aData": [],
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     */
    "_aSortData": null,
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     */
    "_aFilterData": null,
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     */
    "_sFilterRow": null,
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     */
    "src": null,
    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     */
    "idx": -1,
    /**
     * Cached display value
     */
    displayData: null
  };
  DataTable6.models.oColumn = {
    /**
     * Column index.
     */
    "idx": null,
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     */
    "aDataSort": null,
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     */
    "asSorting": null,
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     */
    "bSearchable": null,
    /**
     * Flag to indicate if the column is sortable or not.
     */
    "bSortable": null,
    /**
     * Flag to indicate if the column is currently visible in the table or not
     */
    "bVisible": null,
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     */
    "_sManualType": null,
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     */
    "_bAttrSrc": false,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     */
    "fnGetData": null,
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     */
    "fnSetData": null,
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     */
    "mData": null,
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     */
    "mRender": null,
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     */
    "sClass": null,
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     */
    "sContentPadding": null,
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     */
    "sName": null,
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     */
    "sSortDataType": "std",
    /**
     * Class to be applied to the header element when sorting on this column
     */
    "sSortingClass": null,
    /**
     * Title of the column - what is seen in the TH element (nTh).
     */
    "sTitle": null,
    /**
     * Column sorting and filtering type
     */
    "sType": null,
    /**
     * Width of the column
     */
    "sWidth": null,
    /**
     * Width of the column when it was first "encountered"
     */
    "sWidthOrig": null,
    /** Cached string which is the longest in the column */
    maxLenString: null,
    /**
     * Store for named searches
     */
    searchFixed: null
  };
  DataTable6.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     */
    "aaData": null,
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     */
    "aaSorting": [[0, "asc"]],
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     */
    "aaSortingFixed": [],
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     */
    "ajax": null,
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     */
    "aLengthMenu": [10, 25, 50, 100],
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     */
    "aoColumns": null,
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     */
    "aoColumnDefs": null,
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     */
    "aoSearchCols": [],
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     */
    "bAutoWidth": true,
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     */
    "bDeferRender": true,
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     */
    "bDestroy": false,
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     */
    "bFilter": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bInfo": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bLengthChange": true,
    /**
     * Enable or disable pagination.
     */
    "bPaginate": true,
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     */
    "bProcessing": false,
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     */
    "bRetrieve": false,
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     */
    "bScrollCollapse": false,
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     */
    "bServerSide": false,
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     */
    "bSort": true,
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     */
    "bSortMulti": true,
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     */
    "bSortCellsTop": null,
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     */
    "bSortClasses": true,
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     */
    "bStateSave": false,
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     */
    "fnCreatedRow": null,
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     */
    "fnDrawCallback": null,
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     */
    "fnFooterCallback": null,
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     */
    "fnFormatNumber": function(toFormat) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     */
    "fnHeaderCallback": null,
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     */
    "fnInfoCallback": null,
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     */
    "fnInitComplete": null,
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     */
    "fnPreDrawCallback": null,
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     */
    "fnRowCallback": null,
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateLoadCallback": function(settings) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            "DataTables_" + settings.sInstance + "_" + location.pathname
          )
        );
      } catch (e) {
        return {};
      }
    },
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     */
    "fnStateLoadParams": null,
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     */
    "fnStateLoaded": null,
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateSaveCallback": function(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname,
          JSON.stringify(data)
        );
      } catch (e) {
      }
    },
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     */
    "fnStateSaveParams": null,
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     */
    "iStateDuration": 7200,
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     */
    "iDisplayLength": 10,
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     */
    "iDisplayStart": 0,
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     */
    "iTabIndex": 0,
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     */
    "oClasses": {},
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be sorted
         */
        "orderable": ": Activate to sort",
        /**
         * ARIA label that is added to the table headers when the column is currently being sorted
         */
        "orderableReverse": ": Activate to invert sorting",
        /**
         * ARIA label that is added to the table headers when the column is currently being 
         * sorted and next step is to remove sorting
         */
        "orderableRemove": ": Activate to remove sorting",
        paginate: {
          first: "First",
          last: "Last",
          next: "Next",
          previous: "Previous"
        }
      },
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       */
      "oPaginate": {
        /**
         * Label and character for first page button ()
         */
        "sFirst": "\xAB",
        /**
         * Last page button ()
         */
        "sLast": "\xBB",
        /**
         * Next page button ()
         */
        "sNext": "\u203A",
        /**
         * Previous page button ()
         */
        "sPrevious": "\u2039"
      },
      /**
       * Plural object for the data type the table is showing
       */
      entries: {
        _: "entries",
        1: "entry"
      },
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       */
      "sEmptyTable": "No data available in table",
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       */
      "sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       */
      "sInfoPostFix": "",
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       */
      "sDecimal": "",
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       */
      "sThousands": ",",
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       */
      "sLengthMenu": "_MENU_ _ENTRIES_ per page",
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       */
      "sLoadingRecords": "Loading...",
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       */
      "sProcessing": "",
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       */
      "sSearch": "Search:",
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       */
      "sUrl": "",
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       */
      "sZeroRecords": "No matching records found"
    },
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     */
    "oSearch": $15.extend({}, DataTable6.models.oSearch),
    /**
     * Table and control layout. This replaces the legacy `dom` option.
     */
    layout: {
      topStart: "pageLength",
      topEnd: "search",
      bottomStart: "info",
      bottomEnd: "paging"
    },
    /**
     * Legacy DOM layout option
     */
    "sDom": null,
    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     */
    "searchDelay": null,
    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     */
    "sPaginationType": "full_numbers",
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     */
    "sScrollX": "",
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     */
    "sScrollXInner": "",
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     */
    "sScrollY": "",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     */
    "sServerMethod": "GET",
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     */
    "renderer": null,
    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     */
    "rowId": "DT_RowId",
    /**
     * Caption value
     */
    "caption": null
  };
  _fnHungarianMap6(DataTable6.defaults);
  DataTable6.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     */
    "aDataSort": null,
    "iDataSort": -1,
    ariaTitle: "",
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     */
    "asSorting": ["asc", "desc", ""],
    /**
     * Enable or disable filtering on the data in this column.
     */
    "bSearchable": true,
    /**
     * Enable or disable ordering on this column.
     */
    "bSortable": true,
    /**
     * Enable or disable the display of this column.
     */
    "bVisible": true,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     */
    "mData": null,
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     */
    "mRender": null,
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     */
    "sCellType": "td",
    /**
     * Class to give to each cell in this column.
     */
    "sClass": "",
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     */
    "sContentPadding": "",
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     */
    "sName": "",
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     */
    "sSortDataType": "std",
    /**
     * The title of this column.
     */
    "sTitle": null,
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     */
    "sType": null,
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     */
    "sWidth": null
  };
  _fnHungarianMap6(DataTable6.defaults.column);
  DataTable6.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bAutoWidth": null,
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all for DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bDeferRender": null,
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bFilter": null,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bInfo": true,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bLengthChange": true,
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bPaginate": null,
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bProcessing": null,
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bServerSide": null,
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSort": null,
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortMulti": null,
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortClasses": null,
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bStateSave": null
    },
    /**
     * Scrolling settings for a table.
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bCollapse": null,
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       */
      "iBarWidth": 0,
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sX": null,
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @deprecated
       */
      "sXInner": null,
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sY": null
    },
    /**
     * Language information for the table.
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       */
      "fnInfoCallback": null
    },
    /**
     * Browser support parameters
     */
    "oBrowser": {
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       */
      "bScrollbarLeft": false,
      /**
       * Browser scrollbar width
       */
      "barWidth": 0
    },
    "ajax": null,
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     */
    "aanFeatures": [],
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     */
    "aoData": [],
    /**
     * Array of indexes which are in the current display (after filtering etc)
     */
    "aiDisplay": [],
    /**
     * Array of indexes for display - no filtering
     */
    "aiDisplayMaster": [],
    /**
     * Map of row ids to data indexes
     */
    "aIds": {},
    /**
     * Store information about each column that is in use
     */
    "aoColumns": [],
    /**
     * Store information about the table's header
     */
    "aoHeader": [],
    /**
     * Store information about the table's footer
     */
    "aoFooter": [],
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "oPreviousSearch": {},
    /**
     * Store for named searches
     */
    searchFixed: {},
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     */
    "aoPreSearchCols": [],
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSorting": null,
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSortingFixed": [],
    /**
     * If restoring a table - we should restore its width
     */
    "sDestroyWidth": 0,
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     */
    "aoRowCallback": [],
    /**
     * Callback functions for the header on each draw.
     */
    "aoHeaderCallback": [],
    /**
     * Callback function for the footer on each draw.
     */
    "aoFooterCallback": [],
    /**
     * Array of callback functions for draw callback functions
     */
    "aoDrawCallback": [],
    /**
     * Array of callback functions for row created function
     */
    "aoRowCreatedCallback": [],
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     */
    "aoPreDrawCallback": [],
    /**
     * Callback functions for when the table has been initialised.
     */
    "aoInitComplete": [],
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     */
    "aoStateSaveParams": [],
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     */
    "aoStateLoadParams": [],
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     */
    "aoStateLoaded": [],
    /**
     * Cache the table ID for quick access
     */
    "sTableId": "",
    /**
     * The TABLE node for the main table
     */
    "nTable": null,
    /**
     * Permanent ref to the thead element
     */
    "nTHead": null,
    /**
     * Permanent ref to the tfoot element - if it exists
     */
    "nTFoot": null,
    /**
     * Permanent ref to the tbody element
     */
    "nTBody": null,
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     */
    "nTableWrapper": null,
    /**
     * Indicate if all required information has been read in
     */
    "bInitialised": false,
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     */
    "aoOpenRows": [],
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sDom": null,
    /**
     * Search delay (in mS)
     */
    "searchDelay": null,
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sPaginationType": "two_button",
    /**
     * Number of paging controls on the page. Only used for backwards compatibility
     */
    pagingControls: 0,
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "iStateDuration": 0,
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateSave": [],
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateLoad": [],
    /**
     * State that was saved. Useful for back reference
     */
    "oSavedState": null,
    /**
     * State that was loaded. Useful for back reference
     */
    "oLoadedState": null,
    /**
     * Note if draw should be blocked while getting data
     */
    "bAjaxDataGet": true,
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     */
    "jqXHR": null,
    /**
     * JSON returned from the server in the last Ajax request
     */
    "json": void 0,
    /**
     * Data submitted as part of the last Ajax request
     */
    "oAjaxData": void 0,
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sServerMethod": null,
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "fnFormatNumber": null,
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aLengthMenu": null,
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     */
    "iDraw": 0,
    /**
     * Indicate if a redraw is being done - useful for Ajax
     */
    "bDrawing": false,
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     */
    "iDrawError": -1,
    /**
     * Paging display length
     */
    "_iDisplayLength": 10,
    /**
     * Paging start point - aiDisplay index
     */
    "_iDisplayStart": 0,
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsTotal": 0,
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsDisplay": 0,
    /**
     * The classes to use for the table
     */
    "oClasses": {},
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bFiltered": false,
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bSorted": false,
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSortCellsTop": null,
    /**
     * Initialisation object that is used for the table
     */
    "oInit": null,
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     */
    "aoDestroyCallback": [],
    /**
     * Get the number of records in the current record set, before filtering
     */
    "fnRecordsTotal": function() {
      return _fnDataSource6(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },
    /**
     * Get the number of records in the current record set, after filtering
     */
    "fnRecordsDisplay": function() {
      return _fnDataSource6(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },
    /**
     * Get the display end point - aiDisplay index
     */
    "fnDisplayEnd": function() {
      var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },
    /**
     * The DataTables object for this table
     */
    "oInstance": null,
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     */
    "sInstance": null,
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
    /**
     * Last applied sort
     */
    "aLastSort": [],
    /**
     * Stored plug-in instances
     */
    "oPlugins": {},
    /**
     * Function used to get a row's id from the row's data
     */
    "rowIdFn": null,
    /**
     * Data location where to store a row's id
     */
    "rowId": null,
    caption: "",
    captionNode: null,
    colgroup: null
  };
  var extPagination6 = DataTable6.ext.pager;
  $15.extend(extPagination6, {
    simple: function() {
      return ["previous", "next"];
    },
    full: function() {
      return ["first", "previous", "next", "last"];
    },
    numbers: function() {
      return ["numbers"];
    },
    simple_numbers: function() {
      return ["previous", "numbers", "next"];
    },
    full_numbers: function() {
      return ["first", "previous", "numbers", "next", "last"];
    },
    first_last: function() {
      return ["first", "last"];
    },
    first_last_numbers: function() {
      return ["first", "numbers", "last"];
    },
    // For testing and plug-ins to use
    _numbers: _pagingNumbers6,
    // Number of number buttons - legacy, use `numbers` option for paging feature
    numbers_length: 7
  });
  $15.extend(true, DataTable6.ext.renderer, {
    pagingButton: {
      _: function(settings, buttonType, content, active, disabled) {
        var classes = settings.oClasses.paging;
        var btnClasses = [classes.button];
        var btn;
        if (active) {
          btnClasses.push(classes.active);
        }
        if (disabled) {
          btnClasses.push(classes.disabled);
        }
        if (buttonType === "ellipsis") {
          btn = $15('<span class="ellipsis"></span>').html(content)[0];
        } else {
          btn = $15("<button>", {
            class: btnClasses.join(" "),
            role: "link",
            type: "button"
          }).html(content);
        }
        return {
          display: btn,
          clicker: btn
        };
      }
    },
    pagingContainer: {
      _: function(settings, buttons) {
        return buttons;
      }
    }
  });
  var _filterString6 = function(stripHtml, normalize) {
    return function(str) {
      if (_empty6(str) || typeof str !== "string") {
        return str;
      }
      str = str.replace(_re_new_lines6, " ");
      if (stripHtml) {
        str = _stripHtml6(str);
      }
      if (normalize) {
        str = _normalize6(str, false);
      }
      return str;
    };
  };
  function __mldFnName5(name) {
    return name.replace(/[\W]/g, "_");
  }
  function __mld6(dt, momentFn, luxonFn, dateFn, arg1) {
    if (window.moment) {
      return dt[momentFn](arg1);
    } else if (window.luxon) {
      return dt[luxonFn](arg1);
    }
    return dateFn ? dt[dateFn](arg1) : dt;
  }
  var __mlWarning6 = false;
  function __mldObj6(d, format, locale) {
    var dt;
    if (window.moment) {
      dt = window.moment.utc(d, format, locale, true);
      if (!dt.isValid()) {
        return null;
      }
    } else if (window.luxon) {
      dt = format && typeof d === "string" ? window.luxon.DateTime.fromFormat(d, format) : window.luxon.DateTime.fromISO(d);
      if (!dt.isValid) {
        return null;
      }
      dt.setLocale(locale);
    } else if (!format) {
      dt = new Date(d);
    } else {
      if (!__mlWarning6) {
        alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
      }
      __mlWarning6 = true;
    }
    return dt;
  }
  function __mlHelper6(localeString) {
    return function(from, to, locale, def) {
      if (arguments.length === 0) {
        locale = "en";
        to = null;
        from = null;
      } else if (arguments.length === 1) {
        locale = "en";
        to = from;
        from = null;
      } else if (arguments.length === 2) {
        locale = to;
        to = from;
        from = null;
      }
      var typeName = "datetime" + (to ? "-" + __mldFnName5(to) : "");
      if (!DataTable6.ext.type.order[typeName]) {
        DataTable6.type(typeName, {
          detect: function(d) {
            return d === typeName ? typeName : false;
          },
          order: {
            pre: function(d) {
              return d.valueOf();
            }
          },
          className: "dt-right"
        });
      }
      return function(d, type) {
        if (d === null || d === void 0) {
          if (def === "--now") {
            var local = /* @__PURE__ */ new Date();
            d = new Date(Date.UTC(
              local.getFullYear(),
              local.getMonth(),
              local.getDate(),
              local.getHours(),
              local.getMinutes(),
              local.getSeconds()
            ));
          } else {
            d = "";
          }
        }
        if (type === "type") {
          return typeName;
        }
        if (d === "") {
          return type !== "sort" ? "" : __mldObj6("0000-01-01 00:00:00", null, locale);
        }
        if (to !== null && from === to && type !== "sort" && type !== "type" && !(d instanceof Date)) {
          return d;
        }
        var dt = __mldObj6(d, from, locale);
        if (dt === null) {
          return d;
        }
        if (type === "sort") {
          return dt;
        }
        var formatted = to === null ? __mld6(dt, "toDate", "toJSDate", "")[localeString]() : __mld6(dt, "format", "toFormat", "toISOString", to);
        return type === "display" ? _escapeHtml6(formatted) : formatted;
      };
    };
  }
  var __thousands6 = ",";
  var __decimal6 = ".";
  if (window.Intl !== void 0) {
    try {
      num = new Intl.NumberFormat().formatToParts(100000.1);
      for (i = 0; i < num.length; i++) {
        if (num[i].type === "group") {
          __thousands6 = num[i].value;
        } else if (num[i].type === "decimal") {
          __decimal6 = num[i].value;
        }
      }
    } catch (e) {
    }
  }
  var num;
  var i;
  DataTable6.datetime = function(format, locale) {
    var typeName = "datetime-detect-" + __mldFnName5(format);
    if (!locale) {
      locale = "en";
    }
    if (!DataTable6.ext.type.order[typeName]) {
      DataTable6.type(typeName, {
        detect: function(d) {
          var dt = __mldObj6(d, format, locale);
          return d === "" || dt ? typeName : false;
        },
        order: {
          pre: function(d) {
            return __mldObj6(d, format, locale) || 0;
          }
        },
        className: "dt-right"
      });
    }
  };
  DataTable6.render = {
    date: __mlHelper6("toLocaleDateString"),
    datetime: __mlHelper6("toLocaleString"),
    time: __mlHelper6("toLocaleTimeString"),
    number: function(thousands, decimal, precision, prefix, postfix) {
      if (thousands === null || thousands === void 0) {
        thousands = __thousands6;
      }
      if (decimal === null || decimal === void 0) {
        decimal = __decimal6;
      }
      return {
        display: function(d) {
          if (typeof d !== "number" && typeof d !== "string") {
            return d;
          }
          if (d === "" || d === null) {
            return d;
          }
          var negative = d < 0 ? "-" : "";
          var flo = parseFloat(d);
          var abs = Math.abs(flo);
          if (abs >= 1e11 || abs < 1e-4 && abs !== 0) {
            var exp = flo.toExponential(precision).split(/e\+?/);
            return exp[0] + " x 10<sup>" + exp[1] + "</sup>";
          }
          if (isNaN(flo)) {
            return _escapeHtml6(d);
          }
          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
          if (intPart === 0 && parseFloat(floatPart) === 0) {
            negative = "";
          }
          return negative + (prefix || "") + intPart.toString().replace(
            /\B(?=(\d{3})+(?!\d))/g,
            thousands
          ) + floatPart + (postfix || "");
        }
      };
    },
    text: function() {
      return {
        display: _escapeHtml6,
        filter: _escapeHtml6
      };
    }
  };
  var _extTypes6 = DataTable6.ext.type;
  DataTable6.type = function(name, prop, val) {
    if (!prop) {
      return {
        className: _extTypes6.className[name],
        detect: _extTypes6.detect.find(function(fn) {
          return fn.name === name;
        }),
        order: {
          pre: _extTypes6.order[name + "-pre"],
          asc: _extTypes6.order[name + "-asc"],
          desc: _extTypes6.order[name + "-desc"]
        },
        render: _extTypes6.render[name],
        search: _extTypes6.search[name]
      };
    }
    var setProp = function(prop2, propVal) {
      _extTypes6[prop2][name] = propVal;
    };
    var setDetect = function(fn) {
      var cb = function(d, s) {
        var ret = fn(d, s);
        return ret === true ? name : ret;
      };
      Object.defineProperty(cb, "name", { value: name });
      var idx = _extTypes6.detect.findIndex(function(fn2) {
        return fn2.name === name;
      });
      if (idx === -1) {
        _extTypes6.detect.unshift(cb);
      } else {
        _extTypes6.detect.splice(idx, 1, cb);
      }
    };
    var setOrder = function(obj) {
      _extTypes6.order[name + "-pre"] = obj.pre;
      _extTypes6.order[name + "-asc"] = obj.asc;
      _extTypes6.order[name + "-desc"] = obj.desc;
    };
    if (val === void 0) {
      val = prop;
      prop = null;
    }
    if (prop === "className") {
      setProp("className", val);
    } else if (prop === "detect") {
      setDetect(val);
    } else if (prop === "order") {
      setOrder(val);
    } else if (prop === "render") {
      setProp("render", val);
    } else if (prop === "search") {
      setProp("search", val);
    } else if (!prop) {
      if (val.className) {
        setProp("className", val.className);
      }
      if (val.detect !== void 0) {
        setDetect(val.detect);
      }
      if (val.order) {
        setOrder(val.order);
      }
      if (val.render !== void 0) {
        setProp("render", val.render);
      }
      if (val.search !== void 0) {
        setProp("search", val.search);
      }
    }
  };
  DataTable6.types = function() {
    return _extTypes6.detect.map(function(fn) {
      return fn.name;
    });
  };
  DataTable6.type("string", {
    detect: function() {
      return "string";
    },
    order: {
      pre: function(a) {
        return _empty6(a) ? "" : typeof a === "string" ? a.toLowerCase() : !a.toString ? "" : a.toString();
      }
    },
    search: _filterString6(false, true)
  });
  DataTable6.type("html", {
    detect: function(d) {
      return _empty6(d) || typeof d === "string" && d.indexOf("<") !== -1 ? "html" : null;
    },
    order: {
      pre: function(a) {
        return _empty6(a) ? "" : a.replace ? _stripHtml6(a).trim().toLowerCase() : a + "";
      }
    },
    search: _filterString6(true, true)
  });
  DataTable6.type("date", {
    className: "dt-type-date",
    detect: function(d) {
      if (d && !(d instanceof Date) && !_re_date6.test(d)) {
        return null;
      }
      var parsed = Date.parse(d);
      return parsed !== null && !isNaN(parsed) || _empty6(d) ? "date" : null;
    },
    order: {
      pre: function(d) {
        var ts = Date.parse(d);
        return isNaN(ts) ? -Infinity : ts;
      }
    }
  });
  DataTable6.type("html-num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric6(d, decimal, true) ? "html-num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace6(d, dp, _re_html6, _re_formatted_numeric6);
      }
    },
    search: _filterString6(true, true)
  });
  DataTable6.type("html-num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric6(d, decimal) ? "html-num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace6(d, dp, _re_html6);
      }
    },
    search: _filterString6(true, true)
  });
  DataTable6.type("num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber6(d, decimal, true) ? "num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace6(d, dp, _re_formatted_numeric6);
      }
    }
  });
  DataTable6.type("num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber6(d, decimal) ? "num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace6(d, dp);
      }
    }
  });
  var __numericReplace6 = function(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === "-")) {
      return -Infinity;
    }
    var type = typeof d;
    if (type === "number" || type === "bigint") {
      return d;
    }
    if (decimalPlace) {
      d = _numToDecimal6(d, decimalPlace);
    }
    if (d.replace) {
      if (re1) {
        d = d.replace(re1, "");
      }
      if (re2) {
        d = d.replace(re2, "");
      }
    }
    return d * 1;
  };
  $15.extend(true, DataTable6.ext.renderer, {
    footer: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.tfoot.cell);
      }
    },
    header: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.thead.cell);
        if (!settings.oFeatures.bSort) {
          cell.addClass(classes.order.none);
        }
        var legacyTop = settings.bSortCellsTop;
        var headerRows = cell.closest("thead").find("tr");
        var rowIdx = cell.parent().index();
        if (
          // Cells and rows which have the attribute to disable the icons
          cell.attr("data-dt-order") === "disable" || cell.parent().attr("data-dt-order") === "disable" || // Legacy support for `orderCellsTop`. If it is set, then cells
          // which are not in the top or bottom row of the header (depending
          // on the value) do not get the sorting classes applied to them
          legacyTop === true && rowIdx !== 0 || legacyTop === false && rowIdx !== headerRows.length - 1
        ) {
          return;
        }
        $15(settings.nTable).on("order.dt.DT", function(e, ctx, sorting) {
          if (settings !== ctx) {
            return;
          }
          var orderClasses = classes.order;
          var columns = ctx.api.columns(cell);
          var col = settings.aoColumns[columns.flatten()[0]];
          var orderable = columns.orderable().includes(true);
          var ariaType = "";
          var indexes = columns.indexes();
          var sortDirs = columns.orderable(true).flatten();
          var orderedColumns = "," + sorting.map(function(val) {
            return val.col;
          }).join(",") + ",";
          cell.removeClass(
            orderClasses.isAsc + " " + orderClasses.isDesc
          ).toggleClass(orderClasses.none, !orderable).toggleClass(orderClasses.canAsc, orderable && sortDirs.includes("asc")).toggleClass(orderClasses.canDesc, orderable && sortDirs.includes("desc"));
          var sortIdx = orderedColumns.indexOf("," + indexes.toArray().join(",") + ",");
          if (sortIdx !== -1) {
            var orderDirs = columns.order();
            cell.addClass(
              orderDirs.includes("asc") ? orderClasses.isAsc : "" + orderDirs.includes("desc") ? orderClasses.isDesc : ""
            );
          }
          if (sortIdx === 0) {
            var firstSort = sorting[0];
            var sortOrder = col.asSorting;
            cell.attr("aria-sort", firstSort.dir === "asc" ? "ascending" : "descending");
            ariaType = !sortOrder[firstSort.index + 1] ? "Remove" : "Reverse";
          } else {
            cell.removeAttr("aria-sort");
          }
          cell.attr(
            "aria-label",
            orderable ? col.ariaTitle + ctx.api.i18n("oAria.orderable" + ariaType) : col.ariaTitle
          );
          if (orderable) {
            cell.find(".dt-column-title").attr("role", "button");
            cell.attr("tabindex", 0);
          }
        });
      }
    },
    layout: {
      _: function(settings, container, items) {
        var row = $15("<div/>").addClass("dt-layout-row").appendTo(container);
        $15.each(items, function(key, val) {
          var klass = !val.table ? "dt-" + key + " " : "";
          if (val.table) {
            row.addClass("dt-layout-table");
          }
          $15("<div/>").attr({
            id: val.id || null,
            "class": "dt-layout-cell " + klass + (val.className || "")
          }).append(val.contents).appendTo(row);
        });
      }
    }
  });
  DataTable6.feature = {};
  DataTable6.feature.register = function(name, cb, legacy) {
    DataTable6.ext.features[name] = cb;
    if (legacy) {
      _ext6.feature.push({
        cFeature: legacy,
        fnInit: cb
      });
    }
  };
  DataTable6.feature.register("info", function(settings, opts) {
    if (!settings.oFeatures.bInfo) {
      return null;
    }
    var lang = settings.oLanguage, tid = settings.sTableId, n = $15("<div/>", {
      "class": settings.oClasses.info.container
    });
    opts = $15.extend({
      callback: lang.fnInfoCallback,
      empty: lang.sInfoEmpty,
      postfix: lang.sInfoPostFix,
      search: lang.sInfoFiltered,
      text: lang.sInfo
    }, opts);
    settings.aoDrawCallback.push(function(s) {
      _fnUpdateInfo6(s, opts, n);
    });
    if (!settings._infoEl) {
      n.attr({
        "aria-live": "polite",
        id: tid + "_info",
        role: "status"
      });
      $15(settings.nTable).attr("aria-describedby", tid + "_info");
      settings._infoEl = n;
    }
    return n;
  }, "i");
  function _fnUpdateInfo6(settings, opts, node) {
    var start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? opts.text : opts.empty;
    if (total !== max) {
      out += " " + opts.search;
    }
    out += opts.postfix;
    out = _fnMacros6(settings, out);
    if (opts.callback) {
      out = opts.callback.call(
        settings.oInstance,
        settings,
        start,
        end,
        max,
        total,
        out
      );
    }
    node.html(out);
    _fnCallbackFire6(settings, null, "info", [settings, node[0], out]);
  }
  var __searchCounter6 = 0;
  DataTable6.feature.register("search", function(settings, opts) {
    if (!settings.oFeatures.bFilter) {
      return null;
    }
    var classes = settings.oClasses.search;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var input = '<input type="search" class="' + classes.input + '"/>';
    opts = $15.extend({
      placeholder: language.sSearchPlaceholder,
      text: language.sSearch
    }, opts);
    if (opts.text.indexOf("_INPUT_") === -1) {
      opts.text += "_INPUT_";
    }
    opts.text = _fnMacros6(settings, opts.text);
    var end = opts.text.match(/_INPUT_$/);
    var start = opts.text.match(/^_INPUT_/);
    var removed = opts.text.replace(/_INPUT_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_INPUT_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_INPUT_";
    }
    var filter = $15("<div>").addClass(classes.container).append(str.replace(/_INPUT_/, input));
    filter.find("label").attr("for", "dt-search-" + __searchCounter6);
    filter.find("input").attr("id", "dt-search-" + __searchCounter6);
    __searchCounter6++;
    var searchFn = function(event) {
      var val = this.value;
      if (previousSearch.return && event.key !== "Enter") {
        return;
      }
      if (val != previousSearch.search) {
        previousSearch.search = val;
        _fnFilterComplete6(settings, previousSearch);
        settings._iDisplayStart = 0;
        _fnDraw6(settings);
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : 0;
    var jqFilter = $15("input", filter).val(previousSearch.search).attr("placeholder", opts.placeholder).on(
      "keyup.DT search.DT input.DT paste.DT cut.DT",
      searchDelay ? DataTable6.util.debounce(searchFn, searchDelay) : searchFn
    ).on("mouseup.DT", function(e) {
      setTimeout(function() {
        searchFn.call(jqFilter[0], e);
      }, 10);
    }).on("keypress.DT", function(e) {
      if (e.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $15(settings.nTable).on("search.dt.DT", function(ev, s) {
      if (settings === s && jqFilter[0] !== document.activeElement) {
        jqFilter.val(
          typeof previousSearch.search !== "function" ? previousSearch.search : ""
        );
      }
    });
    return filter;
  }, "f");
  DataTable6.feature.register("paging", function(settings, opts) {
    if (!settings.oFeatures.bPaginate) {
      return null;
    }
    opts = $15.extend({
      buttons: DataTable6.ext.pager.numbers_length,
      type: settings.sPaginationType,
      boundaryNumbers: true
    }, opts);
    if (opts.numbers) {
      opts.buttons = opts.numbers;
    }
    var host = $15("<div/>").addClass(settings.oClasses.paging.container + " paging_" + opts.type);
    var draw = function() {
      _pagingDraw6(settings, host, opts);
    };
    settings.aoDrawCallback.push(draw);
    $15(settings.nTable).on("column-sizing.dt.DT", draw);
    return host;
  }, "p");
  function _pagingDraw6(settings, host, opts) {
    if (!settings._bInitComplete) {
      return;
    }
    var plugin = DataTable6.ext.pager[opts.type], aria = settings.oLanguage.oAria.paginate || {}, start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin().map(function(val) {
      return val === "numbers" ? _pagingNumbers6(page, pages, opts.buttons, opts.boundaryNumbers) : val;
    }).flat();
    var buttonEls = [];
    for (var i = 0; i < buttons.length; i++) {
      var button = buttons[i];
      var btnInfo = _pagingButtonInfo6(settings, button, page, pages);
      var btn = _fnRenderer6(settings, "pagingButton")(
        settings,
        button,
        btnInfo.display,
        btnInfo.active,
        btnInfo.disabled
      );
      $15(btn.clicker).attr({
        "aria-controls": settings.sTableId,
        "aria-disabled": btnInfo.disabled ? "true" : null,
        "aria-current": btnInfo.active ? "page" : null,
        "aria-label": aria[button],
        "data-dt-idx": button,
        "tabIndex": btnInfo.disabled ? -1 : settings.iTabIndex
      });
      if (typeof button !== "number") {
        $15(btn.clicker).addClass(button);
      }
      _fnBindAction6(
        btn.clicker,
        { action: button },
        function(e) {
          e.preventDefault();
          _fnPageChange6(settings, e.data.action, true);
        }
      );
      buttonEls.push(btn.display);
    }
    var wrapped = _fnRenderer6(settings, "pagingContainer")(
      settings,
      buttonEls
    );
    var activeEl = host.find(document.activeElement).data("dt-idx");
    host.empty().append(wrapped);
    if (activeEl !== void 0) {
      host.find("[data-dt-idx=" + activeEl + "]").trigger("focus");
    }
    if (buttonEls.length && // any buttons
    opts.numbers > 1 && // prevent infinite
    $15(host).height() >= $15(buttonEls[0]).outerHeight() * 2 - 10) {
      _pagingDraw6(settings, host, $15.extend({}, opts, { numbers: opts.numbers - 2 }));
    }
  }
  function _pagingButtonInfo6(settings, button, page, pages) {
    var lang = settings.oLanguage.oPaginate;
    var o = {
      display: "",
      active: false,
      disabled: false
    };
    switch (button) {
      case "ellipsis":
        o.display = "&#x2026;";
        o.disabled = true;
        break;
      case "first":
        o.display = lang.sFirst;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "previous":
        o.display = lang.sPrevious;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "next":
        o.display = lang.sNext;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      case "last":
        o.display = lang.sLast;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      default:
        if (typeof button === "number") {
          o.display = settings.fnFormatNumber(button + 1);
          if (page === button) {
            o.active = true;
          }
        }
        break;
    }
    return o;
  }
  function _pagingNumbers6(page, pages, buttons, addFirstLast) {
    var numbers = [], half = Math.floor(buttons / 2), before = addFirstLast ? 2 : 1, after = addFirstLast ? 1 : 0;
    if (pages <= buttons) {
      numbers = _range6(0, pages);
    } else if (buttons === 1) {
      numbers = [page];
    } else if (buttons === 3) {
      if (page <= 1) {
        numbers = [0, 1, "ellipsis"];
      } else if (page >= pages - 2) {
        numbers = _range6(pages - 2, pages);
        numbers.unshift("ellipsis");
      } else {
        numbers = ["ellipsis", page, "ellipsis"];
      }
    } else if (page <= half) {
      numbers = _range6(0, buttons - before);
      numbers.push("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
      }
    } else if (page >= pages - 1 - half) {
      numbers = _range6(pages - (buttons - before), pages);
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.unshift(0);
      }
    } else {
      numbers = _range6(page - half + before, page + half - after);
      numbers.push("ellipsis");
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
        numbers.unshift(0);
      }
    }
    return numbers;
  }
  var __lengthCounter6 = 0;
  DataTable6.feature.register("pageLength", function(settings, opts) {
    var features = settings.oFeatures;
    if (!features.bPaginate || !features.bLengthChange) {
      return null;
    }
    opts = $15.extend({
      menu: settings.aLengthMenu,
      text: settings.oLanguage.sLengthMenu
    }, opts);
    var classes = settings.oClasses.length, tableId = settings.sTableId, menu = opts.menu, lengths = [], language = [], i;
    if (Array.isArray(menu[0])) {
      lengths = menu[0];
      language = menu[1];
    } else {
      for (i = 0; i < menu.length; i++) {
        if ($15.isPlainObject(menu[i])) {
          lengths.push(menu[i].value);
          language.push(menu[i].label);
        } else {
          lengths.push(menu[i]);
          language.push(menu[i]);
        }
      }
    }
    var end = opts.text.match(/_MENU_$/);
    var start = opts.text.match(/^_MENU_/);
    var removed = opts.text.replace(/_MENU_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_MENU_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_MENU_";
    }
    var div = $15("<div/>").addClass(classes.container).append(
      str.replace("_MENU_", "<span></span>")
    );
    var textNodes = [];
    div.find("label")[0].childNodes.forEach(function(el) {
      if (el.nodeType === Node.TEXT_NODE) {
        textNodes.push({
          el,
          text: el.textContent
        });
      }
    });
    var updateEntries = function(len) {
      textNodes.forEach(function(node) {
        node.el.textContent = _fnMacros6(settings, node.text, len);
      });
    };
    var select = $15("<select/>", {
      "name": tableId + "_length",
      "aria-controls": tableId,
      "class": classes.select
    });
    for (i = 0; i < lengths.length; i++) {
      select[0][i] = new Option(
        typeof language[i] === "number" ? settings.fnFormatNumber(language[i]) : language[i],
        lengths[i]
      );
    }
    div.find("label").attr("for", "dt-length-" + __lengthCounter6);
    select.attr("id", "dt-length-" + __lengthCounter6);
    __lengthCounter6++;
    div.find("span").replaceWith(select);
    $15("select", div).val(settings._iDisplayLength).on("change.DT", function() {
      _fnLengthChange6(settings, $15(this).val());
      _fnDraw6(settings);
    });
    $15(settings.nTable).on("length.dt.DT", function(e, s, len) {
      if (settings === s) {
        $15("select", div).val(len);
        updateEntries(len);
      }
    });
    updateEntries(settings._iDisplayLength);
    return div;
  }, "l");
  $15.fn.dataTable = DataTable6;
  DataTable6.$ = $15;
  $15.fn.dataTableSettings = DataTable6.settings;
  $15.fn.dataTableExt = DataTable6.ext;
  $15.fn.DataTable = function(opts) {
    return $15(this).dataTable(opts).api();
  };
  $15.each(DataTable6, function(prop, val) {
    $15.fn.DataTable[prop] = val;
  });
  var dataTables_default6 = DataTable6;

  // node_modules/datatables.net-rowgroup-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs
  var $16 = import_jquery18.default;
  $16.extend(true, dataTables_default6.defaults, {
    renderer: "bootstrap"
  });
  $16.extend(true, dataTables_default6.ext.classes, {
    container: "dt-container dt-bootstrap5",
    search: {
      input: "form-control form-control-sm"
    },
    length: {
      select: "form-select form-select-sm"
    },
    processing: {
      container: "dt-processing card"
    }
  });
  dataTables_default6.ext.renderer.pagingButton.bootstrap = function(settings, buttonType, content, active, disabled) {
    var btnClasses = ["dt-paging-button", "page-item"];
    if (active) {
      btnClasses.push("active");
    }
    if (disabled) {
      btnClasses.push("disabled");
    }
    var li = $16("<li>").addClass(btnClasses.join(" "));
    var a = $16("<a>", {
      "href": disabled ? null : "#",
      "class": "page-link"
    }).html(content).appendTo(li);
    return {
      display: li,
      clicker: a
    };
  };
  dataTables_default6.ext.renderer.pagingContainer.bootstrap = function(settings, buttonEls) {
    return $16("<ul/>").addClass("pagination").append(buttonEls);
  };
  dataTables_default6.ext.renderer.layout.bootstrap = function(settings, container, items) {
    var row = $16("<div/>", {
      "class": items.full ? "row mt-2 justify-content-md-center" : "row mt-2 justify-content-between"
    }).appendTo(container);
    $16.each(items, function(key, val) {
      var klass;
      if (val.table) {
        klass = "col-12";
      } else if (key === "start") {
        klass = "col-md-auto me-auto";
      } else if (key === "end") {
        klass = "col-md-auto ms-auto";
      } else {
        klass = "col-md";
      }
      $16("<div/>", {
        id: val.id || null,
        "class": klass + " " + (val.className || "")
      }).append(val.contents).appendTo(row);
    });
  };

  // node_modules/datatables.net-rowgroup/js/dataTables.rowGroup.mjs
  var import_jquery20 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-rowgroup/node_modules/datatables.net/js/dataTables.mjs
  var import_jquery19 = __toESM(require_jquery(), 1);
  var $17 = import_jquery19.default;
  var DataTable7 = function(selector, options) {
    if (DataTable7.factory(selector, options)) {
      return DataTable7;
    }
    if (this instanceof DataTable7) {
      return $17(selector).DataTable(options);
    } else {
      options = selector;
    }
    var _that = this;
    var emptyInit = options === void 0;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.api = function() {
      return new _Api7(this);
    };
    this.each(function() {
      var o = {};
      var oInit = len > 1 ? (
        // optimisation for single table case
        _fnExtend7(o, options, true)
      ) : options;
      var i = 0, iLen;
      var sId = this.getAttribute("id");
      var bInitHandedOff = false;
      var defaults = DataTable7.defaults;
      var $this = $17(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog7(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      $17(this).trigger("options.dt", oInit);
      _fnCompatOpts7(defaults);
      _fnCompatCols7(defaults.column);
      _fnCamelToHungarian7(defaults, defaults, true);
      _fnCamelToHungarian7(defaults.column, defaults.column, true);
      _fnCamelToHungarian7(defaults, $17.extend(oInit, $this.data()), true);
      var allSettings = DataTable7.settings;
      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            new DataTable7.Api(s).destroy();
            break;
          } else {
            _fnLog7(s, 0, "Cannot reinitialise DataTable", 3);
            return;
          }
        }
        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable7.ext._unique++;
        this.id = sId;
      }
      var oSettings = $17.extend(true, {}, DataTable7.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId,
        colgroup: $17("<colgroup>").prependTo(this),
        fastData: function(row, column, type) {
          return _fnGetCellData7(oSettings, row, column, type);
        }
      });
      oSettings.nTable = this;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.api = new _Api7(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts7(oInit);
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : $17.isPlainObject(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0].value : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend7($17.extend(true, {}, defaults), oInit);
      _fnMap7(oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ]);
      _fnMap7(oSettings, oInit, [
        "ajax",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "iStateDuration",
        "bSortCellsTop",
        "iTabIndex",
        "sDom",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        "caption",
        "layout",
        ["iCookieDuration", "iStateDuration"],
        // backwards compat
        ["oSearch", "oPreviousSearch"],
        ["aoSearchCols", "aoPreSearchCols"],
        ["iDisplayLength", "_iDisplayLength"]
      ]);
      _fnMap7(oSettings.oScroll, oInit, [
        ["sScrollX", "sX"],
        ["sScrollXInner", "sXInner"],
        ["sScrollY", "sY"],
        ["bScrollCollapse", "bCollapse"]
      ]);
      _fnMap7(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg7(oSettings, "aoDrawCallback", oInit.fnDrawCallback);
      _fnCallbackReg7(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams);
      _fnCallbackReg7(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams);
      _fnCallbackReg7(oSettings, "aoStateLoaded", oInit.fnStateLoaded);
      _fnCallbackReg7(oSettings, "aoRowCallback", oInit.fnRowCallback);
      _fnCallbackReg7(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow);
      _fnCallbackReg7(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback);
      _fnCallbackReg7(oSettings, "aoFooterCallback", oInit.fnFooterCallback);
      _fnCallbackReg7(oSettings, "aoInitComplete", oInit.fnInitComplete);
      _fnCallbackReg7(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback);
      oSettings.rowIdFn = _fnGetObjectDataFn7(oInit.rowId);
      _fnBrowserDetect7(oSettings);
      var oClasses = oSettings.oClasses;
      $17.extend(oClasses, DataTable7.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.table);
      if (!oSettings.oFeatures.bPaginate) {
        oInit.iDisplayStart = 0;
      }
      if (oSettings.iInitDisplayStart === void 0) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      var oLanguage = oSettings.oLanguage;
      $17.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl) {
        $17.ajax({
          dataType: "json",
          url: oLanguage.sUrl,
          success: function(json) {
            _fnCamelToHungarian7(defaults.oLanguage, json);
            $17.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
            _fnCallbackFire7(oSettings, null, "i18n", [oSettings], true);
            _fnInitialise7(oSettings);
          },
          error: function() {
            _fnLog7(oSettings, 0, "i18n file loading error", 21);
            _fnInitialise7(oSettings);
          }
        });
        bInitHandedOff = true;
      } else {
        _fnCallbackFire7(oSettings, null, "i18n", [oSettings]);
      }
      var columnsInit = [];
      var thead = this.getElementsByTagName("thead");
      var initHeaderLayout = _fnDetectHeader7(oSettings, thead[0]);
      if (oInit.aoColumns) {
        columnsInit = oInit.aoColumns;
      } else if (initHeaderLayout.length) {
        for (i = 0, iLen = initHeaderLayout[0].length; i < iLen; i++) {
          columnsInit.push(null);
        }
      }
      for (i = 0, iLen = columnsInit.length; i < iLen; i++) {
        _fnAddColumn7(oSettings);
      }
      _fnApplyColumnDefs7(oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function(iCol, oDef) {
        _fnColumnOptions7(oSettings, iCol, oDef);
      });
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if (rowOne.length) {
        var a = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $17(rowOne[0]).children("th, td").each(function(i2, cell) {
          var col = oSettings.aoColumns[i2];
          if (!col) {
            _fnLog7(oSettings, 0, "Incorrect column count", 18);
          }
          if (col.mData === i2) {
            var sort = a(cell, "sort") || a(cell, "order");
            var filter = a(cell, "filter") || a(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {
                _: i2 + ".display",
                sort: sort !== null ? i2 + ".@data-" + sort : void 0,
                type: sort !== null ? i2 + ".@data-" + sort : void 0,
                filter: filter !== null ? i2 + ".@data-" + filter : void 0
              };
              col._isArrayHost = true;
              _fnColumnOptions7(oSettings, i2);
            }
          }
        });
      }
      var features = oSettings.oFeatures;
      var loadedInit = function() {
        if (oInit.aaSorting === void 0) {
          var sorting = oSettings.aaSorting;
          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        _fnSortingClasses7(oSettings);
        _fnCallbackReg7(oSettings, "aoDrawCallback", function() {
          if (oSettings.bSorted || _fnDataSource7(oSettings) === "ssp" || features.bDeferRender) {
            _fnSortingClasses7(oSettings);
          }
        });
        var caption = $this.children("caption");
        if (oSettings.caption) {
          if (caption.length === 0) {
            caption = $17("<caption/>").appendTo($this);
          }
          caption.html(oSettings.caption);
        }
        if (caption.length) {
          caption[0]._captionSide = caption.css("caption-side");
          oSettings.captionNode = caption[0];
        }
        if (thead.length === 0) {
          thead = $17("<thead/>").appendTo($this);
        }
        oSettings.nTHead = thead[0];
        $17("tr", thead).addClass(oClasses.thead.row);
        var tbody = $this.children("tbody");
        if (tbody.length === 0) {
          tbody = $17("<tbody/>").insertAfter(thead);
        }
        oSettings.nTBody = tbody[0];
        var tfoot = $this.children("tfoot");
        if (tfoot.length === 0) {
          tfoot = $17("<tfoot/>").appendTo($this);
        }
        oSettings.nTFoot = tfoot[0];
        $17("tr", tfoot).addClass(oClasses.tfoot.row);
        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData7(oSettings, oInit.aaData[i]);
          }
        } else if (_fnDataSource7(oSettings) == "dom") {
          _fnAddTr7(oSettings, $17(oSettings.nTBody).children("tr"));
        }
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        oSettings.bInitialised = true;
        if (bInitHandedOff === false) {
          _fnInitialise7(oSettings);
        }
      };
      _fnCallbackReg7(oSettings, "aoDrawCallback", _fnSaveState7);
      if (oInit.bStateSave) {
        features.bStateSave = true;
        _fnLoadState7(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  DataTable7.ext = _ext7 = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",
    /**
     * Legacy so v1 plug-ins don't throw js errors on load
     */
    feature: [],
    /**
     * Feature plug-ins.
     * 
     * This is an object of callbacks which provide the features for DataTables
     * to be initialised via the `layout` option.
     */
    features: {},
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Automatic column class assignment
       */
      className: {},
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
      /**
       * Automatic renderer assignment
       */
      render: {},
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatibility only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable7.fnVersionCheck,
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable7.version
  };
  $17.extend(_ext7, {
    afnFiltering: _ext7.search,
    aTypes: _ext7.type.detect,
    ofnSearch: _ext7.type.search,
    oSort: _ext7.type.order,
    afnSortData: _ext7.order,
    aoFeatures: _ext7.feature,
    oStdClasses: _ext7.classes,
    oPagination: _ext7.pager
  });
  $17.extend(DataTable7.ext.classes, {
    container: "dt-container",
    empty: {
      row: "dt-empty"
    },
    info: {
      container: "dt-info"
    },
    length: {
      container: "dt-length",
      select: "dt-input"
    },
    order: {
      canAsc: "dt-orderable-asc",
      canDesc: "dt-orderable-desc",
      isAsc: "dt-ordering-asc",
      isDesc: "dt-ordering-desc",
      none: "dt-orderable-none",
      position: "sorting_"
    },
    processing: {
      container: "dt-processing"
    },
    scrolling: {
      body: "dt-scroll-body",
      container: "dt-scroll",
      footer: {
        self: "dt-scroll-foot",
        inner: "dt-scroll-footInner"
      },
      header: {
        self: "dt-scroll-head",
        inner: "dt-scroll-headInner"
      }
    },
    search: {
      container: "dt-search",
      input: "dt-input"
    },
    table: "dataTable",
    tbody: {
      cell: "",
      row: ""
    },
    thead: {
      cell: "",
      row: ""
    },
    tfoot: {
      cell: "",
      row: ""
    },
    paging: {
      active: "current",
      button: "dt-paging-button",
      container: "dt-paging",
      disabled: "disabled"
    }
  });
  var _ext7;
  var _Api7;
  var _api_register7;
  var _api_registerPlural7;
  var _re_dic7 = {};
  var _re_new_lines7 = /[\r\n\u2028]/g;
  var _re_html7 = /<([^>]*>)/g;
  var _max_str_len7 = Math.pow(2, 28);
  var _re_date7 = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;
  var _re_escape_regex7 = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric7 = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty7 = function(d) {
    return !d || d === true || d === "-" ? true : false;
  };
  var _intVal7 = function(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  var _numToDecimal7 = function(num, decimalPoint) {
    if (!_re_dic7[decimalPoint]) {
      _re_dic7[decimalPoint] = new RegExp(_fnEscapeRegex7(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic7[decimalPoint], ".") : num;
  };
  var _isNumber7 = function(d, decimalPoint, formatted) {
    var type = typeof d;
    var strType = type === "string";
    if (type === "number" || type === "bigint") {
      return true;
    }
    if (_empty7(d)) {
      return true;
    }
    if (decimalPoint && strType) {
      d = _numToDecimal7(d, decimalPoint);
    }
    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric7, "");
    }
    return !isNaN(parseFloat(d)) && isFinite(d);
  };
  var _isHtml7 = function(d) {
    return _empty7(d) || typeof d === "string";
  };
  var _htmlNumeric7 = function(d, decimalPoint, formatted) {
    if (_empty7(d)) {
      return true;
    }
    if (typeof d === "string" && d.match(/<(input|select)/i)) {
      return null;
    }
    var html = _isHtml7(d);
    return !html ? null : _isNumber7(_stripHtml7(d), decimalPoint, formatted) ? true : null;
  };
  var _pluck7 = function(a, prop, prop2) {
    var out = [];
    var i = 0, ien = a.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order7 = function(a, order, prop, prop2) {
    var out = [];
    var i = 0, ien = order.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[order[i]]) {
          out.push(a[order[i]][prop]);
        }
      }
    }
    return out;
  };
  var _range7 = function(len, start) {
    var out = [];
    var end;
    if (start === void 0) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }
    for (var i = start; i < end; i++) {
      out.push(i);
    }
    return out;
  };
  var _removeEmpty7 = function(a) {
    var out = [];
    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        out.push(a[i]);
      }
    }
    return out;
  };
  var _stripHtml7 = function(input) {
    if (input.length > _max_str_len7) {
      throw new Error("Exceeded max str len");
    }
    var previous;
    input = input.replace(_re_html7, "");
    do {
      previous = input;
      input = input.replace(/<script/i, "");
    } while (input !== previous);
    return previous;
  };
  var _escapeHtml7 = function(d) {
    if (Array.isArray(d)) {
      d = d.join(",");
    }
    return typeof d === "string" ? d.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d;
  };
  var _normalize7 = function(str, both) {
    if (typeof str !== "string") {
      return str;
    }
    var res = str.normalize("NFD");
    return res.length !== str.length ? (both === true ? str + " " : "") + res.replace(/[\u0300-\u036f]/g, "") : res;
  };
  var _areAllUnique7 = function(src) {
    if (src.length < 2) {
      return true;
    }
    var sorted = src.slice().sort();
    var last = sorted[0];
    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }
      last = sorted[i];
    }
    return true;
  };
  var _unique7 = function(src) {
    if (Array.from && Set) {
      return Array.from(new Set(src));
    }
    if (_areAllUnique7(src)) {
      return src.slice();
    }
    var out = [], val, i, ien = src.length, j, k = 0;
    again: for (i = 0; i < ien; i++) {
      val = src[i];
      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }
      out.push(val);
      k++;
    }
    return out;
  };
  var _flatten7 = function(out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten7(out, val[i]);
      }
    } else {
      out.push(val);
    }
    return out;
  };
  function _addClass7(el, name) {
    if (name) {
      name.split(" ").forEach(function(n) {
        if (n) {
          el.classList.add(n);
        }
      });
    }
  }
  DataTable7.util = {
    /**
     * Return a string with diacritic characters decomposed
     * @param {*} mixed Function or string to normalize
     * @param {*} both Return original string and the normalized string
     * @returns String or undefined
     */
    diacritics: function(mixed, both) {
      var type = typeof mixed;
      if (type !== "function") {
        return _normalize7(mixed, both);
      }
      _normalize7 = mixed;
    },
    /**
     * Debounce a function
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    debounce: function(fn, timeout) {
      var timer;
      return function() {
        var that = this;
        var args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(that, args);
        }, timeout || 250);
      };
    },
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function(fn, freq) {
      var frequency = freq !== void 0 ? freq : 200, last, timer;
      return function() {
        var that = this, now = +/* @__PURE__ */ new Date(), args = arguments;
        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            last = void 0;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },
    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function(val) {
      return val.replace(_re_escape_regex7, "\\$1");
    },
    /**
     * Create a function that will write to a nested object or array
     * @param {*} source JSON notation string
     * @returns Write function
     */
    set: function(source) {
      if ($17.isPlainObject(source)) {
        return DataTable7.util.set(source._);
      } else if (source === null) {
        return function() {
        };
      } else if (typeof source === "function") {
        return function(data, val, meta) {
          source(data, "set", val, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var setData = function(data, val, src) {
          var a = _fnSplitObjNotation7(src), b;
          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;
          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            if (a[i] === "__proto__" || a[i] === "constructor") {
              throw new Error("Cannot set prototype values");
            }
            arrayNotation = a[i].match(__reArray7);
            funcNotation = a[i].match(__reFn7);
            if (arrayNotation) {
              a[i] = a[i].replace(__reArray7, "");
              data[a[i]] = [];
              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join(".");
              if (Array.isArray(val)) {
                for (var j = 0, jLen = val.length; j < jLen; j++) {
                  o = {};
                  setData(o, val[j], innerSrc);
                  data[a[i]].push(o);
                }
              } else {
                data[a[i]] = val;
              }
              return;
            } else if (funcNotation) {
              a[i] = a[i].replace(__reFn7, "");
              data = data[a[i]](val);
            }
            if (data[a[i]] === null || data[a[i]] === void 0) {
              data[a[i]] = {};
            }
            data = data[a[i]];
          }
          if (aLast.match(__reFn7)) {
            data = data[aLast.replace(__reFn7, "")](val);
          } else {
            data[aLast.replace(__reArray7, "")] = val;
          }
        };
        return function(data, val) {
          return setData(data, val, source);
        };
      } else {
        return function(data, val) {
          data[source] = val;
        };
      }
    },
    /**
     * Create a function that will read nested objects from arrays, based on JSON notation
     * @param {*} source JSON notation string
     * @returns Value read
     */
    get: function(source) {
      if ($17.isPlainObject(source)) {
        var o = {};
        $17.each(source, function(key, val) {
          if (val) {
            o[key] = DataTable7.util.get(val);
          }
        });
        return function(data, type, row, meta) {
          var t = o[type] || o._;
          return t !== void 0 ? t(data, type, row, meta) : data;
        };
      } else if (source === null) {
        return function(data) {
          return data;
        };
      } else if (typeof source === "function") {
        return function(data, type, row, meta) {
          return source(data, type, row, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var fetchData = function(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== "") {
            var a = _fnSplitObjNotation7(src);
            for (var i = 0, iLen = a.length; i < iLen; i++) {
              arrayNotation = a[i].match(__reArray7);
              funcNotation = a[i].match(__reFn7);
              if (arrayNotation) {
                a[i] = a[i].replace(__reArray7, "");
                if (a[i] !== "") {
                  data = data[a[i]];
                }
                out = [];
                a.splice(0, i + 1);
                innerSrc = a.join(".");
                if (Array.isArray(data)) {
                  for (var j = 0, jLen = data.length; j < jLen; j++) {
                    out.push(fetchData(data[j], type, innerSrc));
                  }
                }
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join);
                break;
              } else if (funcNotation) {
                a[i] = a[i].replace(__reFn7, "");
                data = data[a[i]]();
                continue;
              }
              if (data === null || data[a[i]] === null) {
                return null;
              } else if (data === void 0 || data[a[i]] === void 0) {
                return void 0;
              }
              data = data[a[i]];
            }
          }
          return data;
        };
        return function(data, type) {
          return fetchData(data, type, source);
        };
      } else {
        return function(data) {
          return data[source];
        };
      }
    },
    stripHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _stripHtml7 = mixed;
        return;
      } else if (type === "string") {
        return _stripHtml7(mixed);
      }
      return mixed;
    },
    escapeHtml: function(mixed) {
      var type = typeof mixed;
      if (type === "function") {
        _escapeHtml7 = mixed;
        return;
      } else if (type === "string" || Array.isArray(mixed)) {
        return _escapeHtml7(mixed);
      }
      return mixed;
    },
    unique: _unique7
  };
  function _fnHungarianMap7(o) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map2 = {};
    $17.each(o, function(key) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map2[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap7(o[key]);
        }
      }
    });
    o._hungarianMap = map2;
  }
  function _fnCamelToHungarian7(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap7(src);
    }
    var hungarianKey;
    $17.each(user, function(key) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $17.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian7(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  var _fnCompatMap7 = function(o, knew, old) {
    if (o[knew] !== void 0) {
      o[old] = o[knew];
    }
  };
  function _fnCompatOpts7(init2) {
    _fnCompatMap7(init2, "ordering", "bSort");
    _fnCompatMap7(init2, "orderMulti", "bSortMulti");
    _fnCompatMap7(init2, "orderClasses", "bSortClasses");
    _fnCompatMap7(init2, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap7(init2, "order", "aaSorting");
    _fnCompatMap7(init2, "orderFixed", "aaSortingFixed");
    _fnCompatMap7(init2, "paging", "bPaginate");
    _fnCompatMap7(init2, "pagingType", "sPaginationType");
    _fnCompatMap7(init2, "pageLength", "iDisplayLength");
    _fnCompatMap7(init2, "searching", "bFilter");
    if (typeof init2.sScrollX === "boolean") {
      init2.sScrollX = init2.sScrollX ? "100%" : "";
    }
    if (typeof init2.scrollX === "boolean") {
      init2.scrollX = init2.scrollX ? "100%" : "";
    }
    var searchCols = init2.aoSearchCols;
    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian7(DataTable7.models.oSearch, searchCols[i]);
        }
      }
    }
    if (init2.serverSide && !init2.searchDelay) {
      init2.searchDelay = 400;
    }
  }
  function _fnCompatCols7(init2) {
    _fnCompatMap7(init2, "orderable", "bSortable");
    _fnCompatMap7(init2, "orderData", "aDataSort");
    _fnCompatMap7(init2, "orderSequence", "asSorting");
    _fnCompatMap7(init2, "orderDataType", "sortDataType");
    var dataSort = init2.aDataSort;
    if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
      init2.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect7(settings) {
    if (!DataTable7.__browser) {
      var browser = {};
      DataTable7.__browser = browser;
      var n = $17("<div/>").css({
        position: "fixed",
        top: 0,
        left: -1 * window.pageXOffset,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(
        $17("<div/>").css({
          position: "absolute",
          top: 1,
          left: 1,
          width: 100,
          overflow: "scroll"
        }).append(
          $17("<div/>").css({
            width: "100%",
            height: 10
          })
        )
      ).appendTo("body");
      var outer = n.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      n.remove();
    }
    $17.extend(settings.oBrowser, DataTable7.__browser);
    settings.oScroll.iBarWidth = DataTable7.__browser.barWidth;
  }
  function _fnAddColumn7(oSettings) {
    var oDefaults = DataTable7.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $17.extend({}, DataTable7.models.oColumn, oDefaults, {
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol,
      searchFixed: {},
      colEl: $17("<col>").attr("data-dt-column", iCol)
    });
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $17.extend({}, DataTable7.models.oSearch, searchCols[iCol]);
  }
  function _fnColumnOptions7(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    if (oOptions !== void 0 && oOptions !== null) {
      _fnCompatCols7(oOptions);
      _fnCamelToHungarian7(DataTable7.defaults.column, oOptions, true);
      if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      var origClass = oCol.sClass;
      $17.extend(oCol, oOptions);
      _fnMap7(oCol, oOptions, "sWidth", "sWidthOrig");
      if (origClass !== oCol.sClass) {
        oCol.sClass = origClass + " " + oCol.sClass;
      }
      if (oOptions.iDataSort !== void 0) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap7(oCol, oOptions, "aDataSort");
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn7(mDataSrc);
    if (oCol.mRender && Array.isArray(oCol.mRender)) {
      var copy = oCol.mRender.slice();
      var name = copy.shift();
      oCol.mRender = DataTable7.render[name].apply(window, copy);
    }
    oCol._render = oCol.mRender ? _fnGetObjectDataFn7(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $17.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, void 0, meta);
      return oCol._render && type ? oCol._render(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn7(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
    }
  }
  function _fnAdjustColumnSizing7(settings) {
    _fnCalculateColumnWidths7(settings);
    _fnColumnSizes7(settings);
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw7(settings);
    }
    _fnCallbackFire7(settings, null, "column-sizing", [settings]);
  }
  function _fnColumnSizes7(settings) {
    var cols = settings.aoColumns;
    for (var i = 0; i < cols.length; i++) {
      var width = _fnColumnsSumWidth7(settings, [i], false, false);
      cols[i].colEl.css("width", width);
    }
  }
  function _fnVisibleToColumnIndex7(oSettings, iMatch) {
    var aiVis = _fnGetColumns7(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible7(oSettings, iMatch) {
    var aiVis = _fnGetColumns7(oSettings, "bVisible");
    var iPos = aiVis.indexOf(iMatch);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns7(settings) {
    var layout = settings.aoHeader;
    var columns = settings.aoColumns;
    var vis = 0;
    if (layout.length) {
      for (var i = 0, ien = layout[0].length; i < ien; i++) {
        if (columns[i].bVisible && $17(layout[0][i].cell).css("display") !== "none") {
          vis++;
        }
      }
    }
    return vis;
  }
  function _fnGetColumns7(oSettings, sParam) {
    var a = [];
    oSettings.aoColumns.map(function(val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  function _fnColumnTypes7(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable7.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, detectedType, cache;
    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            if (!data[k]) {
              continue;
            }
            if (cache[k] === void 0) {
              cache[k] = _fnGetCellData7(settings, k, i, "type");
            }
            detectedType = types[j](cache[k], settings);
            if (!detectedType && j !== types.length - 2) {
              break;
            }
            if (detectedType === "html" && !_empty7(cache[k])) {
              break;
            }
          }
          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        if (!col.sType) {
          col.sType = "string";
        }
      }
      var autoClass = _ext7.type.className[col.sType];
      if (autoClass) {
        _columnAutoClass7(settings.aoHeader, i, autoClass);
        _columnAutoClass7(settings.aoFooter, i, autoClass);
      }
      var renderer = _ext7.type.render[col.sType];
      if (renderer && !col._render) {
        col._render = DataTable7.util.get(renderer);
        _columnAutoRender7(settings, i);
      }
    }
  }
  function _columnAutoRender7(settings, colIdx) {
    var data = settings.aoData;
    for (var i = 0; i < data.length; i++) {
      if (data[i].nTr) {
        var display = _fnGetCellData7(settings, i, colIdx, "display");
        data[i].displayData[colIdx] = display;
        _fnWriteCell7(data[i].anCells[colIdx], display);
      }
    }
  }
  function _columnAutoClass7(container, colIdx, className) {
    container.forEach(function(row) {
      if (row[colIdx] && row[colIdx].unique) {
        _addClass7(row[colIdx].cell, className);
      }
    });
  }
  function _fnApplyColumnDefs7(oSettings, aoColDefs, aoCols, headerLayout, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        if (aoCols[i] && aoCols[i].name) {
          columns[i].sName = aoCols[i].name;
        }
      }
    }
    if (aoColDefs) {
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        var aTargets = def.target !== void 0 ? def.target : def.targets !== void 0 ? def.targets : def.aTargets;
        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          var target = aTargets[j];
          if (typeof target === "number" && target >= 0) {
            while (columns.length <= target) {
              _fnAddColumn7(oSettings);
            }
            fn(target, def);
          } else if (typeof target === "number" && target < 0) {
            fn(columns.length + target, def);
          } else if (typeof target === "string") {
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (target === "_all") {
                fn(k, def);
              } else if (target.indexOf(":name") !== -1) {
                if (columns[k].sName === target.replace(":name", "")) {
                  fn(k, def);
                }
              } else {
                headerLayout.forEach(function(row) {
                  if (row[k]) {
                    var cell = $17(row[k].cell);
                    if (target.match(/^[a-z][\w-]*$/i)) {
                      target = "." + target;
                    }
                    if (cell.is(target)) {
                      fn(k, def);
                    }
                  }
                });
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  function _fnColumnsSumWidth7(settings, targets, original, incVisible) {
    if (!Array.isArray(targets)) {
      targets = _fnColumnsFromHeader7(targets);
    }
    var sum = 0;
    var unit;
    var columns = settings.aoColumns;
    for (var i = 0, ien = targets.length; i < ien; i++) {
      var column = columns[targets[i]];
      var definedWidth = original ? column.sWidthOrig : column.sWidth;
      if (!incVisible && column.bVisible === false) {
        continue;
      }
      if (definedWidth === null || definedWidth === void 0) {
        return null;
      } else if (typeof definedWidth === "number") {
        unit = "px";
        sum += definedWidth;
      } else {
        var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);
        if (matched) {
          sum += matched[1] * 1;
          unit = matched.length === 3 ? matched[2] : "px";
        }
      }
    }
    return sum + unit;
  }
  function _fnColumnsFromHeader7(cell) {
    var attr = $17(cell).closest("[data-dt-column]").attr("data-dt-column");
    if (!attr) {
      return [];
    }
    return attr.split(",").map(function(val) {
      return val * 1;
    });
  }
  function _fnAddData7(settings, dataIn, tr, tds) {
    var rowIdx = settings.aoData.length;
    var rowModel = $17.extend(true, {}, DataTable7.models.oRow, {
      src: tr ? "dom" : "data",
      idx: rowIdx
    });
    rowModel._aData = dataIn;
    settings.aoData.push(rowModel);
    var columns = settings.aoColumns;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    settings.aiDisplayMaster.push(rowIdx);
    var id = settings.rowIdFn(dataIn);
    if (id !== void 0) {
      settings.aIds[id] = rowModel;
    }
    if (tr || !settings.oFeatures.bDeferRender) {
      _fnCreateTr7(settings, rowIdx, tr, tds);
    }
    return rowIdx;
  }
  function _fnAddTr7(settings, trs) {
    var row;
    if (!(trs instanceof $17)) {
      trs = $17(trs);
    }
    return trs.map(function(i, el) {
      row = _fnGetRowElements7(settings, el);
      return _fnAddData7(settings, row.data, el, row.cells);
    });
  }
  function _fnGetCellData7(settings, rowIdx, colIdx, type) {
    if (type === "search") {
      type = "filter";
    } else if (type === "order") {
      type = "sort";
    }
    var row = settings.aoData[rowIdx];
    if (!row) {
      return void 0;
    }
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = row._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings,
      row: rowIdx,
      col: colIdx
    });
    if (type !== "display" && cellData && typeof cellData === "object" && cellData.nodeName) {
      cellData = cellData.innerHTML;
    }
    if (cellData === void 0) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog7(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
      cellData = defaultContent;
    } else if (typeof cellData === "function") {
      return cellData.call(rowData);
    }
    if (cellData === null && type === "display") {
      return "";
    }
    if (type === "filter") {
      var fomatters = DataTable7.ext.type.search;
      if (fomatters[col.sType]) {
        cellData = fomatters[col.sType](cellData);
      }
    }
    return cellData;
  }
  function _fnSetCellData7(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings,
      row: rowIdx,
      col: colIdx
    });
  }
  function _fnWriteCell7(td, val) {
    if (val && typeof val === "object" && val.nodeName) {
      $17(td).empty().append(val);
    } else {
      td.innerHTML = val;
    }
  }
  var __reArray7 = /\[.*?\]$/;
  var __reFn7 = /\(\)$/;
  function _fnSplitObjNotation7(str) {
    var parts = str.match(/(\\.|[^.])+/g) || [""];
    return parts.map(function(s) {
      return s.replace(/\\\./g, ".");
    });
  }
  var _fnGetObjectDataFn7 = DataTable7.util.get;
  var _fnSetObjectDataFn7 = DataTable7.util.set;
  function _fnGetDataMaster7(settings) {
    return _pluck7(settings.aoData, "_aData");
  }
  function _fnClearTable7(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnInvalidate7(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;
    row._aSortData = null;
    row._aFilterData = null;
    row.displayData = null;
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements7(
        settings,
        row,
        colIdx,
        colIdx === void 0 ? void 0 : row._aData
      ).data;
    } else {
      var cells = row.anCells;
      var display = _fnGetRowDisplay7(settings, rowIdx);
      if (cells) {
        if (colIdx !== void 0) {
          _fnWriteCell7(cells[colIdx], display[colIdx]);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            _fnWriteCell7(cells[i], display[i]);
          }
        }
      }
    }
    var cols = settings.aoColumns;
    if (colIdx !== void 0) {
      cols[colIdx].sType = null;
      cols[colIdx].maxLenString = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
        cols[i].maxLenString = null;
      }
      _fnRowAttributes7(settings, row);
    }
  }
  function _fnGetRowElements7(settings, row, colIdx, d) {
    var tds = [], td = row.firstChild, name, col, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d = d !== void 0 ? d : objectRead ? {} : [];
    var attr = function(str, td2) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr2 = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn7(str);
          setter(d, td2.getAttribute(attr2));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === void 0 || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn7(col.mData._);
          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn7(col.mData);
            }
            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }
      i++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn7(settings.rowId)(d, id);
      }
    }
    return {
      data: d,
      cells: tds
    };
  }
  function _fnGetRowDisplay7(settings, rowIdx) {
    let rowModal = settings.aoData[rowIdx];
    let columns = settings.aoColumns;
    if (!rowModal.displayData) {
      rowModal.displayData = [];
      for (var colIdx = 0, len = columns.length; colIdx < len; colIdx++) {
        rowModal.displayData.push(
          _fnGetCellData7(settings, rowIdx, colIdx, "display")
        );
      }
    }
    return rowModal.displayData;
  }
  function _fnCreateTr7(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create, trClass = oSettings.oClasses.tbody.row;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      _addClass7(nTr, trClass);
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes7(oSettings, row);
      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn && anTds[i] ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        if (!nTd) {
          _fnLog7(oSettings, 0, "Incorrect column count", 18);
        }
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd);
        var display = _fnGetRowDisplay7(oSettings, iRow);
        if (create || (oCol.mRender || oCol.mData !== i) && (!$17.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
          _fnWriteCell7(nTd, display[i]);
        }
        if (oCol.bVisible && create) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && !create) {
          nTd.parentNode.removeChild(nTd);
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(
            oSettings.oInstance,
            nTd,
            _fnGetCellData7(oSettings, iRow, i),
            rowData,
            iRow,
            i
          );
        }
      }
      _fnCallbackFire7(oSettings, "aoRowCreatedCallback", "row-created", [nTr, rowData, iRow, cells]);
    } else {
      _addClass7(row.nTr, trClass);
    }
  }
  function _fnRowAttributes7(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique7(row.__rowc.concat(a)) : a;
        $17(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $17(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $17(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead7(settings, side) {
    var classes = settings.oClasses;
    var columns = settings.aoColumns;
    var i, ien, row;
    var target = side === "header" ? settings.nTHead : settings.nTFoot;
    var titleProp = side === "header" ? "sTitle" : side;
    if (!target) {
      return;
    }
    if (side === "header" || _pluck7(settings.aoColumns, titleProp).join("")) {
      row = $17("tr", target);
      if (!row.length) {
        row = $17("<tr/>").appendTo(target);
      }
      if (row.length === 1) {
        var cells = $17("td, th", row);
        for (i = cells.length, ien = columns.length; i < ien; i++) {
          $17("<th/>").html(columns[i][titleProp] || "").appendTo(row);
        }
      }
    }
    var detected = _fnDetectHeader7(settings, target, true);
    if (side === "header") {
      settings.aoHeader = detected;
    } else {
      settings.aoFooter = detected;
    }
    $17(target).children("tr").attr("role", "row");
    $17(target).children("tr").children("th, td").each(function() {
      _fnRenderer7(settings, side)(
        settings,
        $17(this),
        classes
      );
    });
  }
  function _fnHeaderLayout7(settings, source, incColumns) {
    var row, column, cell;
    var local = [];
    var structure = [];
    var columns = settings.aoColumns;
    var columnCount = columns.length;
    var rowspan, colspan;
    if (!source) {
      return;
    }
    if (!incColumns) {
      incColumns = _range7(columnCount).filter(function(idx) {
        return columns[idx].bVisible;
      });
    }
    for (row = 0; row < source.length; row++) {
      local[row] = source[row].slice().filter(function(cell2, i) {
        return incColumns.includes(i);
      });
      structure.push([]);
    }
    for (row = 0; row < local.length; row++) {
      for (column = 0; column < local[row].length; column++) {
        rowspan = 1;
        colspan = 1;
        if (structure[row][column] === void 0) {
          cell = local[row][column].cell;
          while (local[row + rowspan] !== void 0 && local[row][column].cell == local[row + rowspan][column].cell) {
            structure[row + rowspan][column] = null;
            rowspan++;
          }
          while (local[row][column + colspan] !== void 0 && local[row][column].cell == local[row][column + colspan].cell) {
            for (var k = 0; k < rowspan; k++) {
              structure[row + k][column + colspan] = null;
            }
            colspan++;
          }
          var titleSpan = $17("span.dt-column-title", cell);
          structure[row][column] = {
            cell,
            colspan,
            rowspan,
            title: titleSpan.length ? titleSpan.html() : $17(cell).html()
          };
        }
      }
    }
    return structure;
  }
  function _fnDrawHead7(settings, source) {
    var layout = _fnHeaderLayout7(settings, source);
    var tr, n;
    for (var row = 0; row < source.length; row++) {
      tr = source[row].row;
      if (tr) {
        while (n = tr.firstChild) {
          tr.removeChild(n);
        }
      }
      for (var column = 0; column < layout[row].length; column++) {
        var point = layout[row][column];
        if (point) {
          $17(point.cell).appendTo(tr).attr("rowspan", point.rowspan).attr("colspan", point.colspan);
        }
      }
    }
  }
  function _fnDraw7(oSettings, ajaxComplete) {
    _fnStart7(oSettings);
    var aPreDraw = _fnCallbackFire7(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if (aPreDraw.indexOf(false) !== -1) {
      _fnProcessingDisplay7(oSettings, false);
      return;
    }
    var anRows = [];
    var iRowCount = 0;
    var bServerSide = _fnDataSource7(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    var columns = oSettings.aoColumns;
    var body = $17(oSettings.nTBody);
    oSettings.bDrawing = true;
    if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !ajaxComplete) {
      if (oSettings.iDraw === 0) {
        body.empty().append(_emptyRow7(oSettings));
      }
      _fnAjaxUpdate7(oSettings);
      return;
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr7(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        for (var i = 0; i < columns.length; i++) {
          var col = columns[i];
          var td = aoData.anCells[i];
          _addClass7(td, _ext7.type.className[col.sType]);
          _addClass7(td, col.sClass);
          _addClass7(td, oSettings.oClasses.tbody.cell);
        }
        _fnCallbackFire7(
          oSettings,
          "aoRowCallback",
          null,
          [nRow, aoData._aData, iRowCount, j, iDataIndex]
        );
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      anRows[0] = _emptyRow7(oSettings);
    }
    _fnCallbackFire7(oSettings, "aoHeaderCallback", "header", [
      $17(oSettings.nTHead).children("tr")[0],
      _fnGetDataMaster7(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    _fnCallbackFire7(oSettings, "aoFooterCallback", "footer", [
      $17(oSettings.nTFoot).children("tr")[0],
      _fnGetDataMaster7(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    if (body[0].replaceChildren) {
      body[0].replaceChildren.apply(body[0], anRows);
    } else {
      body.children().detach();
      body.append($17(anRows));
    }
    $17(oSettings.nTableWrapper).toggleClass("dt-empty-footer", $17("tr", oSettings.nTFoot).length === 0);
    _fnCallbackFire7(oSettings, "aoDrawCallback", "draw", [oSettings], true);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw7(settings, holdPosition, recompute) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (recompute === void 0 || recompute === true) {
      if (sort) {
        _fnSort7(settings);
      }
      if (filter) {
        _fnFilterComplete7(settings, settings.oPreviousSearch);
      } else {
        settings.aiDisplay = settings.aiDisplayMaster.slice();
      }
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw7(settings);
    settings._drawHold = false;
  }
  function _emptyRow7(settings) {
    var oLang = settings.oLanguage;
    var zero = oLang.sZeroRecords;
    var dataSrc = _fnDataSource7(settings);
    if (settings.iDraw < 1 && dataSrc === "ssp" || settings.iDraw <= 1 && dataSrc === "ajax") {
      zero = oLang.sLoadingRecords;
    } else if (oLang.sEmptyTable && settings.fnRecordsTotal() === 0) {
      zero = oLang.sEmptyTable;
    }
    return $17("<tr/>").append($17("<td />", {
      "colSpan": _fnVisbleColumns7(settings),
      "class": settings.oClasses.empty.row
    }).html(zero))[0];
  }
  function _layoutArray7(settings, layout, side) {
    var groups = {};
    $17.each(layout, function(pos, val) {
      if (val === null) {
        return;
      }
      var splitPos = pos.replace(/([A-Z])/g, " $1").split(" ");
      if (!groups[splitPos[0]]) {
        groups[splitPos[0]] = {};
      }
      var align = splitPos.length === 1 ? "full" : splitPos[1].toLowerCase();
      var group = groups[splitPos[0]];
      var groupRun = function(contents, innerVal) {
        if ($17.isPlainObject(innerVal)) {
          Object.keys(innerVal).map(function(key) {
            contents.push({
              feature: key,
              opts: innerVal[key]
            });
          });
        } else {
          contents.push(innerVal);
        }
      };
      if (!group[align] || !group[align].contents) {
        group[align] = { contents: [] };
      }
      if (Array.isArray(val)) {
        for (var i2 = 0; i2 < val.length; i2++) {
          groupRun(group[align].contents, val[i2]);
        }
      } else {
        groupRun(group[align].contents, val);
      }
      if (!Array.isArray(group[align].contents)) {
        group[align].contents = [group[align].contents];
      }
    });
    var filtered = Object.keys(groups).map(function(pos) {
      if (pos.indexOf(side) !== 0) {
        return null;
      }
      return {
        name: pos,
        val: groups[pos]
      };
    }).filter(function(item) {
      return item !== null;
    });
    filtered.sort(function(a, b) {
      var order1 = a.name.replace(/[^0-9]/g, "") * 1;
      var order2 = b.name.replace(/[^0-9]/g, "") * 1;
      return order2 - order1;
    });
    if (side === "bottom") {
      filtered.reverse();
    }
    var rows = [];
    for (var i = 0, ien = filtered.length; i < ien; i++) {
      if (filtered[i].val.full) {
        rows.push({ full: filtered[i].val.full });
        _layoutResolve7(settings, rows[rows.length - 1]);
        delete filtered[i].val.full;
      }
      if (Object.keys(filtered[i].val).length) {
        rows.push(filtered[i].val);
        _layoutResolve7(settings, rows[rows.length - 1]);
      }
    }
    return rows;
  }
  function _layoutResolve7(settings, row) {
    var getFeature = function(feature, opts) {
      if (!_ext7.features[feature]) {
        _fnLog7(settings, 0, "Unknown feature: " + feature);
      }
      return _ext7.features[feature].apply(this, [settings, opts]);
    };
    var resolve = function(item) {
      var line = row[item].contents;
      for (var i = 0, ien = line.length; i < ien; i++) {
        if (!line[i]) {
          continue;
        } else if (typeof line[i] === "string") {
          line[i] = getFeature(line[i], null);
        } else if ($17.isPlainObject(line[i])) {
          line[i] = getFeature(line[i].feature, line[i].opts);
        } else if (typeof line[i].node === "function") {
          line[i] = line[i].node(settings);
        } else if (typeof line[i] === "function") {
          var inst = line[i](settings);
          line[i] = typeof inst.node === "function" ? inst.node() : inst;
        }
      }
    };
    $17.each(row, function(key) {
      resolve(key);
    });
  }
  function _fnAddOptionsHtml7(settings) {
    var classes = settings.oClasses;
    var table = $17(settings.nTable);
    var insert = $17("<div/>").attr({
      id: settings.sTableId + "_wrapper",
      "class": classes.container
    }).insertBefore(table);
    settings.nTableWrapper = insert[0];
    if (settings.sDom) {
      _fnLayoutDom7(settings, settings.sDom, insert);
    } else {
      var top = _layoutArray7(settings, settings.layout, "top");
      var bottom = _layoutArray7(settings, settings.layout, "bottom");
      var renderer = _fnRenderer7(settings, "layout");
      top.forEach(function(item) {
        renderer(settings, insert, item);
      });
      renderer(settings, insert, {
        full: {
          table: true,
          contents: [_fnFeatureHtmlTable7(settings)]
        }
      });
      bottom.forEach(function(item) {
        renderer(settings, insert, item);
      });
    }
    _processingHtml7(settings);
  }
  function _fnLayoutDom7(settings, dom, insert) {
    var parts = dom.match(/(".*?")|('.*?')|./g);
    var featureNode, option, newNode, next, attr;
    for (var i = 0; i < parts.length; i++) {
      featureNode = null;
      option = parts[i];
      if (option == "<") {
        newNode = $17("<div/>");
        next = parts[i + 1];
        if (next[0] == "'" || next[0] == '"') {
          attr = next.replace(/['"]/g, "");
          var id = "", className;
          if (attr.indexOf(".") != -1) {
            var split = attr.split(".");
            id = split[0];
            className = split[1];
          } else if (attr[0] == "#") {
            id = attr;
          } else {
            className = attr;
          }
          newNode.attr("id", id.substring(1)).addClass(className);
          i++;
        }
        insert.append(newNode);
        insert = newNode;
      } else if (option == ">") {
        insert = insert.parent();
      } else if (option == "t") {
        featureNode = _fnFeatureHtmlTable7(settings);
      } else {
        DataTable7.ext.feature.forEach(function(feature) {
          if (option == feature.cFeature) {
            featureNode = feature.fnInit(settings);
          }
        });
      }
      if (featureNode) {
        insert.append(featureNode);
      }
    }
  }
  function _fnDetectHeader7(settings, thead, write) {
    var columns = settings.aoColumns;
    var rows = $17(thead).children("tr");
    var row, cell;
    var i, k, l, iLen, shifted, column, colspan, rowspan;
    var isHeader = thead && thead.nodeName.toLowerCase() === "thead";
    var layout = [];
    var unique;
    var shift = function(a, i2, j) {
      var k2 = a[i2];
      while (k2[j]) {
        j++;
      }
      return j;
    };
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      layout.push([]);
    }
    for (i = 0, iLen = rows.length; i < iLen; i++) {
      row = rows[i];
      column = 0;
      cell = row.firstChild;
      while (cell) {
        if (cell.nodeName.toUpperCase() == "TD" || cell.nodeName.toUpperCase() == "TH") {
          var cols = [];
          colspan = cell.getAttribute("colspan") * 1;
          rowspan = cell.getAttribute("rowspan") * 1;
          colspan = !colspan || colspan === 0 || colspan === 1 ? 1 : colspan;
          rowspan = !rowspan || rowspan === 0 || rowspan === 1 ? 1 : rowspan;
          shifted = shift(layout, i, column);
          unique = colspan === 1 ? true : false;
          if (write) {
            if (unique) {
              _fnColumnOptions7(settings, shifted, $17(cell).data());
              var columnDef = columns[shifted];
              var width = cell.getAttribute("width") || null;
              var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
              if (t) {
                width = t[1];
              }
              columnDef.sWidthOrig = columnDef.sWidth || width;
              if (isHeader) {
                if (columnDef.sTitle !== null && !columnDef.autoTitle) {
                  cell.innerHTML = columnDef.sTitle;
                }
                if (!columnDef.sTitle && unique) {
                  columnDef.sTitle = _stripHtml7(cell.innerHTML);
                  columnDef.autoTitle = true;
                }
              } else {
                if (columnDef.footer) {
                  cell.innerHTML = columnDef.footer;
                }
              }
              if (!columnDef.ariaTitle) {
                columnDef.ariaTitle = $17(cell).attr("aria-label") || columnDef.sTitle;
              }
              if (columnDef.className) {
                $17(cell).addClass(columnDef.className);
              }
            }
            if ($17("span.dt-column-title", cell).length === 0) {
              $17("<span>").addClass("dt-column-title").append(cell.childNodes).appendTo(cell);
            }
            if (isHeader && $17("span.dt-column-order", cell).length === 0) {
              $17("<span>").addClass("dt-column-order").appendTo(cell);
            }
          }
          for (l = 0; l < colspan; l++) {
            for (k = 0; k < rowspan; k++) {
              layout[i + k][shifted + l] = {
                cell,
                unique
              };
              layout[i + k].row = row;
            }
            cols.push(shifted + l);
          }
          cell.setAttribute("data-dt-column", _unique7(cols).join(","));
        }
        cell = cell.nextSibling;
      }
    }
    return layout;
  }
  function _fnStart7(oSettings) {
    var bServerSide = _fnDataSource7(oSettings) == "ssp";
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
  }
  function _fnBuildAjax7(oSettings, data, fn) {
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
      if (json === null || typeof status === "number" && status == 204) {
        json = {};
        _fnAjaxDataSrc7(oSettings, json, []);
      }
      var error = json.error || json.sError;
      if (error) {
        _fnLog7(oSettings, 0, error);
      }
      oSettings.json = json;
      _fnCallbackFire7(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR], true);
      fn(json);
    };
    if ($17.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === "function" ? ajaxData(data, oSettings) : (
        // fn can manipulate data or return
        ajaxData
      );
      data = typeof ajaxData === "function" && newData ? newData : $17.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {
      "url": typeof ajax === "string" ? ajax : "",
      "data": data,
      "success": callback,
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function(xhr, error) {
        var ret = _fnCallbackFire7(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR], true);
        if (ret.indexOf(true) === -1) {
          if (error == "parsererror") {
            _fnLog7(oSettings, 0, "Invalid JSON response", 1);
          } else if (xhr.readyState === 4) {
            _fnLog7(oSettings, 0, "Ajax error", 7);
          }
        }
        _fnProcessingDisplay7(oSettings, false);
      }
    };
    if ($17.isPlainObject(ajax)) {
      $17.extend(baseAjax, ajax);
    }
    oSettings.oAjaxData = data;
    _fnCallbackFire7(oSettings, null, "preXhr", [oSettings, data, baseAjax], true);
    if (typeof ajax === "function") {
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else if (ajax.url === "") {
      var empty = {};
      DataTable7.util.set(ajax.dataSrc)(empty, []);
      callback(empty);
    } else {
      oSettings.jqXHR = $17.ajax(baseAjax);
      if (ajaxData) {
        ajax.data = ajaxData;
      }
    }
  }
  function _fnAjaxUpdate7(settings) {
    settings.iDraw++;
    _fnProcessingDisplay7(settings, true);
    _fnBuildAjax7(
      settings,
      _fnAjaxParameters7(settings),
      function(json) {
        _fnAjaxUpdateDraw7(settings, json);
      }
    );
  }
  function _fnAjaxParameters7(settings) {
    var columns = settings.aoColumns, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, colData = function(idx, prop) {
      return typeof columns[idx][prop] === "function" ? "function" : columns[idx][prop];
    };
    return {
      draw: settings.iDraw,
      columns: columns.map(function(column, i) {
        return {
          data: colData(i, "mData"),
          name: column.sName,
          searchable: column.bSearchable,
          orderable: column.bSortable,
          search: {
            value: preColSearch[i].search,
            regex: preColSearch[i].regex,
            fixed: Object.keys(column.searchFixed).map(function(name) {
              return {
                name,
                term: column.searchFixed[name].toString()
              };
            })
          }
        };
      }),
      order: _fnSortFlatten7(settings).map(function(val) {
        return {
          column: val.col,
          dir: val.dir,
          name: colData(val.col, "sName")
        };
      }),
      start: settings._iDisplayStart,
      length: features.bPaginate ? settings._iDisplayLength : -1,
      search: {
        value: preSearch.search,
        regex: preSearch.regex,
        fixed: Object.keys(settings.searchFixed).map(function(name) {
          return {
            name,
            term: settings.searchFixed[name].toString()
          };
        })
      }
    };
  }
  function _fnAjaxUpdateDraw7(settings, json) {
    var data = _fnAjaxDataSrc7(settings, json);
    var draw = _fnAjaxDataSrcParam7(settings, "draw", json);
    var recordsTotal = _fnAjaxDataSrcParam7(settings, "recordsTotal", json);
    var recordsFiltered = _fnAjaxDataSrcParam7(settings, "recordsFiltered", json);
    if (draw !== void 0) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    if (!data) {
      data = [];
    }
    _fnClearTable7(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData7(settings, data[i]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnDraw7(settings, true);
    _fnInitComplete7(settings);
    _fnProcessingDisplay7(settings, false);
  }
  function _fnAjaxDataSrc7(settings, json, write) {
    var dataProp = "data";
    if ($17.isPlainObject(settings.ajax) && settings.ajax.dataSrc !== void 0) {
      var dataSrc = settings.ajax.dataSrc;
      if (typeof dataSrc === "string" || typeof dataSrc === "function") {
        dataProp = dataSrc;
      } else if (dataSrc.data !== void 0) {
        dataProp = dataSrc.data;
      }
    }
    if (!write) {
      if (dataProp === "data") {
        return json.aaData || json[dataProp];
      }
      return dataProp !== "" ? _fnGetObjectDataFn7(dataProp)(json) : json;
    }
    _fnSetObjectDataFn7(dataProp)(json, write);
  }
  function _fnAjaxDataSrcParam7(settings, param, json) {
    var dataSrc = $17.isPlainObject(settings.ajax) ? settings.ajax.dataSrc : null;
    if (dataSrc && dataSrc[param]) {
      return _fnGetObjectDataFn7(dataSrc[param])(json);
    }
    var old = "";
    if (param === "draw") {
      old = "sEcho";
    } else if (param === "recordsTotal") {
      old = "iTotalRecords";
    } else if (param === "recordsFiltered") {
      old = "iTotalDisplayRecords";
    }
    return json[old] !== void 0 ? json[old] : json[param];
  }
  function _fnFilterComplete7(settings, input) {
    var columnsSearch = settings.aoPreSearchCols;
    _fnColumnTypes7(settings);
    if (_fnDataSource7(settings) != "ssp") {
      _fnFilterData7(settings);
      settings.aiDisplay = settings.aiDisplayMaster.slice();
      _fnFilter7(settings.aiDisplay, settings, input.search, input);
      $17.each(settings.searchFixed, function(name, term) {
        _fnFilter7(settings.aiDisplay, settings, term, {});
      });
      for (var i = 0; i < columnsSearch.length; i++) {
        var col = columnsSearch[i];
        _fnFilter7(
          settings.aiDisplay,
          settings,
          col.search,
          col,
          i
        );
        $17.each(settings.aoColumns[i].searchFixed, function(name, term) {
          _fnFilter7(settings.aiDisplay, settings, term, {}, i);
        });
      }
      _fnFilterCustom7(settings);
    }
    settings.bFiltered = true;
    _fnCallbackFire7(settings, null, "search", [settings]);
  }
  function _fnFilterCustom7(settings) {
    var filters = DataTable7.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = [];
      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];
        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      displayRows.push.apply(displayRows, rows);
    }
  }
  function _fnFilter7(searchRows, settings, input, options, column) {
    if (input === "") {
      return;
    }
    var i = 0;
    var searchFunc = typeof input === "function" ? input : null;
    var rpSearch = input instanceof RegExp ? input : searchFunc ? null : _fnFilterCreateSearch7(input, options);
    while (i < searchRows.length) {
      var row = settings.aoData[searchRows[i]];
      var data = column === void 0 ? row._sFilterRow : row._aFilterData[column];
      if (searchFunc && !searchFunc(data, row._aData, searchRows[i], column) || rpSearch && !rpSearch.test(data)) {
        searchRows.splice(i, 1);
        i--;
      }
      i++;
    }
  }
  function _fnFilterCreateSearch7(search, inOpts) {
    var not = [];
    var options = $17.extend({}, {
      boundary: false,
      caseInsensitive: true,
      exact: false,
      regex: false,
      smart: true
    }, inOpts);
    if (typeof search !== "string") {
      search = search.toString();
    }
    search = _normalize7(search);
    if (options.exact) {
      return new RegExp(
        "^" + _fnEscapeRegex7(search) + "$",
        options.caseInsensitive ? "i" : ""
      );
    }
    search = options.regex ? search : _fnEscapeRegex7(search);
    if (options.smart) {
      var parts = search.match(/!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""];
      var a = parts.map(function(word) {
        var negative = false;
        var m2;
        if (word.charAt(0) === "!") {
          negative = true;
          word = word.substring(1);
        }
        if (word.charAt(0) === '"') {
          m2 = word.match(/^"(.*)"$/);
          word = m2 ? m2[1] : word;
        } else if (word.charAt(0) === "\u201C") {
          m2 = word.match(/^\u201C(.*)\u201D$/);
          word = m2 ? m2[1] : word;
        }
        if (negative) {
          if (word.length > 1) {
            not.push("(?!" + word + ")");
          }
          word = "";
        }
        return word.replace(/"/g, "");
      });
      var match = not.length ? not.join("") : "";
      var boundary = options.boundary ? "\\b" : "";
      search = "^(?=.*?" + boundary + a.join(")(?=.*?" + boundary) + ")(" + match + ".)*$";
    }
    return new RegExp(search, options.caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex7 = DataTable7.util.escapeRegex;
  var __filter_div7 = $17("<div>")[0];
  var __filter_div_textContent7 = __filter_div7.textContent !== void 0;
  function _fnFilterData7(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var column;
    var j, jen, filterData, cellData, row;
    var wasInvalidated = false;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aFilterData) {
        filterData = [];
        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];
          if (column.bSearchable) {
            cellData = _fnGetCellData7(settings, rowIdx, j, "filter");
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div7.innerHTML = cellData;
            cellData = __filter_div_textContent7 ? __filter_div7.textContent : __filter_div7.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnInitialise7(settings) {
    var i, iAjaxStart = settings.iInitDisplayStart;
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise7(settings);
      }, 200);
      return;
    }
    _fnBuildHead7(settings, "header");
    _fnBuildHead7(settings, "footer");
    _fnDrawHead7(settings, settings.aoHeader);
    _fnDrawHead7(settings, settings.aoFooter);
    _fnAddOptionsHtml7(settings);
    _fnSortInit7(settings);
    _colGroup7(settings);
    _fnProcessingDisplay7(settings, true);
    _fnCallbackFire7(settings, null, "preInit", [settings], true);
    _fnReDraw7(settings);
    var dataSrc = _fnDataSource7(settings);
    if (dataSrc != "ssp") {
      if (dataSrc == "ajax") {
        _fnBuildAjax7(settings, {}, function(json) {
          var aData = _fnAjaxDataSrc7(settings, json);
          for (i = 0; i < aData.length; i++) {
            _fnAddData7(settings, aData[i]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw7(settings);
          _fnProcessingDisplay7(settings, false);
          _fnInitComplete7(settings);
        }, settings);
      } else {
        _fnInitComplete7(settings);
        _fnProcessingDisplay7(settings, false);
      }
    }
  }
  function _fnInitComplete7(settings) {
    if (settings._bInitComplete) {
      return;
    }
    var args = [settings, settings.json];
    settings._bInitComplete = true;
    _fnAdjustColumnSizing7(settings);
    _fnCallbackFire7(settings, null, "plugin-init", args, true);
    _fnCallbackFire7(settings, "aoInitComplete", "init", args, true);
  }
  function _fnLengthChange7(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow7(settings);
    _fnCallbackFire7(settings, null, "length", [settings, len]);
  }
  function _fnPageChange7(settings, action, redraw) {
    var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;
      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;
      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else if (action === "ellipsis") {
      return;
    } else {
      _fnLog7(settings, 0, "Unknown paging action: " + action, 5);
    }
    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;
    _fnCallbackFire7(settings, null, changed ? "page" : "page-nc", [settings]);
    if (changed && redraw) {
      _fnDraw7(settings);
    }
    return changed;
  }
  function _processingHtml7(settings) {
    var table = settings.nTable;
    if (settings.oFeatures.bProcessing) {
      var n = $17("<div/>", {
        "id": settings.sTableId + "_processing",
        "class": settings.oClasses.processing.container,
        "role": "status"
      }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>").insertBefore(table);
      $17(table).on("processing.dt.DT", function(e, s, show) {
        n.css("display", show ? "block" : "none");
      });
    }
  }
  function _fnProcessingDisplay7(settings, show) {
    _fnCallbackFire7(settings, null, "processing", [settings, show]);
  }
  function _fnFeatureHtmlTable7(settings) {
    var table = $17(settings.nTable);
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses.scrolling;
    var caption = settings.captionNode;
    var captionSide = caption ? caption._captionSide : null;
    var headerClone = $17(table[0].cloneNode(false));
    var footerClone = $17(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size = function(s) {
      return !s ? null : _fnStringToCss7(s);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $17(_div, { "class": classes.container }).append(
      $17(_div, { "class": classes.header.self }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: scrollX ? size(scrollX) : "100%"
      }).append(
        $17(_div, { "class": classes.header.inner }).css({
          "box-sizing": "content-box",
          width: scroll.sXInner || "100%"
        }).append(
          headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
            table.children("thead")
          )
        )
      )
    ).append(
      $17(_div, { "class": classes.body }).css({
        position: "relative",
        overflow: "auto",
        width: size(scrollX)
      }).append(table)
    );
    if (footer) {
      scroller.append(
        $17(_div, { "class": classes.footer.self }).css({
          overflow: "hidden",
          border: 0,
          width: scrollX ? size(scrollX) : "100%"
        }).append(
          $17(_div, { "class": classes.footer.inner }).append(
            footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
              table.children("tfoot")
            )
          )
        )
      );
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    $17(scrollBody).on("scroll.DT", function() {
      var scrollLeft = this.scrollLeft;
      scrollHead.scrollLeft = scrollLeft;
      if (footer) {
        scrollFoot.scrollLeft = scrollLeft;
      }
    });
    $17("th, td", scrollHead).on("focus", function() {
      var scrollLeft = scrollHead.scrollLeft;
      scrollBody.scrollLeft = scrollLeft;
      if (footer) {
        scrollBody.scrollLeft = scrollLeft;
      }
    });
    $17(scrollBody).css("max-height", scrollY);
    if (!scroll.bCollapse) {
      $17(scrollBody).css("height", scrollY);
    }
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push(_fnScrollDraw7);
    return scroller[0];
  }
  function _fnScrollDraw7(settings) {
    var scroll = settings.oScroll, barWidth = scroll.iBarWidth, divHeader = $17(settings.nScrollHead), divHeaderInner = divHeader.children("div"), divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $17(divBodyEl), divFooter = $17(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $17(settings.nTHead), table = $17(settings.nTable), footer = settings.nTFoot && $17("th, td", settings.nTFoot).length ? $17(settings.nTFoot) : null, browser = settings.oBrowser, headerCopy, footerCopy;
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing7(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    headerCopy = header.clone().prependTo(table);
    headerCopy.find("th, td").removeAttr("tabindex");
    headerCopy.find("[id]").removeAttr("id");
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerCopy.find("[id]").removeAttr("id");
    }
    if (settings.aiDisplay.length) {
      var colSizes = table.find("tbody tr").eq(0).find("th, td").map(function(vis) {
        return {
          idx: _fnVisibleToColumnIndex7(settings, vis),
          width: $17(this).outerWidth()
        };
      });
      for (var i = 0; i < colSizes.length; i++) {
        var colEl = settings.aoColumns[colSizes[i].idx].colEl[0];
        var colWidth = colEl.style.width.replace("px", "");
        if (colWidth !== colSizes[i].width) {
          colEl.style.width = colSizes[i].width + "px";
        }
      }
    }
    divHeaderTable.find("colgroup").remove();
    divHeaderTable.append(settings.colgroup.clone());
    if (footer) {
      divFooterTable.find("colgroup").remove();
      divFooterTable.append(settings.colgroup.clone());
    }
    $17("th, td", headerCopy).each(function() {
      $17(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
    });
    if (footer) {
      $17("th, td", footerCopy).each(function() {
        $17(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
      });
    }
    var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var paddingSide = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    var outerWidth = table.outerWidth();
    divHeaderTable.css("width", _fnStringToCss7(outerWidth));
    divHeaderInner.css("width", _fnStringToCss7(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    if (footer) {
      divFooterTable.css("width", _fnStringToCss7(outerWidth));
      divFooterInner.css("width", _fnStringToCss7(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
    }
    table.children("colgroup").prependTo(table);
    divBody.trigger("scroll");
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnCalculateColumnWidths7(settings) {
    if (!settings.oFeatures.bAutoWidth) {
      return;
    }
    var table = settings.nTable, columns = settings.aoColumns, scroll = settings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, visibleColumns = _fnGetColumns7(settings, "bVisible"), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, i, column, columnIdx;
    var styleWidth = table.style.width;
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    _fnCallbackFire7(
      settings,
      null,
      "column-calc",
      { visible: visibleColumns },
      false
    );
    var tmpTable = $17(table.cloneNode()).css("visibility", "hidden").removeAttr("id");
    tmpTable.append("<tbody>");
    var tr = $17("<tr/>").appendTo(tmpTable.find("tbody"));
    tmpTable.append($17(settings.nTHead).clone()).append($17(settings.nTFoot).clone());
    tmpTable.find("tfoot th, tfoot td").css("width", "");
    tmpTable.find("thead th, thead td").each(function() {
      var width = _fnColumnsSumWidth7(settings, this, true, false);
      if (width) {
        this.style.width = width;
        if (scrollX) {
          $17(this).append($17("<div/>").css({
            width,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } else {
        this.style.width = "";
      }
    });
    for (i = 0; i < visibleColumns.length; i++) {
      columnIdx = visibleColumns[i];
      column = columns[columnIdx];
      var longest = _fnGetMaxLenString7(settings, columnIdx);
      var autoClass = _ext7.type.className[column.sType];
      var text = longest + column.sContentPadding;
      var insert = longest.indexOf("<") === -1 ? document.createTextNode(text) : text;
      $17("<td/>").addClass(autoClass).addClass(column.sClass).append(insert).appendTo(tr);
    }
    $17("[name]", tmpTable).removeAttr("name");
    var holder = $17("<div/>").css(
      scrollX || scrollY ? {
        position: "absolute",
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: "hidden"
      } : {}
    ).append(tmpTable).appendTo(tableContainer);
    if (scrollX && scrollXInner) {
      tmpTable.width(scrollXInner);
    } else if (scrollX) {
      tmpTable.css("width", "auto");
      tmpTable.removeAttr("width");
      if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
        tmpTable.width(tableContainer.clientWidth);
      }
    } else if (scrollY) {
      tmpTable.width(tableContainer.clientWidth);
    } else if (tableWidthAttr) {
      tmpTable.width(tableWidthAttr);
    }
    var total = 0;
    var bodyCells = tmpTable.find("tbody tr").eq(0).children();
    for (i = 0; i < visibleColumns.length; i++) {
      var bounding = bodyCells[i].getBoundingClientRect().width;
      total += bounding;
      columns[visibleColumns[i]].sWidth = _fnStringToCss7(bounding);
    }
    table.style.width = _fnStringToCss7(total);
    holder.remove();
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss7(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !settings._reszEvt) {
      var bindResize = function() {
        $17(window).on("resize.DT-" + settings.sInstance, DataTable7.util.throttle(function() {
          if (!settings.bDestroying) {
            _fnAdjustColumnSizing7(settings);
          }
        }));
      };
      bindResize();
      settings._reszEvt = true;
    }
  }
  function _fnGetMaxLenString7(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    if (!column.maxLenString) {
      var s, max = "", maxLen = -1;
      for (var i = 0, ien = settings.aiDisplayMaster.length; i < ien; i++) {
        var rowIdx = settings.aiDisplayMaster[i];
        var data = _fnGetRowDisplay7(settings, rowIdx)[colIdx];
        var cellString = data && typeof data === "object" && data.nodeType ? data.innerHTML : data + "";
        cellString = cellString.replace(/id=".*?"/g, "").replace(/name=".*?"/g, "");
        s = _stripHtml7(cellString).replace(/&nbsp;/g, " ");
        if (s.length > maxLen) {
          max = cellString;
          maxLen = s.length;
        }
      }
      column.maxLenString = max;
    }
    return column.maxLenString;
  }
  function _fnStringToCss7(s) {
    if (s === null) {
      return "0px";
    }
    if (typeof s == "number") {
      return s < 0 ? "0px" : s + "px";
    }
    return s.match(/\d$/) ? s + "px" : s;
  }
  function _colGroup7(settings) {
    var cols = settings.aoColumns;
    settings.colgroup.empty();
    for (i = 0; i < cols.length; i++) {
      if (cols[i].bVisible) {
        settings.colgroup.append(cols[i].colEl);
      }
    }
  }
  function _fnSortInit7(settings) {
    var target = settings.nTHead;
    var headerRows = target.querySelectorAll("tr");
    var legacyTop = settings.bSortCellsTop;
    var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
    if (legacyTop === true) {
      target = headerRows[0];
    } else if (legacyTop === false) {
      target = headerRows[headerRows.length - 1];
    }
    _fnSortAttachListener7(
      settings,
      target,
      target === settings.nTHead ? "tr" + notSelector + " th" + notSelector + ", tr" + notSelector + " td" + notSelector : "th" + notSelector + ", td" + notSelector
    );
    var order = [];
    _fnSortResolve7(settings, order, settings.aaSorting);
    settings.aaSorting = order;
  }
  function _fnSortAttachListener7(settings, node, selector, column, callback) {
    _fnBindAction7(node, selector, function(e) {
      var run = false;
      var columns = column === void 0 ? _fnColumnsFromHeader7(e.target) : [column];
      if (columns.length) {
        for (var i = 0, ien = columns.length; i < ien; i++) {
          var ret = _fnSortAdd7(settings, columns[i], i, e.shiftKey);
          if (ret !== false) {
            run = true;
          }
          if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === "") {
            break;
          }
        }
        if (run) {
          _fnProcessingDisplay7(settings, true);
          setTimeout(function() {
            _fnSort7(settings);
            _fnSortDisplay7(settings, settings.aiDisplay);
            _fnProcessingDisplay7(settings, false);
            _fnReDraw7(settings, false, false);
            if (callback) {
              callback();
            }
          }, 0);
        }
      }
    });
  }
  function _fnSortDisplay7(settings, display) {
    var master = settings.aiDisplayMaster;
    var masterMap = {};
    var map2 = {};
    var i;
    for (i = 0; i < master.length; i++) {
      masterMap[master[i]] = i;
    }
    for (i = 0; i < display.length; i++) {
      map2[display[i]] = masterMap[display[i]];
    }
    display.sort(function(a, b) {
      return map2[a] - map2[b];
    });
  }
  function _fnSortResolve7(settings, nestedSort, sort) {
    var push = function(a) {
      if ($17.isPlainObject(a)) {
        if (a.idx !== void 0) {
          nestedSort.push([a.idx, a.dir]);
        } else if (a.name) {
          var cols = _pluck7(settings.aoColumns, "sName");
          var idx = cols.indexOf(a.name);
          if (idx !== -1) {
            nestedSort.push([idx, a.dir]);
          }
        }
      } else {
        nestedSort.push(a);
      }
    };
    if ($17.isPlainObject(sort)) {
      push(sort);
    } else if (sort.length && typeof sort[0] === "number") {
      push(sort);
    } else if (sort.length) {
      for (var z = 0; z < sort.length; z++) {
        push(sort[z]);
      }
    }
  }
  function _fnSortFlatten7(settings) {
    var i, k, kLen, aSort = [], extSort = DataTable7.ext.type.order, aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $17.isPlainObject(fixed), nestedSort = [];
    if (!settings.oFeatures.bSort) {
      return aSort;
    }
    if (Array.isArray(fixed)) {
      _fnSortResolve7(settings, nestedSort, fixed);
    }
    if (fixedObj && fixed.pre) {
      _fnSortResolve7(settings, nestedSort, fixed.pre);
    }
    _fnSortResolve7(settings, nestedSort, settings.aaSorting);
    if (fixedObj && fixed.post) {
      _fnSortResolve7(settings, nestedSort, fixed.post);
    }
    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      if (aoColumns[srcCol]) {
        aDataSort = aoColumns[srcCol].aDataSort;
        for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
          iCol = aDataSort[k];
          sType = aoColumns[iCol].sType || "string";
          if (nestedSort[i]._idx === void 0) {
            nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
          }
          if (nestedSort[i][1]) {
            aSort.push({
              src: srcCol,
              col: iCol,
              dir: nestedSort[i][1],
              index: nestedSort[i]._idx,
              type: sType,
              formatter: extSort[sType + "-pre"],
              sorter: extSort[sType + "-" + nestedSort[i][1]]
            });
          }
        }
      }
    }
    return aSort;
  }
  function _fnSort7(oSettings, col, dir) {
    var i, ien, iLen, aiOrig = [], extSort = DataTable7.ext.type.order, aoData = oSettings.aoData, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    _fnColumnTypes7(oSettings);
    if (col !== void 0) {
      var srcCol = oSettings.aoColumns[col];
      aSort = [{
        src: col,
        col,
        dir,
        index: 0,
        type: srcCol.sType,
        formatter: extSort[srcCol.sType + "-pre"],
        sorter: extSort[srcCol.sType + "-" + dir]
      }];
      displayMaster = displayMaster.slice();
    } else {
      aSort = _fnSortFlatten7(oSettings);
    }
    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i];
      _fnSortData7(oSettings, sortCol.col);
    }
    if (_fnDataSource7(oSettings) != "ssp" && aSort.length !== 0) {
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[i] = i;
      }
      if (aSort.length && aSort[0].dir === "desc") {
        aiOrig.reverse();
      }
      displayMaster.sort(function(a, b) {
        var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
        for (k = 0; k < len; k++) {
          sort = aSort[k];
          x = dataA[sort.col];
          y = dataB[sort.col];
          if (sort.sorter) {
            test = sort.sorter(x, y);
            if (test !== 0) {
              return test;
            }
          } else {
            test = x < y ? -1 : x > y ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
        }
        x = aiOrig[a];
        y = aiOrig[b];
        return x < y ? -1 : x > y ? 1 : 0;
      });
    } else if (aSort.length === 0) {
      displayMaster.sort(function(x, y) {
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    if (col === void 0) {
      oSettings.bSorted = true;
      _fnCallbackFire7(oSettings, null, "order", [oSettings, aSort]);
    }
    return displayMaster;
  }
  function _fnSortAdd7(settings, colIdx, addIndex, shift) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a, overflow) {
      var idx = a._idx;
      if (idx === void 0) {
        idx = asSorting.indexOf(a[1]);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (!col.bSortable) {
      return false;
    }
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if ((shift || addIndex) && settings.oFeatures.bSortMulti) {
      var sortIdx = _pluck7(sorting, "0").indexOf(colIdx);
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else if (shift) {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      } else {
        sorting.push([colIdx, sorting[0][1], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    }
  }
  function _fnSortingClasses7(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.order.position;
    var sort = _fnSortFlatten7(settings);
    var features = settings.oFeatures;
    var i, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src;
        $17(_pluck7(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      }
      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $17(_pluck7(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData7(settings, colIdx) {
    var column = settings.aoColumns[colIdx];
    var customSort = DataTable7.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(
        settings.oInstance,
        settings,
        colIdx,
        _fnColumnIndexToVisible7(settings, colIdx)
      );
    }
    var row, cellData;
    var formatter = DataTable7.ext.type.order[column.sType + "-pre"];
    var data = settings.aoData;
    for (var rowIdx = 0; rowIdx < data.length; rowIdx++) {
      if (!data[rowIdx]) {
        continue;
      }
      row = data[rowIdx];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[colIdx] || customSort) {
        cellData = customSort ? customData[rowIdx] : (
          // If there was a custom sort function, use data from there
          _fnGetCellData7(settings, rowIdx, colIdx, "sort")
        );
        row._aSortData[colIdx] = formatter ? formatter(cellData, settings) : cellData;
      }
    }
  }
  function _fnSaveState7(settings) {
    if (settings._bLoadingState) {
      return;
    }
    var state = {
      time: +/* @__PURE__ */ new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $17.extend(true, [], settings.aaSorting),
      search: $17.extend({}, settings.oPreviousSearch),
      columns: settings.aoColumns.map(function(col, i) {
        return {
          visible: col.bVisible,
          search: $17.extend({}, settings.aoPreSearchCols[i])
        };
      })
    };
    settings.oSavedState = state;
    _fnCallbackFire7(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
  }
  function _fnLoadState7(settings, init2, callback) {
    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }
    var loaded = function(state2) {
      _fnImplementState7(settings, state2, callback);
    };
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
    if (state !== void 0) {
      _fnImplementState7(settings, state, callback);
    }
    return true;
  }
  function _fnImplementState7(settings, s, callback) {
    var i, ien;
    var columns = settings.aoColumns;
    settings._bLoadingState = true;
    var api = settings._bInitComplete ? new DataTable7.Api(settings) : null;
    if (!s || !s.time) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && s.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var abStateLoad = _fnCallbackFire7(settings, "aoStateLoadParams", "stateLoadParams", [settings, s]);
    if (abStateLoad.indexOf(false) !== -1) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    if (s.columns && columns.length !== s.columns.length) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    settings.oLoadedState = $17.extend(true, {}, s);
    _fnCallbackFire7(settings, null, "stateLoadInit", [settings, s], true);
    if (s.length !== void 0) {
      if (api) {
        api.page.len(s.length);
      } else {
        settings._iDisplayLength = s.length;
      }
    }
    if (s.start !== void 0) {
      if (api === null) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      } else {
        _fnPageChange7(settings, s.start / settings._iDisplayLength);
      }
    }
    if (s.order !== void 0) {
      settings.aaSorting = [];
      $17.each(s.order, function(i2, col2) {
        settings.aaSorting.push(
          col2[0] >= columns.length ? [0, col2[1]] : col2
        );
      });
    }
    if (s.search !== void 0) {
      $17.extend(settings.oPreviousSearch, s.search);
    }
    if (s.columns) {
      for (i = 0, ien = s.columns.length; i < ien; i++) {
        var col = s.columns[i];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i).visible(col.visible, false);
          } else {
            columns[i].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $17.extend(settings.aoPreSearchCols[i], col.search);
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
    settings._bLoadingState = false;
    _fnCallbackFire7(settings, "aoStateLoaded", "stateLoaded", [settings, s]);
    callback();
  }
  function _fnLog7(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable7.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire7(settings, null, "dt-error", [settings, tn, msg], true);
      }
      if (type == "alert") {
        alert(msg);
      } else if (type == "throw") {
        throw new Error(msg);
      } else if (typeof type == "function") {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  function _fnMap7(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $17.each(name, function(i, val) {
        if (Array.isArray(val)) {
          _fnMap7(ret, src, val[0], val[1]);
        } else {
          _fnMap7(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === void 0) {
      mappedName = name;
    }
    if (src[name] !== void 0) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend7(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, prop)) {
        val = extender[prop];
        if ($17.isPlainObject(val)) {
          if (!$17.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $17.extend(true, out[prop], val);
        } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }
    return out;
  }
  function _fnBindAction7(n, selector, fn) {
    $17(n).on("click.DT", selector, function(e) {
      fn(e);
    }).on("keypress.DT", selector, function(e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on("selectstart.DT", selector, function() {
      return false;
    });
  }
  function _fnCallbackReg7(settings, store, fn) {
    if (fn) {
      settings[store].push(fn);
    }
  }
  function _fnCallbackFire7(settings, callbackArr, eventName, args, bubbles) {
    var ret = [];
    if (callbackArr) {
      ret = settings[callbackArr].slice().reverse().map(function(val) {
        return val.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e = $17.Event(eventName + ".dt");
      var table = $17(settings.nTable);
      e.dt = settings.api;
      table[bubbles ? "trigger" : "triggerHandler"](e, args);
      if (bubbles && table.parents("body").length === 0) {
        $17("body").trigger(e, args);
      }
      ret.push(e.result);
    }
    return ret;
  }
  function _fnLengthOverflow7(settings) {
    var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start >= end) {
      start = end - len;
    }
    start -= start % len;
    if (len === -1 || start < 0) {
      start = 0;
    }
    settings._iDisplayStart = start;
  }
  function _fnRenderer7(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable7.ext.renderer[type];
    if ($17.isPlainObject(renderer) && renderer[type]) {
      return host[renderer[type]] || host._;
    } else if (typeof renderer === "string") {
      return host[renderer] || host._;
    }
    return host._;
  }
  function _fnDataSource7(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else if (settings.ajax) {
      return "ajax";
    }
    return "dom";
  }
  function _fnMacros7(settings, str, entries) {
    var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), max = settings.fnRecordsTotal(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, max)).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len))).replace(/_ENTRIES_/g, settings.api.i18n("entries", "", entries)).replace(/_ENTRIES-MAX_/g, settings.api.i18n("entries", "", max)).replace(/_ENTRIES-TOTAL_/g, settings.api.i18n("entries", "", vis));
  }
  var __apiStruct7 = [];
  var __arrayProto7 = Array.prototype;
  var _toSettings7 = function(mixed) {
    var idx, jq;
    var settings = DataTable7.settings;
    var tables = _pluck7(settings, "nTable");
    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oFeatures) {
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
      idx = tables.indexOf(mixed);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === "function") {
      return mixed.settings().toArray();
    } else if (typeof mixed === "string") {
      jq = $17(mixed).get();
    } else if (mixed instanceof $17) {
      jq = mixed.get();
    }
    if (jq) {
      return settings.filter(function(v, idx2) {
        return jq.includes(tables[idx2]);
      });
    }
  };
  _Api7 = function(context, data) {
    if (!(this instanceof _Api7)) {
      return new _Api7(context, data);
    }
    var settings = [];
    var ctxSettings = function(o) {
      var a = _toSettings7(o);
      if (a) {
        settings.push.apply(settings, a);
      }
    };
    if (Array.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = settings.length > 1 ? _unique7(settings) : settings;
    if (data) {
      this.push.apply(this, data);
    }
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
    _Api7.extend(this, this, __apiStruct7);
  };
  DataTable7.Api = _Api7;
  $17.extend(_Api7.prototype, {
    any: function() {
      return this.count() !== 0;
    },
    context: [],
    // array of table settings objects
    count: function() {
      return this.flatten().length;
    },
    each: function(fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }
      return this;
    },
    eq: function(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api7(ctx[idx], this[idx]) : null;
    },
    filter: function(fn) {
      var a = __arrayProto7.filter.call(this, fn, this);
      return new _Api7(this.context, a);
    },
    flatten: function() {
      var a = [];
      return new _Api7(this.context, a.concat.apply(a, this.toArray()));
    },
    get: function(idx) {
      return this[idx];
    },
    join: __arrayProto7.join,
    includes: function(find) {
      return this.indexOf(find) === -1 ? false : true;
    },
    indexOf: __arrayProto7.indexOf,
    iterator: function(flatten, type, fn, alwaysNew) {
      var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
      if (typeof flatten === "string") {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }
      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api7(context[i]);
        if (type === "table") {
          ret = fn.call(apiInst, context[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "columns" || type === "rows") {
          ret = fn.call(apiInst, context[i], this[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "every" || type === "column" || type === "column-rows" || type === "row" || type === "cell") {
          items = this[i];
          if (type === "column-rows") {
            rows = _selector_row_indexes7(context[i], selector.opts);
          }
          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];
            if (type === "cell") {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }
            if (ret !== void 0) {
              a.push(ret);
            }
          }
        }
      }
      if (a.length || alwaysNew) {
        var api = new _Api7(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
    lastIndexOf: __arrayProto7.lastIndexOf,
    length: 0,
    map: function(fn) {
      var a = __arrayProto7.map.call(this, fn, this);
      return new _Api7(this.context, a);
    },
    pluck: function(prop) {
      var fn = DataTable7.util.get(prop);
      return this.map(function(el) {
        return fn(el);
      });
    },
    pop: __arrayProto7.pop,
    push: __arrayProto7.push,
    reduce: __arrayProto7.reduce,
    reduceRight: __arrayProto7.reduceRight,
    reverse: __arrayProto7.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto7.shift,
    slice: function() {
      return new _Api7(this.context, this);
    },
    sort: __arrayProto7.sort,
    splice: __arrayProto7.splice,
    toArray: function() {
      return __arrayProto7.slice.call(this);
    },
    to$: function() {
      return $17(this);
    },
    toJQuery: function() {
      return $17(this);
    },
    unique: function() {
      return new _Api7(this.context, _unique7(this.toArray()));
    },
    unshift: __arrayProto7.unshift
  });
  function _api_scope7(scope, fn, struc) {
    return function() {
      var ret = fn.apply(scope || this, arguments);
      _Api7.extend(ret, ret, struc.methodExt);
      return ret;
    };
  }
  function _api_find7(src, name) {
    for (var i = 0, ien = src.length; i < ien; i++) {
      if (src[i].name === name) {
        return src[i];
      }
    }
    return null;
  }
  window.__apiStruct = __apiStruct7;
  _Api7.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api7) && !obj.__dt_wrapper) {
      return;
    }
    var i, ien, struct;
    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i];
      if (struct.name === "__proto__") {
        continue;
      }
      obj[struct.name] = struct.type === "function" ? _api_scope7(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api7.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api7.register = _api_register7 = function(name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api7.register(name[j], val);
      }
      return;
    }
    var i, ien, heir = name.split("."), struct = __apiStruct7, key, method;
    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf("()") !== -1;
      key = method ? heir[i].replace("()", "") : heir[i];
      var src = _api_find7(struct, key);
      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: "object"
        };
        struct.push(src);
      }
      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === "function" ? "function" : $17.isPlainObject(val) ? "object" : "other";
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api7.registerPlural = _api_registerPlural7 = function(pluralName, singularName, val) {
    _Api7.register(pluralName, val);
    _Api7.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else if (ret instanceof _Api7) {
        return ret.length ? Array.isArray(ret[0]) ? new _Api7(ret.context, ret[0]) : (
          // Array results are 'enhanced'
          ret[0]
        ) : void 0;
      }
      return ret;
    });
  };
  var __table_selector7 = function(selector, a) {
    if (Array.isArray(selector)) {
      var result = [];
      selector.forEach(function(sel) {
        var inner = __table_selector7(sel, a);
        result.push.apply(result, inner);
      });
      return result.filter(function(item) {
        return item;
      });
    }
    if (typeof selector === "number") {
      return [a[selector]];
    }
    var nodes = a.map(function(el) {
      return el.nTable;
    });
    return $17(nodes).filter(selector).map(function() {
      var idx = nodes.indexOf(this);
      return a[idx];
    }).toArray();
  };
  _api_register7("tables()", function(selector) {
    return selector !== void 0 && selector !== null ? new _Api7(__table_selector7(selector, this.context)) : this;
  });
  _api_register7("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api7(ctx[0]) : tables;
  });
  [
    ["nodes", "node", "nTable"],
    ["body", "body", "nTBody"],
    ["header", "header", "nTHead"],
    ["footer", "footer", "nTFoot"]
  ].forEach(function(item) {
    _api_registerPlural7(
      "tables()." + item[0] + "()",
      "table()." + item[1] + "()",
      function() {
        return this.iterator("table", function(ctx) {
          return ctx[item[2]];
        }, 1);
      }
    );
  });
  [
    ["header", "aoHeader"],
    ["footer", "aoFooter"]
  ].forEach(function(item) {
    _api_register7("table()." + item[0] + ".structure()", function(selector) {
      var indexes = this.columns(selector).indexes().flatten();
      var ctx = this.context[0];
      return _fnHeaderLayout7(ctx, ctx[item[1]], indexes);
    });
  });
  _api_registerPlural7("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register7("tables().every()", function(fn) {
    var that = this;
    return this.iterator("table", function(s, i) {
      fn.call(that.table(i), i);
    });
  });
  _api_register7("caption()", function(value, side) {
    var context = this.context;
    if (value === void 0) {
      var caption = context[0].captionNode;
      return caption && context.length ? caption.innerHTML : null;
    }
    return this.iterator("table", function(ctx) {
      var table = $17(ctx.nTable);
      var caption2 = $17(ctx.captionNode);
      var container = $17(ctx.nTableWrapper);
      if (!caption2.length) {
        caption2 = $17("<caption/>").html(value);
        ctx.captionNode = caption2[0];
        if (!side) {
          table.prepend(caption2);
          side = caption2.css("caption-side");
        }
      }
      caption2.html(value);
      if (side) {
        caption2.css("caption-side", side);
        caption2[0]._captionSide = side;
      }
      if (container.find("div.dataTables_scroll").length) {
        var selector = side === "top" ? "Head" : "Foot";
        container.find("div.dataTables_scroll" + selector + " table").prepend(caption2);
      } else {
        table.prepend(caption2);
      }
    }, 1);
  });
  _api_register7("caption.node()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].captionNode : null;
  });
  _api_register7("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw7(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw7(settings, paging === false);
      }
    });
  });
  _api_register7("page()", function(action) {
    if (action === void 0) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange7(settings, action);
    });
  });
  _api_register7("page.info()", function() {
    if (this.context.length === 0) {
      return void 0;
    }
    var settings = this.context[0], start = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource7(settings) === "ssp"
    };
  });
  _api_register7("page.len()", function(len) {
    if (len === void 0) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange7(settings, len);
    });
  });
  var __reload7 = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api7(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource7(settings) == "ssp") {
      _fnReDraw7(settings, holdPosition);
    } else {
      _fnProcessingDisplay7(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax7(settings, {}, function(json) {
        _fnClearTable7(settings);
        var data = _fnAjaxDataSrc7(settings, json);
        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData7(settings, data[i]);
        }
        _fnReDraw7(settings, holdPosition);
        _fnInitComplete7(settings);
        _fnProcessingDisplay7(settings, false);
      });
    }
  };
  _api_register7("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register7("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register7("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload7(settings, resetPaging === false, callback);
    });
  });
  _api_register7("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === void 0) {
      if (ctx.length === 0) {
        return void 0;
      }
      ctx = ctx[0];
      return $17.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax;
    }
    return this.iterator("table", function(settings) {
      if ($17.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register7("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload7(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run7 = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
      selector = [selector];
    }
    for (i = 0, ien = selector.length; i < ien; i++) {
      a = selector[i] && selector[i].split && !selector[i].match(/[[(:]/) ? selector[i].split(",") : [selector[i]];
      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === "string" ? a[j].trim() : a[j]);
        res = res.filter(function(item) {
          return item !== null && item !== void 0;
        });
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext7.selector[type];
    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }
    return _unique7(out);
  };
  var _selector_opts7 = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === void 0) {
      opts.search = opts.filter;
    }
    return $17.extend({
      search: "none",
      order: "current",
      page: "all"
    }, opts);
  };
  var _selector_first7 = function(old) {
    let inst = new _Api7(old.context[0]);
    if (old.length) {
      inst.push(old[0]);
    }
    inst.selector = old.selector;
    if (inst.length && inst[0].length > 1) {
      inst[0].splice(1);
    }
    return inst;
  };
  var _selector_row_indexes7 = function(settings, opts) {
    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order = opts.order, page = opts.page;
    if (page == "current") {
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == "current" || order == "applied") {
      if (search == "none") {
        a = displayMaster.slice();
      } else if (search == "applied") {
        a = displayFiltered.slice();
      } else if (search == "removed") {
        var displayFilteredMap = {};
        for (i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }
        displayMaster.forEach(function(item) {
          if (!Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
            a.push(item);
          }
        });
      }
    } else if (order == "index" || order == "original") {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (!settings.aoData[i]) {
          continue;
        }
        if (search == "none") {
          a.push(i);
        } else {
          tmp = displayFiltered.indexOf(i);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(i);
          }
        }
      }
    } else if (typeof order === "number") {
      var ordered = _fnSort7(settings, order, "asc");
      if (search === "none") {
        a = ordered;
      } else {
        for (i = 0; i < ordered.length; i++) {
          tmp = displayFiltered.indexOf(ordered[i]);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(ordered[i]);
          }
        }
      }
    }
    return a;
  };
  var __row_selector7 = function(settings, selector, opts) {
    var rows;
    var run = function(sel) {
      var selInt = _intVal7(sel);
      var aoData = settings.aoData;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      if (!rows) {
        rows = _selector_row_indexes7(settings, opts);
      }
      if (selInt !== null && rows.indexOf(selInt) !== -1) {
        return [selInt];
      } else if (sel === null || sel === void 0 || sel === "") {
        return rows;
      }
      if (typeof sel === "function") {
        return rows.map(function(idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex;
        var cellIdx = sel._DT_CellIndex;
        if (rowIdx !== void 0) {
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $17(sel).closest("*[data-dt-row]");
          return host.length ? [host.data("dt-row")] : [];
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== void 0) {
          return [rowObj.idx];
        }
      }
      var nodes = _removeEmpty7(
        _pluck_order7(settings.aoData, rows, "nTr")
      );
      return $17(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    var matched = _selector_run7("row", selector, run, settings, opts);
    if (opts.order === "current" || opts.order === "applied") {
      _fnSortDisplay7(settings, matched);
    }
    return matched;
  };
  _api_register7("rows()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($17.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts7(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector7(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register7("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || void 0;
    }, 1);
  });
  _api_register7("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order7(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural7("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r = settings.aoData[row];
      return type === "search" ? r._aFilterData : r._aSortData;
    }, 1);
  });
  _api_registerPlural7("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate7(settings, row, src);
    });
  });
  _api_registerPlural7("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural7("rows().ids()", "row().id()", function(hash) {
    var a = [];
    var context = this.context;
    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? "#" : "") + id);
      }
    }
    return new _Api7(context, a);
  });
  _api_registerPlural7("rows().remove()", "row().remove()", function() {
    this.iterator("row", function(settings, row) {
      var data = settings.aoData;
      var rowData = data[row];
      var idx = settings.aiDisplayMaster.indexOf(row);
      if (idx !== -1) {
        settings.aiDisplayMaster.splice(idx, 1);
      }
      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      }
      _fnLengthOverflow7(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== void 0) {
        delete settings.aIds[id];
      }
      data[row] = null;
    });
    return this;
  });
  _api_register7("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i, ien;
      var out = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr7(settings, row)[0]);
        } else {
          out.push(_fnAddData7(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    modRows.push.apply(modRows, newRows);
    return modRows;
  });
  _api_register7("row()", function(selector, opts) {
    return _selector_first7(this.rows(selector, opts));
  });
  _api_register7("row().data()", function(data) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]]._aData : void 0;
    }
    var row = ctx[0].aoData[this[0]];
    row._aData = data;
    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn7(ctx[0].rowId)(data, row.nTr.id);
    }
    _fnInvalidate7(ctx[0], this[0], "data");
    return this;
  });
  _api_register7("row().node()", function() {
    var ctx = this.context;
    return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]].nTr || null : null;
  });
  _api_register7("row.add()", function(row) {
    if (row instanceof $17 && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr7(settings, row)[0];
      }
      return _fnAddData7(settings, row);
    });
    return this.row(rows[0]);
  });
  $17(document).on("plugin-init.dt", function(e, context) {
    var api = new _Api7(context);
    api.on("stateSaveParams.DT", function(e2, settings, d) {
      var idFn = settings.rowIdFn;
      var rows = settings.aiDisplayMaster;
      var ids = [];
      for (var i = 0; i < rows.length; i++) {
        var rowIdx = rows[i];
        var data = settings.aoData[rowIdx];
        if (data._detailsShow) {
          ids.push("#" + idFn(data._aData));
        }
      }
      d.childRows = ids;
    });
    api.on("stateLoaded.DT", function(e2, settings, state) {
      __details_state_load7(api, state);
    });
    __details_state_load7(api, api.state.loaded());
  });
  var __details_state_load7 = function(api, state) {
    if (state && state.childRows) {
      api.rows(state.childRows.map(function(id) {
        return id.replace(/(?<!\\):/g, "\\:");
      })).every(function() {
        _fnCallbackFire7(api.settings()[0], null, "requestChild", [this]);
      });
    }
  };
  var __details_add7 = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r, k) {
      if (Array.isArray(r) || r instanceof $17) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }
        return;
      }
      if (r.nodeName && r.nodeName.toLowerCase() === "tr") {
        r.setAttribute("data-dt-row", row.idx);
        rows.push(r);
      } else {
        var created = $17("<tr><td></td></tr>").attr("data-dt-row", row.idx).addClass(k);
        $17("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns7(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.detach();
    }
    row._details = $17(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_state7 = DataTable7.util.throttle(
    function(ctx) {
      _fnSaveState7(ctx[0]);
    },
    500
  );
  var __details_remove7 = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = void 0;
        row._details = void 0;
        $17(row.nTr).removeClass("dt-hasChild");
        __details_state7(ctx);
      }
    }
  };
  var __details_display7 = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
          $17(row.nTr).addClass("dt-hasChild");
        } else {
          row._details.detach();
          $17(row.nTr).removeClass("dt-hasChild");
        }
        _fnCallbackFire7(ctx[0], null, "childRow", [show, api.row(api[0])]);
        __details_events7(ctx[0]);
        __details_state7(ctx);
      }
    }
  };
  var __details_events7 = function(settings) {
    var api = new _Api7(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-sizing" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck7(data, "_details").length > 0) {
      api.on(drawEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({ page: "current" }).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns7(ctx);
        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];
          if (row && row._details) {
            row._details.each(function() {
              var el = $17(this).children("td");
              if (el.length == 1) {
                el.attr("colspan", visible);
              }
            });
          }
        }
      });
      api.on(destroyEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i] && data[i]._details) {
            __details_remove7(api, i);
          }
        }
      });
    }
  };
  var _emp7 = "";
  var _child_obj7 = _emp7 + "row().child";
  var _child_mth7 = _child_obj7 + "()";
  _api_register7(_child_mth7, function(data, klass) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length && ctx[0].aoData[this[0]] ? ctx[0].aoData[this[0]]._details : void 0;
    } else if (data === true) {
      this.child.show();
    } else if (data === false) {
      __details_remove7(this);
    } else if (ctx.length && this.length) {
      __details_add7(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }
    return this;
  });
  _api_register7([
    _child_obj7 + ".show()",
    _child_mth7 + ".show()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display7(this, true);
    return this;
  });
  _api_register7([
    _child_obj7 + ".hide()",
    _child_mth7 + ".hide()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display7(this, false);
    return this;
  });
  _api_register7([
    _child_obj7 + ".remove()",
    _child_mth7 + ".remove()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_remove7(this);
    return this;
  });
  _api_register7(_child_obj7 + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector7 = /^([^:]+):(name|title|visIdx|visible)$/;
  var __columnData7 = function(settings, column, r1, r2, rows, type) {
    var a = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData7(settings, rows[row], column, type));
    }
    return a;
  };
  var __column_header7 = function(settings, column, row) {
    var header = settings.aoHeader;
    var target = row !== void 0 ? row : settings.bSortCellsTop ? 0 : header.length - 1;
    return header[target][column].cell;
  };
  var __column_selector7 = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck7(columns, "sName"), titles = _pluck7(columns, "sTitle"), cells = DataTable7.util.get("[].[].cell")(settings.aoHeader), nodes = _unique7(_flatten7([], cells));
    var run = function(s) {
      var selInt = _intVal7(s);
      if (s === "") {
        return _range7(columns.length);
      }
      if (selInt !== null) {
        return [
          selInt >= 0 ? selInt : (
            // Count from left
            columns.length + selInt
          )
          // Count from right (+ because its a negative value)
        ];
      }
      if (typeof s === "function") {
        var rows = _selector_row_indexes7(settings, opts);
        return columns.map(function(col, idx2) {
          return s(
            idx2,
            __columnData7(settings, idx2, 0, 0, rows),
            __column_header7(settings, idx2)
          ) ? idx2 : null;
        });
      }
      var match = typeof s === "string" ? s.match(__re_column_selector7) : "";
      if (match) {
        switch (match[2]) {
          case "visIdx":
          case "visible":
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = columns.map(function(col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex7(settings, idx)];
          case "name":
            return names.map(function(name, i) {
              return name === match[1] ? i : null;
            });
          case "title":
            return titles.map(function(title, i) {
              return title === match[1] ? i : null;
            });
          default:
            return [];
        }
      }
      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      }
      var jqResult = $17(nodes).filter(s).map(function() {
        return _fnColumnsFromHeader7(this);
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      var host = $17(s).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run7("column", selector, run, settings, opts);
  };
  var __setColumnVis7 = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, cells, i, ien, tr;
    if (vis === void 0) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return false;
    }
    if (vis) {
      var insertBefore = _pluck7(cols, "bVisible").indexOf(true, column + 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        if (data[i]) {
          tr = data[i].nTr;
          cells = data[i].anCells;
          if (tr) {
            tr.insertBefore(cells[column], cells[insertBefore] || null);
          }
        }
      }
    } else {
      $17(_pluck7(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
    _colGroup7(settings);
    return true;
  };
  _api_register7("columns()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($17.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts7(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector7(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural7("columns().header()", "column().header()", function(row) {
    return this.iterator("column", function(settings, column) {
      return __column_header7(settings, column, row);
    }, 1);
  });
  _api_registerPlural7("columns().footer()", "column().footer()", function(row) {
    return this.iterator("column", function(settings, column) {
      var footer = settings.aoFooter;
      if (!footer.length) {
        return null;
      }
      return settings.aoFooter[row !== void 0 ? row : 0][column].cell;
    }, 1);
  });
  _api_registerPlural7("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData7, 1);
  });
  _api_registerPlural7("columns().render()", "column().render()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return __columnData7(settings, column, i, j, rows, type);
    }, 1);
  });
  _api_registerPlural7("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural7("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order7(
        settings.aoData,
        rows,
        type === "search" ? "_aFilterData" : "_aSortData",
        column
      );
    }, 1);
  });
  _api_registerPlural7("columns().init()", "column().init()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column];
    }, 1);
  });
  _api_registerPlural7("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order7(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural7("columns().titles()", "column().title()", function(title, row) {
    return this.iterator("column", function(settings, column) {
      if (typeof title === "number") {
        row = title;
        title = void 0;
      }
      var span = $17("span.dt-column-title", this.column(column).header(row));
      if (title !== void 0) {
        span.html(title);
        return this;
      }
      return span.html();
    }, 1);
  });
  _api_registerPlural7("columns().types()", "column().type()", function() {
    return this.iterator("column", function(settings, column) {
      var type = settings.aoColumns[column].sType;
      if (!type) {
        _fnColumnTypes7(settings);
      }
      return type;
    }, 1);
  });
  _api_registerPlural7("columns().visible()", "column().visible()", function(vis, calc) {
    var that = this;
    var changed = [];
    var ret = this.iterator("column", function(settings, column) {
      if (vis === void 0) {
        return settings.aoColumns[column].bVisible;
      }
      if (__setColumnVis7(settings, column, vis)) {
        changed.push(column);
      }
    });
    if (vis !== void 0) {
      this.iterator("table", function(settings) {
        _fnDrawHead7(settings, settings.aoHeader);
        _fnDrawHead7(settings, settings.aoFooter);
        if (!settings.aiDisplay.length) {
          $17(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns7(settings));
        }
        _fnSaveState7(settings);
        that.iterator("column", function(settings2, column) {
          if (changed.includes(column)) {
            _fnCallbackFire7(settings2, null, "column-visibility", [settings2, column, vis, calc]);
          }
        });
        if (changed.length && (calc === void 0 || calc)) {
          that.columns.adjust();
        }
      });
    }
    return ret;
  });
  _api_registerPlural7("columns().widths()", "column().width()", function() {
    var columns = this.columns(":visible").count();
    var row = $17("<tr>").html("<td>" + Array(columns).join("</td><td>") + "</td>");
    $17(this.table().body()).append(row);
    var widths = row.children().map(function() {
      return $17(this).outerWidth();
    });
    row.remove();
    return this.iterator("column", function(settings, column) {
      var visIdx = _fnColumnIndexToVisible7(settings, column);
      return visIdx !== null ? widths[visIdx] : 0;
    }, 1);
  });
  _api_registerPlural7("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible7(settings, column) : column;
    }, 1);
  });
  _api_register7("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing7(settings);
    }, 1);
  });
  _api_register7("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex7(ctx, idx);
      } else if (type === "fromData" || type === "toVisible") {
        return _fnColumnIndexToVisible7(ctx, idx);
      }
    }
  });
  _api_register7("column()", function(selector, opts) {
    return _selector_first7(this.columns(selector, opts));
  });
  var __cell_selector7 = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes7(settings, opts);
    var cells = _removeEmpty7(_pluck_order7(data, rows, "anCells"));
    var allCells = $17(_flatten7([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;
    var run = function(s) {
      var fnSelector = typeof s === "function";
      if (s === null || s === void 0 || fnSelector) {
        a = [];
        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];
          for (j = 0; j < columns; j++) {
            o = {
              row,
              column: j
            };
            if (fnSelector) {
              host = data[row];
              if (s(o, _fnGetCellData7(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              a.push(o);
            }
          }
        }
        return a;
      }
      if ($17.isPlainObject(s)) {
        return s.column !== void 0 && s.row !== void 0 && rows.indexOf(s.row) !== -1 ? [s] : [];
      }
      var jqResult = allCells.filter(s).map(function(i2, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      host = $17(s).closest("*[data-dt-row]");
      return host.length ? [{
        row: host.data("dt-row"),
        column: host.data("dt-column")
      }] : [];
    };
    return _selector_run7("cell", selector, run, settings, opts);
  };
  _api_register7("cells()", function(rowSelector, columnSelector, opts) {
    if ($17.isPlainObject(rowSelector)) {
      if (rowSelector.row === void 0) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($17.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === void 0) {
      return this.iterator("table", function(settings) {
        return __cell_selector7(settings, rowSelector, _selector_opts7(opts));
      });
    }
    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {};
    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator("table", function(settings, idx) {
      var a = [];
      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }
      return a;
    }, 1);
    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $17.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts
    });
    return cells;
  });
  _api_registerPlural7("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : void 0;
    }, 1);
  });
  _api_register7("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData7(settings, row, column);
    }, 1);
  });
  _api_registerPlural7("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural7("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData7(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural7("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {
        row,
        column,
        columnVisible: _fnColumnIndexToVisible7(settings, column)
      };
    }, 1);
  });
  _api_registerPlural7("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate7(settings, row, src, column);
    });
  });
  _api_register7("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first7(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register7("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === void 0) {
      return ctx.length && cell.length ? _fnGetCellData7(ctx[0], cell[0].row, cell[0].column) : void 0;
    }
    _fnSetCellData7(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate7(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register7("order()", function(order, dir) {
    var ctx = this.context;
    var args = Array.prototype.slice.call(arguments);
    if (order === void 0) {
      return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
    }
    if (typeof order === "number") {
      order = [[order, dir]];
    } else if (args.length > 1) {
      order = args;
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = Array.isArray(order) ? order.slice() : order;
    });
  });
  _api_register7("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener7(settings, node, {}, column, callback);
    });
  });
  _api_register7("order.fixed()", function(set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
      return Array.isArray(fixed) ? { pre: fixed } : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $17.extend(true, {}, set);
    });
  });
  _api_register7([
    "columns().order()",
    "column().order()"
  ], function(dir) {
    var that = this;
    if (!dir) {
      return this.iterator("column", function(settings, idx) {
        var sort = _fnSortFlatten7(settings);
        for (var i = 0, ien = sort.length; i < ien; i++) {
          if (sort[i].col === idx) {
            return sort[i].dir;
          }
        }
        return null;
      }, 1);
    } else {
      return this.iterator("table", function(settings, i) {
        settings.aaSorting = that[i].map(function(col) {
          return [col, dir];
        });
      });
    }
  });
  _api_registerPlural7("columns().orderable()", "column().orderable()", function(directions) {
    return this.iterator("column", function(settings, idx) {
      var col = settings.aoColumns[idx];
      return directions ? col.asSorting : col.bSortable;
    }, 1);
  });
  _api_register7("processing()", function(show) {
    return this.iterator("table", function(ctx) {
      _fnProcessingDisplay7(ctx, show);
    });
  });
  _api_register7("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === void 0) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.search : void 0;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      if (typeof regex === "object") {
        _fnFilterComplete7(settings, $17.extend(settings.oPreviousSearch, regex, {
          search: input
        }));
      } else {
        _fnFilterComplete7(settings, $17.extend(settings.oPreviousSearch, {
          search: input,
          regex: regex === null ? false : regex,
          smart: smart === null ? true : smart,
          caseInsensitive: caseInsen === null ? true : caseInsen
        }));
      }
    });
  });
  _api_register7("search.fixed()", function(name, search) {
    var ret = this.iterator(true, "table", function(settings) {
      var fixed = settings.searchFixed;
      if (!name) {
        return Object.keys(fixed);
      } else if (search === void 0) {
        return fixed[name];
      } else if (search === null) {
        delete fixed[name];
      } else {
        fixed[name] = search;
      }
      return this;
    });
    return name !== void 0 && search === void 0 ? ret[0] : ret;
  });
  _api_registerPlural7(
    "columns().search()",
    "column().search()",
    function(input, regex, smart, caseInsen) {
      return this.iterator("column", function(settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === void 0) {
          return preSearch[column].search;
        }
        if (!settings.oFeatures.bFilter) {
          return;
        }
        if (typeof regex === "object") {
          $17.extend(preSearch[column], regex, {
            search: input
          });
        } else {
          $17.extend(preSearch[column], {
            search: input,
            regex: regex === null ? false : regex,
            smart: smart === null ? true : smart,
            caseInsensitive: caseInsen === null ? true : caseInsen
          });
        }
        _fnFilterComplete7(settings, settings.oPreviousSearch);
      });
    }
  );
  _api_register7(
    [
      "columns().search.fixed()",
      "column().search.fixed()"
    ],
    function(name, search) {
      var ret = this.iterator(true, "column", function(settings, colIdx) {
        var fixed = settings.aoColumns[colIdx].searchFixed;
        if (!name) {
          return Object.keys(fixed);
        } else if (search === void 0) {
          return fixed[name];
        } else if (search === null) {
          delete fixed[name];
        } else {
          fixed[name] = search;
        }
        return this;
      });
      return name !== void 0 && search === void 0 ? ret[0] : ret;
    }
  );
  _api_register7("state()", function(set, ignoreTime) {
    if (!set) {
      return this.context.length ? this.context[0].oSavedState : null;
    }
    var setMutate = $17.extend(true, {}, set);
    return this.iterator("table", function(settings) {
      if (ignoreTime !== false) {
        setMutate.time = +/* @__PURE__ */ new Date() + 100;
      }
      _fnImplementState7(settings, setMutate, function() {
      });
    });
  });
  _api_register7("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register7("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register7("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState7(settings);
    });
  });
  DataTable7.use = function(module, type) {
    if (type === "lib" || module.fn) {
      $17 = module;
    } else if (type == "win" || module.document) {
      window = module;
      document = module.document;
    } else if (type === "datetime" || module.type === "DateTime") {
      DataTable7.DateTime = module;
    }
  };
  DataTable7.factory = function(root, jq) {
    var is = false;
    if (root && root.document) {
      window = root;
      document = root.document;
    }
    if (jq && jq.fn && jq.fn.jquery) {
      $17 = jq;
      is = true;
    }
    return is;
  };
  DataTable7.versionCheck = function(version, version2) {
    var aThis = version2 ? version2.split(".") : DataTable7.version.split(".");
    var aThat = version.split(".");
    var iThis, iThat;
    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable7.isDataTable = function(table) {
    var t = $17(table).get(0);
    var is = false;
    if (table instanceof DataTable7.Api) {
      return true;
    }
    $17.each(DataTable7.settings, function(i, o) {
      var head = o.nScrollHead ? $17("table", o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $17("table", o.nScrollFoot)[0] : null;
      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  DataTable7.tables = function(visible) {
    var api = false;
    if ($17.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a = DataTable7.settings.filter(function(o) {
      return !visible || visible && $17(o.nTable).is(":visible") ? true : false;
    }).map(function(o) {
      return o.nTable;
    });
    return api ? new _Api7(a) : a;
  };
  DataTable7.camelToHungarian = _fnCamelToHungarian7;
  _api_register7("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $17(rows);
    return $17([].concat(
      jqRows.filter(selector).toArray(),
      jqRows.find(selector).toArray()
    ));
  });
  $17.each(["on", "one", "off"], function(i, key) {
    _api_register7(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      args[0] = args[0].split(/\s/).map(function(e) {
        return !e.match(/\.dt\b/) ? e + ".dt" : e;
      }).join(" ");
      var inst = $17(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register7("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable7(settings);
    });
  });
  _api_register7("error()", function(msg) {
    return this.iterator("table", function(settings) {
      _fnLog7(settings, 0, msg);
    });
  });
  _api_register7("settings()", function() {
    return new _Api7(this.context, this.context);
  });
  _api_register7("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register7("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck7(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register7("trigger()", function(name, args, bubbles) {
    return this.iterator("table", function(settings) {
      return _fnCallbackFire7(settings, null, name, args, bubbles);
    }).flatten();
  });
  _api_register7("ready()", function(fn) {
    var ctx = this.context;
    if (!fn) {
      return ctx.length ? ctx[0]._bInitComplete || false : null;
    }
    return this.tables().every(function() {
      if (this.context[0]._bInitComplete) {
        fn.call(this);
      } else {
        this.on("init", function() {
          fn.call(this);
        });
      }
    });
  });
  _api_register7("destroy()", function(remove) {
    remove = remove || false;
    return this.iterator("table", function(settings) {
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $17(table);
      var jqTbody = $17(tbody);
      var jqWrapper = $17(settings.nTableWrapper);
      var rows = settings.aoData.map(function(r) {
        return r ? r.nTr : null;
      });
      var orderClasses = classes.order;
      settings.bDestroying = true;
      _fnCallbackFire7(settings, "aoDestroyCallback", "destroy", [settings], true);
      if (!remove) {
        new _Api7(settings).columns().visible(true);
      }
      jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
      $17(window).off(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.colgroup.remove();
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses7(settings);
      $17("th, td", thead).removeClass(
        orderClasses.canAsc + " " + orderClasses.canDesc + " " + orderClasses.isAsc + " " + orderClasses.isDesc
      ).css("width", "");
      jqTbody.children().detach();
      jqTbody.append(rows);
      var orig = settings.nTableWrapper.parentNode;
      var insertBefore = settings.nTableWrapper.nextSibling;
      var removedMethod = remove ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove && orig) {
        orig.insertBefore(table, insertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.table);
      }
      var idx = DataTable7.settings.indexOf(settings);
      if (idx !== -1) {
        DataTable7.settings.splice(idx, 1);
      }
    });
  });
  $17.each(["column", "row", "cell"], function(i, type) {
    _api_register7(type + "s().every()", function(fn) {
      var opts = this.selector.opts;
      var api = this;
      var inst;
      var counter = 0;
      return this.iterator("every", function(settings, selectedIdx, tableIdx) {
        inst = api[type](selectedIdx, opts);
        if (type === "cell") {
          fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
        } else {
          fn.call(inst, selectedIdx, tableIdx, counter);
        }
        counter++;
      });
    });
  });
  _api_register7("i18n()", function(token, def, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn7(token)(ctx.oLanguage);
    if (resolved === void 0) {
      resolved = def;
    }
    if ($17.isPlainObject(resolved)) {
      resolved = plural !== void 0 && resolved[plural] !== void 0 ? resolved[plural] : resolved._;
    }
    return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
  });
  DataTable7.version = "2.0.5";
  DataTable7.settings = [];
  DataTable7.models = {};
  DataTable7.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     */
    "caseInsensitive": true,
    /**
     * Applied search term
     */
    "search": "",
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     */
    "regex": false,
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     */
    "smart": true,
    /**
     * Flag to indicate if DataTables should only trigger a search when
     * the return key is pressed.
     */
    "return": false
  };
  DataTable7.models.oRow = {
    /**
     * TR element for the row
     */
    "nTr": null,
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     */
    "anCells": null,
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     */
    "_aData": [],
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     */
    "_aSortData": null,
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     */
    "_aFilterData": null,
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     */
    "_sFilterRow": null,
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     */
    "src": null,
    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     */
    "idx": -1,
    /**
     * Cached display value
     */
    displayData: null
  };
  DataTable7.models.oColumn = {
    /**
     * Column index.
     */
    "idx": null,
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     */
    "aDataSort": null,
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     */
    "asSorting": null,
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     */
    "bSearchable": null,
    /**
     * Flag to indicate if the column is sortable or not.
     */
    "bSortable": null,
    /**
     * Flag to indicate if the column is currently visible in the table or not
     */
    "bVisible": null,
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     */
    "_sManualType": null,
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     */
    "_bAttrSrc": false,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     */
    "fnGetData": null,
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     */
    "fnSetData": null,
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     */
    "mData": null,
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     */
    "mRender": null,
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     */
    "sClass": null,
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     */
    "sContentPadding": null,
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     */
    "sName": null,
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     */
    "sSortDataType": "std",
    /**
     * Class to be applied to the header element when sorting on this column
     */
    "sSortingClass": null,
    /**
     * Title of the column - what is seen in the TH element (nTh).
     */
    "sTitle": null,
    /**
     * Column sorting and filtering type
     */
    "sType": null,
    /**
     * Width of the column
     */
    "sWidth": null,
    /**
     * Width of the column when it was first "encountered"
     */
    "sWidthOrig": null,
    /** Cached string which is the longest in the column */
    maxLenString: null,
    /**
     * Store for named searches
     */
    searchFixed: null
  };
  DataTable7.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     */
    "aaData": null,
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     */
    "aaSorting": [[0, "asc"]],
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     */
    "aaSortingFixed": [],
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     */
    "ajax": null,
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     */
    "aLengthMenu": [10, 25, 50, 100],
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     */
    "aoColumns": null,
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     */
    "aoColumnDefs": null,
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     */
    "aoSearchCols": [],
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     */
    "bAutoWidth": true,
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     */
    "bDeferRender": true,
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     */
    "bDestroy": false,
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     */
    "bFilter": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bInfo": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bLengthChange": true,
    /**
     * Enable or disable pagination.
     */
    "bPaginate": true,
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     */
    "bProcessing": false,
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     */
    "bRetrieve": false,
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     */
    "bScrollCollapse": false,
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     */
    "bServerSide": false,
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     */
    "bSort": true,
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     */
    "bSortMulti": true,
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     */
    "bSortCellsTop": null,
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     */
    "bSortClasses": true,
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     */
    "bStateSave": false,
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     */
    "fnCreatedRow": null,
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     */
    "fnDrawCallback": null,
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     */
    "fnFooterCallback": null,
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     */
    "fnFormatNumber": function(toFormat) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     */
    "fnHeaderCallback": null,
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     */
    "fnInfoCallback": null,
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     */
    "fnInitComplete": null,
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     */
    "fnPreDrawCallback": null,
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     */
    "fnRowCallback": null,
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateLoadCallback": function(settings) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            "DataTables_" + settings.sInstance + "_" + location.pathname
          )
        );
      } catch (e) {
        return {};
      }
    },
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     */
    "fnStateLoadParams": null,
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     */
    "fnStateLoaded": null,
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     */
    "fnStateSaveCallback": function(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname,
          JSON.stringify(data)
        );
      } catch (e) {
      }
    },
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     */
    "fnStateSaveParams": null,
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     */
    "iStateDuration": 7200,
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     */
    "iDisplayLength": 10,
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     */
    "iDisplayStart": 0,
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     */
    "iTabIndex": 0,
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     */
    "oClasses": {},
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be sorted
         */
        "orderable": ": Activate to sort",
        /**
         * ARIA label that is added to the table headers when the column is currently being sorted
         */
        "orderableReverse": ": Activate to invert sorting",
        /**
         * ARIA label that is added to the table headers when the column is currently being 
         * sorted and next step is to remove sorting
         */
        "orderableRemove": ": Activate to remove sorting",
        paginate: {
          first: "First",
          last: "Last",
          next: "Next",
          previous: "Previous"
        }
      },
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       */
      "oPaginate": {
        /**
         * Label and character for first page button ()
         */
        "sFirst": "\xAB",
        /**
         * Last page button ()
         */
        "sLast": "\xBB",
        /**
         * Next page button ()
         */
        "sNext": "\u203A",
        /**
         * Previous page button ()
         */
        "sPrevious": "\u2039"
      },
      /**
       * Plural object for the data type the table is showing
       */
      entries: {
        _: "entries",
        1: "entry"
      },
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       */
      "sEmptyTable": "No data available in table",
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       */
      "sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       */
      "sInfoPostFix": "",
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       */
      "sDecimal": "",
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       */
      "sThousands": ",",
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       */
      "sLengthMenu": "_MENU_ _ENTRIES_ per page",
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       */
      "sLoadingRecords": "Loading...",
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       */
      "sProcessing": "",
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       */
      "sSearch": "Search:",
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       */
      "sUrl": "",
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       */
      "sZeroRecords": "No matching records found"
    },
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     */
    "oSearch": $17.extend({}, DataTable7.models.oSearch),
    /**
     * Table and control layout. This replaces the legacy `dom` option.
     */
    layout: {
      topStart: "pageLength",
      topEnd: "search",
      bottomStart: "info",
      bottomEnd: "paging"
    },
    /**
     * Legacy DOM layout option
     */
    "sDom": null,
    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     */
    "searchDelay": null,
    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     */
    "sPaginationType": "full_numbers",
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     */
    "sScrollX": "",
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     */
    "sScrollXInner": "",
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     */
    "sScrollY": "",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     */
    "sServerMethod": "GET",
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     */
    "renderer": null,
    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     */
    "rowId": "DT_RowId",
    /**
     * Caption value
     */
    "caption": null
  };
  _fnHungarianMap7(DataTable7.defaults);
  DataTable7.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     */
    "aDataSort": null,
    "iDataSort": -1,
    ariaTitle: "",
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     */
    "asSorting": ["asc", "desc", ""],
    /**
     * Enable or disable filtering on the data in this column.
     */
    "bSearchable": true,
    /**
     * Enable or disable ordering on this column.
     */
    "bSortable": true,
    /**
     * Enable or disable the display of this column.
     */
    "bVisible": true,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     */
    "fnCreatedCell": null,
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     */
    "mData": null,
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     */
    "mRender": null,
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     */
    "sCellType": "td",
    /**
     * Class to give to each cell in this column.
     */
    "sClass": "",
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     */
    "sContentPadding": "",
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     */
    "sDefaultContent": null,
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     */
    "sName": "",
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     */
    "sSortDataType": "std",
    /**
     * The title of this column.
     */
    "sTitle": null,
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     */
    "sType": null,
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     */
    "sWidth": null
  };
  _fnHungarianMap7(DataTable7.defaults.column);
  DataTable7.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bAutoWidth": null,
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all for DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bDeferRender": null,
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bFilter": null,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bInfo": true,
      /**
       * Used only for compatiblity with DT1
       * @deprecated
       */
      "bLengthChange": true,
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bPaginate": null,
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bProcessing": null,
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bServerSide": null,
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSort": null,
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortMulti": null,
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bSortClasses": null,
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bStateSave": null
    },
    /**
     * Scrolling settings for a table.
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "bCollapse": null,
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       */
      "iBarWidth": 0,
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sX": null,
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @deprecated
       */
      "sXInner": null,
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       */
      "sY": null
    },
    /**
     * Language information for the table.
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       */
      "fnInfoCallback": null
    },
    /**
     * Browser support parameters
     */
    "oBrowser": {
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       */
      "bScrollbarLeft": false,
      /**
       * Browser scrollbar width
       */
      "barWidth": 0
    },
    "ajax": null,
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     */
    "aanFeatures": [],
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     */
    "aoData": [],
    /**
     * Array of indexes which are in the current display (after filtering etc)
     */
    "aiDisplay": [],
    /**
     * Array of indexes for display - no filtering
     */
    "aiDisplayMaster": [],
    /**
     * Map of row ids to data indexes
     */
    "aIds": {},
    /**
     * Store information about each column that is in use
     */
    "aoColumns": [],
    /**
     * Store information about the table's header
     */
    "aoHeader": [],
    /**
     * Store information about the table's footer
     */
    "aoFooter": [],
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "oPreviousSearch": {},
    /**
     * Store for named searches
     */
    searchFixed: {},
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     */
    "aoPreSearchCols": [],
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSorting": null,
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aaSortingFixed": [],
    /**
     * If restoring a table - we should restore its width
     */
    "sDestroyWidth": 0,
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     */
    "aoRowCallback": [],
    /**
     * Callback functions for the header on each draw.
     */
    "aoHeaderCallback": [],
    /**
     * Callback function for the footer on each draw.
     */
    "aoFooterCallback": [],
    /**
     * Array of callback functions for draw callback functions
     */
    "aoDrawCallback": [],
    /**
     * Array of callback functions for row created function
     */
    "aoRowCreatedCallback": [],
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     */
    "aoPreDrawCallback": [],
    /**
     * Callback functions for when the table has been initialised.
     */
    "aoInitComplete": [],
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     */
    "aoStateSaveParams": [],
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     */
    "aoStateLoadParams": [],
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     */
    "aoStateLoaded": [],
    /**
     * Cache the table ID for quick access
     */
    "sTableId": "",
    /**
     * The TABLE node for the main table
     */
    "nTable": null,
    /**
     * Permanent ref to the thead element
     */
    "nTHead": null,
    /**
     * Permanent ref to the tfoot element - if it exists
     */
    "nTFoot": null,
    /**
     * Permanent ref to the tbody element
     */
    "nTBody": null,
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     */
    "nTableWrapper": null,
    /**
     * Indicate if all required information has been read in
     */
    "bInitialised": false,
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     */
    "aoOpenRows": [],
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sDom": null,
    /**
     * Search delay (in mS)
     */
    "searchDelay": null,
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sPaginationType": "two_button",
    /**
     * Number of paging controls on the page. Only used for backwards compatibility
     */
    pagingControls: 0,
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "iStateDuration": 0,
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateSave": [],
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     */
    "aoStateLoad": [],
    /**
     * State that was saved. Useful for back reference
     */
    "oSavedState": null,
    /**
     * State that was loaded. Useful for back reference
     */
    "oLoadedState": null,
    /**
     * Note if draw should be blocked while getting data
     */
    "bAjaxDataGet": true,
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     */
    "jqXHR": null,
    /**
     * JSON returned from the server in the last Ajax request
     */
    "json": void 0,
    /**
     * Data submitted as part of the last Ajax request
     */
    "oAjaxData": void 0,
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sServerMethod": null,
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "fnFormatNumber": null,
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "aLengthMenu": null,
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     */
    "iDraw": 0,
    /**
     * Indicate if a redraw is being done - useful for Ajax
     */
    "bDrawing": false,
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     */
    "iDrawError": -1,
    /**
     * Paging display length
     */
    "_iDisplayLength": 10,
    /**
     * Paging start point - aiDisplay index
     */
    "_iDisplayStart": 0,
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsTotal": 0,
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     */
    "_iRecordsDisplay": 0,
    /**
     * The classes to use for the table
     */
    "oClasses": {},
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bFiltered": false,
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @deprecated
     */
    "bSorted": false,
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSortCellsTop": null,
    /**
     * Initialisation object that is used for the table
     */
    "oInit": null,
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     */
    "aoDestroyCallback": [],
    /**
     * Get the number of records in the current record set, before filtering
     */
    "fnRecordsTotal": function() {
      return _fnDataSource7(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },
    /**
     * Get the number of records in the current record set, after filtering
     */
    "fnRecordsDisplay": function() {
      return _fnDataSource7(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },
    /**
     * Get the display end point - aiDisplay index
     */
    "fnDisplayEnd": function() {
      var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },
    /**
     * The DataTables object for this table
     */
    "oInstance": null,
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     */
    "sInstance": null,
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
    /**
     * Last applied sort
     */
    "aLastSort": [],
    /**
     * Stored plug-in instances
     */
    "oPlugins": {},
    /**
     * Function used to get a row's id from the row's data
     */
    "rowIdFn": null,
    /**
     * Data location where to store a row's id
     */
    "rowId": null,
    caption: "",
    captionNode: null,
    colgroup: null
  };
  var extPagination7 = DataTable7.ext.pager;
  $17.extend(extPagination7, {
    simple: function() {
      return ["previous", "next"];
    },
    full: function() {
      return ["first", "previous", "next", "last"];
    },
    numbers: function() {
      return ["numbers"];
    },
    simple_numbers: function() {
      return ["previous", "numbers", "next"];
    },
    full_numbers: function() {
      return ["first", "previous", "numbers", "next", "last"];
    },
    first_last: function() {
      return ["first", "last"];
    },
    first_last_numbers: function() {
      return ["first", "numbers", "last"];
    },
    // For testing and plug-ins to use
    _numbers: _pagingNumbers7,
    // Number of number buttons - legacy, use `numbers` option for paging feature
    numbers_length: 7
  });
  $17.extend(true, DataTable7.ext.renderer, {
    pagingButton: {
      _: function(settings, buttonType, content, active, disabled) {
        var classes = settings.oClasses.paging;
        var btnClasses = [classes.button];
        var btn;
        if (active) {
          btnClasses.push(classes.active);
        }
        if (disabled) {
          btnClasses.push(classes.disabled);
        }
        if (buttonType === "ellipsis") {
          btn = $17('<span class="ellipsis"></span>').html(content)[0];
        } else {
          btn = $17("<button>", {
            class: btnClasses.join(" "),
            role: "link",
            type: "button"
          }).html(content);
        }
        return {
          display: btn,
          clicker: btn
        };
      }
    },
    pagingContainer: {
      _: function(settings, buttons) {
        return buttons;
      }
    }
  });
  var _filterString7 = function(stripHtml, normalize) {
    return function(str) {
      if (_empty7(str) || typeof str !== "string") {
        return str;
      }
      str = str.replace(_re_new_lines7, " ");
      if (stripHtml) {
        str = _stripHtml7(str);
      }
      if (normalize) {
        str = _normalize7(str, false);
      }
      return str;
    };
  };
  function __mldFnName6(name) {
    return name.replace(/[\W]/g, "_");
  }
  function __mld7(dt, momentFn, luxonFn, dateFn, arg1) {
    if (window.moment) {
      return dt[momentFn](arg1);
    } else if (window.luxon) {
      return dt[luxonFn](arg1);
    }
    return dateFn ? dt[dateFn](arg1) : dt;
  }
  var __mlWarning7 = false;
  function __mldObj7(d, format, locale) {
    var dt;
    if (window.moment) {
      dt = window.moment.utc(d, format, locale, true);
      if (!dt.isValid()) {
        return null;
      }
    } else if (window.luxon) {
      dt = format && typeof d === "string" ? window.luxon.DateTime.fromFormat(d, format) : window.luxon.DateTime.fromISO(d);
      if (!dt.isValid) {
        return null;
      }
      dt.setLocale(locale);
    } else if (!format) {
      dt = new Date(d);
    } else {
      if (!__mlWarning7) {
        alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
      }
      __mlWarning7 = true;
    }
    return dt;
  }
  function __mlHelper7(localeString) {
    return function(from, to, locale, def) {
      if (arguments.length === 0) {
        locale = "en";
        to = null;
        from = null;
      } else if (arguments.length === 1) {
        locale = "en";
        to = from;
        from = null;
      } else if (arguments.length === 2) {
        locale = to;
        to = from;
        from = null;
      }
      var typeName = "datetime" + (to ? "-" + __mldFnName6(to) : "");
      if (!DataTable7.ext.type.order[typeName]) {
        DataTable7.type(typeName, {
          detect: function(d) {
            return d === typeName ? typeName : false;
          },
          order: {
            pre: function(d) {
              return d.valueOf();
            }
          },
          className: "dt-right"
        });
      }
      return function(d, type) {
        if (d === null || d === void 0) {
          if (def === "--now") {
            var local = /* @__PURE__ */ new Date();
            d = new Date(Date.UTC(
              local.getFullYear(),
              local.getMonth(),
              local.getDate(),
              local.getHours(),
              local.getMinutes(),
              local.getSeconds()
            ));
          } else {
            d = "";
          }
        }
        if (type === "type") {
          return typeName;
        }
        if (d === "") {
          return type !== "sort" ? "" : __mldObj7("0000-01-01 00:00:00", null, locale);
        }
        if (to !== null && from === to && type !== "sort" && type !== "type" && !(d instanceof Date)) {
          return d;
        }
        var dt = __mldObj7(d, from, locale);
        if (dt === null) {
          return d;
        }
        if (type === "sort") {
          return dt;
        }
        var formatted = to === null ? __mld7(dt, "toDate", "toJSDate", "")[localeString]() : __mld7(dt, "format", "toFormat", "toISOString", to);
        return type === "display" ? _escapeHtml7(formatted) : formatted;
      };
    };
  }
  var __thousands7 = ",";
  var __decimal7 = ".";
  if (window.Intl !== void 0) {
    try {
      num = new Intl.NumberFormat().formatToParts(100000.1);
      for (i = 0; i < num.length; i++) {
        if (num[i].type === "group") {
          __thousands7 = num[i].value;
        } else if (num[i].type === "decimal") {
          __decimal7 = num[i].value;
        }
      }
    } catch (e) {
    }
  }
  var num;
  var i;
  DataTable7.datetime = function(format, locale) {
    var typeName = "datetime-detect-" + __mldFnName6(format);
    if (!locale) {
      locale = "en";
    }
    if (!DataTable7.ext.type.order[typeName]) {
      DataTable7.type(typeName, {
        detect: function(d) {
          var dt = __mldObj7(d, format, locale);
          return d === "" || dt ? typeName : false;
        },
        order: {
          pre: function(d) {
            return __mldObj7(d, format, locale) || 0;
          }
        },
        className: "dt-right"
      });
    }
  };
  DataTable7.render = {
    date: __mlHelper7("toLocaleDateString"),
    datetime: __mlHelper7("toLocaleString"),
    time: __mlHelper7("toLocaleTimeString"),
    number: function(thousands, decimal, precision, prefix, postfix) {
      if (thousands === null || thousands === void 0) {
        thousands = __thousands7;
      }
      if (decimal === null || decimal === void 0) {
        decimal = __decimal7;
      }
      return {
        display: function(d) {
          if (typeof d !== "number" && typeof d !== "string") {
            return d;
          }
          if (d === "" || d === null) {
            return d;
          }
          var negative = d < 0 ? "-" : "";
          var flo = parseFloat(d);
          var abs = Math.abs(flo);
          if (abs >= 1e11 || abs < 1e-4 && abs !== 0) {
            var exp = flo.toExponential(precision).split(/e\+?/);
            return exp[0] + " x 10<sup>" + exp[1] + "</sup>";
          }
          if (isNaN(flo)) {
            return _escapeHtml7(d);
          }
          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
          if (intPart === 0 && parseFloat(floatPart) === 0) {
            negative = "";
          }
          return negative + (prefix || "") + intPart.toString().replace(
            /\B(?=(\d{3})+(?!\d))/g,
            thousands
          ) + floatPart + (postfix || "");
        }
      };
    },
    text: function() {
      return {
        display: _escapeHtml7,
        filter: _escapeHtml7
      };
    }
  };
  var _extTypes7 = DataTable7.ext.type;
  DataTable7.type = function(name, prop, val) {
    if (!prop) {
      return {
        className: _extTypes7.className[name],
        detect: _extTypes7.detect.find(function(fn) {
          return fn.name === name;
        }),
        order: {
          pre: _extTypes7.order[name + "-pre"],
          asc: _extTypes7.order[name + "-asc"],
          desc: _extTypes7.order[name + "-desc"]
        },
        render: _extTypes7.render[name],
        search: _extTypes7.search[name]
      };
    }
    var setProp = function(prop2, propVal) {
      _extTypes7[prop2][name] = propVal;
    };
    var setDetect = function(fn) {
      var cb = function(d, s) {
        var ret = fn(d, s);
        return ret === true ? name : ret;
      };
      Object.defineProperty(cb, "name", { value: name });
      var idx = _extTypes7.detect.findIndex(function(fn2) {
        return fn2.name === name;
      });
      if (idx === -1) {
        _extTypes7.detect.unshift(cb);
      } else {
        _extTypes7.detect.splice(idx, 1, cb);
      }
    };
    var setOrder = function(obj) {
      _extTypes7.order[name + "-pre"] = obj.pre;
      _extTypes7.order[name + "-asc"] = obj.asc;
      _extTypes7.order[name + "-desc"] = obj.desc;
    };
    if (val === void 0) {
      val = prop;
      prop = null;
    }
    if (prop === "className") {
      setProp("className", val);
    } else if (prop === "detect") {
      setDetect(val);
    } else if (prop === "order") {
      setOrder(val);
    } else if (prop === "render") {
      setProp("render", val);
    } else if (prop === "search") {
      setProp("search", val);
    } else if (!prop) {
      if (val.className) {
        setProp("className", val.className);
      }
      if (val.detect !== void 0) {
        setDetect(val.detect);
      }
      if (val.order) {
        setOrder(val.order);
      }
      if (val.render !== void 0) {
        setProp("render", val.render);
      }
      if (val.search !== void 0) {
        setProp("search", val.search);
      }
    }
  };
  DataTable7.types = function() {
    return _extTypes7.detect.map(function(fn) {
      return fn.name;
    });
  };
  DataTable7.type("string", {
    detect: function() {
      return "string";
    },
    order: {
      pre: function(a) {
        return _empty7(a) ? "" : typeof a === "string" ? a.toLowerCase() : !a.toString ? "" : a.toString();
      }
    },
    search: _filterString7(false, true)
  });
  DataTable7.type("html", {
    detect: function(d) {
      return _empty7(d) || typeof d === "string" && d.indexOf("<") !== -1 ? "html" : null;
    },
    order: {
      pre: function(a) {
        return _empty7(a) ? "" : a.replace ? _stripHtml7(a).trim().toLowerCase() : a + "";
      }
    },
    search: _filterString7(true, true)
  });
  DataTable7.type("date", {
    className: "dt-type-date",
    detect: function(d) {
      if (d && !(d instanceof Date) && !_re_date7.test(d)) {
        return null;
      }
      var parsed = Date.parse(d);
      return parsed !== null && !isNaN(parsed) || _empty7(d) ? "date" : null;
    },
    order: {
      pre: function(d) {
        var ts = Date.parse(d);
        return isNaN(ts) ? -Infinity : ts;
      }
    }
  });
  DataTable7.type("html-num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric7(d, decimal, true) ? "html-num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace7(d, dp, _re_html7, _re_formatted_numeric7);
      }
    },
    search: _filterString7(true, true)
  });
  DataTable7.type("html-num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric7(d, decimal) ? "html-num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace7(d, dp, _re_html7);
      }
    },
    search: _filterString7(true, true)
  });
  DataTable7.type("num-fmt", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber7(d, decimal, true) ? "num-fmt" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace7(d, dp, _re_formatted_numeric7);
      }
    }
  });
  DataTable7.type("num", {
    className: "dt-type-numeric",
    detect: function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber7(d, decimal) ? "num" : null;
    },
    order: {
      pre: function(d, s) {
        var dp = s.oLanguage.sDecimal;
        return __numericReplace7(d, dp);
      }
    }
  });
  var __numericReplace7 = function(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === "-")) {
      return -Infinity;
    }
    var type = typeof d;
    if (type === "number" || type === "bigint") {
      return d;
    }
    if (decimalPlace) {
      d = _numToDecimal7(d, decimalPlace);
    }
    if (d.replace) {
      if (re1) {
        d = d.replace(re1, "");
      }
      if (re2) {
        d = d.replace(re2, "");
      }
    }
    return d * 1;
  };
  $17.extend(true, DataTable7.ext.renderer, {
    footer: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.tfoot.cell);
      }
    },
    header: {
      _: function(settings, cell, classes) {
        cell.addClass(classes.thead.cell);
        if (!settings.oFeatures.bSort) {
          cell.addClass(classes.order.none);
        }
        var legacyTop = settings.bSortCellsTop;
        var headerRows = cell.closest("thead").find("tr");
        var rowIdx = cell.parent().index();
        if (
          // Cells and rows which have the attribute to disable the icons
          cell.attr("data-dt-order") === "disable" || cell.parent().attr("data-dt-order") === "disable" || // Legacy support for `orderCellsTop`. If it is set, then cells
          // which are not in the top or bottom row of the header (depending
          // on the value) do not get the sorting classes applied to them
          legacyTop === true && rowIdx !== 0 || legacyTop === false && rowIdx !== headerRows.length - 1
        ) {
          return;
        }
        $17(settings.nTable).on("order.dt.DT", function(e, ctx, sorting) {
          if (settings !== ctx) {
            return;
          }
          var orderClasses = classes.order;
          var columns = ctx.api.columns(cell);
          var col = settings.aoColumns[columns.flatten()[0]];
          var orderable = columns.orderable().includes(true);
          var ariaType = "";
          var indexes = columns.indexes();
          var sortDirs = columns.orderable(true).flatten();
          var orderedColumns = "," + sorting.map(function(val) {
            return val.col;
          }).join(",") + ",";
          cell.removeClass(
            orderClasses.isAsc + " " + orderClasses.isDesc
          ).toggleClass(orderClasses.none, !orderable).toggleClass(orderClasses.canAsc, orderable && sortDirs.includes("asc")).toggleClass(orderClasses.canDesc, orderable && sortDirs.includes("desc"));
          var sortIdx = orderedColumns.indexOf("," + indexes.toArray().join(",") + ",");
          if (sortIdx !== -1) {
            var orderDirs = columns.order();
            cell.addClass(
              orderDirs.includes("asc") ? orderClasses.isAsc : "" + orderDirs.includes("desc") ? orderClasses.isDesc : ""
            );
          }
          if (sortIdx === 0) {
            var firstSort = sorting[0];
            var sortOrder = col.asSorting;
            cell.attr("aria-sort", firstSort.dir === "asc" ? "ascending" : "descending");
            ariaType = !sortOrder[firstSort.index + 1] ? "Remove" : "Reverse";
          } else {
            cell.removeAttr("aria-sort");
          }
          cell.attr(
            "aria-label",
            orderable ? col.ariaTitle + ctx.api.i18n("oAria.orderable" + ariaType) : col.ariaTitle
          );
          if (orderable) {
            cell.find(".dt-column-title").attr("role", "button");
            cell.attr("tabindex", 0);
          }
        });
      }
    },
    layout: {
      _: function(settings, container, items) {
        var row = $17("<div/>").addClass("dt-layout-row").appendTo(container);
        $17.each(items, function(key, val) {
          var klass = !val.table ? "dt-" + key + " " : "";
          if (val.table) {
            row.addClass("dt-layout-table");
          }
          $17("<div/>").attr({
            id: val.id || null,
            "class": "dt-layout-cell " + klass + (val.className || "")
          }).append(val.contents).appendTo(row);
        });
      }
    }
  });
  DataTable7.feature = {};
  DataTable7.feature.register = function(name, cb, legacy) {
    DataTable7.ext.features[name] = cb;
    if (legacy) {
      _ext7.feature.push({
        cFeature: legacy,
        fnInit: cb
      });
    }
  };
  DataTable7.feature.register("info", function(settings, opts) {
    if (!settings.oFeatures.bInfo) {
      return null;
    }
    var lang = settings.oLanguage, tid = settings.sTableId, n = $17("<div/>", {
      "class": settings.oClasses.info.container
    });
    opts = $17.extend({
      callback: lang.fnInfoCallback,
      empty: lang.sInfoEmpty,
      postfix: lang.sInfoPostFix,
      search: lang.sInfoFiltered,
      text: lang.sInfo
    }, opts);
    settings.aoDrawCallback.push(function(s) {
      _fnUpdateInfo7(s, opts, n);
    });
    if (!settings._infoEl) {
      n.attr({
        "aria-live": "polite",
        id: tid + "_info",
        role: "status"
      });
      $17(settings.nTable).attr("aria-describedby", tid + "_info");
      settings._infoEl = n;
    }
    return n;
  }, "i");
  function _fnUpdateInfo7(settings, opts, node) {
    var start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? opts.text : opts.empty;
    if (total !== max) {
      out += " " + opts.search;
    }
    out += opts.postfix;
    out = _fnMacros7(settings, out);
    if (opts.callback) {
      out = opts.callback.call(
        settings.oInstance,
        settings,
        start,
        end,
        max,
        total,
        out
      );
    }
    node.html(out);
    _fnCallbackFire7(settings, null, "info", [settings, node[0], out]);
  }
  var __searchCounter7 = 0;
  DataTable7.feature.register("search", function(settings, opts) {
    if (!settings.oFeatures.bFilter) {
      return null;
    }
    var classes = settings.oClasses.search;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var input = '<input type="search" class="' + classes.input + '"/>';
    opts = $17.extend({
      placeholder: language.sSearchPlaceholder,
      text: language.sSearch
    }, opts);
    if (opts.text.indexOf("_INPUT_") === -1) {
      opts.text += "_INPUT_";
    }
    opts.text = _fnMacros7(settings, opts.text);
    var end = opts.text.match(/_INPUT_$/);
    var start = opts.text.match(/^_INPUT_/);
    var removed = opts.text.replace(/_INPUT_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_INPUT_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_INPUT_";
    }
    var filter = $17("<div>").addClass(classes.container).append(str.replace(/_INPUT_/, input));
    filter.find("label").attr("for", "dt-search-" + __searchCounter7);
    filter.find("input").attr("id", "dt-search-" + __searchCounter7);
    __searchCounter7++;
    var searchFn = function(event) {
      var val = this.value;
      if (previousSearch.return && event.key !== "Enter") {
        return;
      }
      if (val != previousSearch.search) {
        previousSearch.search = val;
        _fnFilterComplete7(settings, previousSearch);
        settings._iDisplayStart = 0;
        _fnDraw7(settings);
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : 0;
    var jqFilter = $17("input", filter).val(previousSearch.search).attr("placeholder", opts.placeholder).on(
      "keyup.DT search.DT input.DT paste.DT cut.DT",
      searchDelay ? DataTable7.util.debounce(searchFn, searchDelay) : searchFn
    ).on("mouseup.DT", function(e) {
      setTimeout(function() {
        searchFn.call(jqFilter[0], e);
      }, 10);
    }).on("keypress.DT", function(e) {
      if (e.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $17(settings.nTable).on("search.dt.DT", function(ev, s) {
      if (settings === s && jqFilter[0] !== document.activeElement) {
        jqFilter.val(
          typeof previousSearch.search !== "function" ? previousSearch.search : ""
        );
      }
    });
    return filter;
  }, "f");
  DataTable7.feature.register("paging", function(settings, opts) {
    if (!settings.oFeatures.bPaginate) {
      return null;
    }
    opts = $17.extend({
      buttons: DataTable7.ext.pager.numbers_length,
      type: settings.sPaginationType,
      boundaryNumbers: true
    }, opts);
    if (opts.numbers) {
      opts.buttons = opts.numbers;
    }
    var host = $17("<div/>").addClass(settings.oClasses.paging.container + " paging_" + opts.type);
    var draw = function() {
      _pagingDraw7(settings, host, opts);
    };
    settings.aoDrawCallback.push(draw);
    $17(settings.nTable).on("column-sizing.dt.DT", draw);
    return host;
  }, "p");
  function _pagingDraw7(settings, host, opts) {
    if (!settings._bInitComplete) {
      return;
    }
    var plugin = DataTable7.ext.pager[opts.type], aria = settings.oLanguage.oAria.paginate || {}, start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin().map(function(val) {
      return val === "numbers" ? _pagingNumbers7(page, pages, opts.buttons, opts.boundaryNumbers) : val;
    }).flat();
    var buttonEls = [];
    for (var i = 0; i < buttons.length; i++) {
      var button = buttons[i];
      var btnInfo = _pagingButtonInfo7(settings, button, page, pages);
      var btn = _fnRenderer7(settings, "pagingButton")(
        settings,
        button,
        btnInfo.display,
        btnInfo.active,
        btnInfo.disabled
      );
      $17(btn.clicker).attr({
        "aria-controls": settings.sTableId,
        "aria-disabled": btnInfo.disabled ? "true" : null,
        "aria-current": btnInfo.active ? "page" : null,
        "aria-label": aria[button],
        "data-dt-idx": button,
        "tabIndex": btnInfo.disabled ? -1 : settings.iTabIndex
      });
      if (typeof button !== "number") {
        $17(btn.clicker).addClass(button);
      }
      _fnBindAction7(
        btn.clicker,
        { action: button },
        function(e) {
          e.preventDefault();
          _fnPageChange7(settings, e.data.action, true);
        }
      );
      buttonEls.push(btn.display);
    }
    var wrapped = _fnRenderer7(settings, "pagingContainer")(
      settings,
      buttonEls
    );
    var activeEl = host.find(document.activeElement).data("dt-idx");
    host.empty().append(wrapped);
    if (activeEl !== void 0) {
      host.find("[data-dt-idx=" + activeEl + "]").trigger("focus");
    }
    if (buttonEls.length && // any buttons
    opts.numbers > 1 && // prevent infinite
    $17(host).height() >= $17(buttonEls[0]).outerHeight() * 2 - 10) {
      _pagingDraw7(settings, host, $17.extend({}, opts, { numbers: opts.numbers - 2 }));
    }
  }
  function _pagingButtonInfo7(settings, button, page, pages) {
    var lang = settings.oLanguage.oPaginate;
    var o = {
      display: "",
      active: false,
      disabled: false
    };
    switch (button) {
      case "ellipsis":
        o.display = "&#x2026;";
        o.disabled = true;
        break;
      case "first":
        o.display = lang.sFirst;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "previous":
        o.display = lang.sPrevious;
        if (page === 0) {
          o.disabled = true;
        }
        break;
      case "next":
        o.display = lang.sNext;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      case "last":
        o.display = lang.sLast;
        if (pages === 0 || page === pages - 1) {
          o.disabled = true;
        }
        break;
      default:
        if (typeof button === "number") {
          o.display = settings.fnFormatNumber(button + 1);
          if (page === button) {
            o.active = true;
          }
        }
        break;
    }
    return o;
  }
  function _pagingNumbers7(page, pages, buttons, addFirstLast) {
    var numbers = [], half = Math.floor(buttons / 2), before = addFirstLast ? 2 : 1, after = addFirstLast ? 1 : 0;
    if (pages <= buttons) {
      numbers = _range7(0, pages);
    } else if (buttons === 1) {
      numbers = [page];
    } else if (buttons === 3) {
      if (page <= 1) {
        numbers = [0, 1, "ellipsis"];
      } else if (page >= pages - 2) {
        numbers = _range7(pages - 2, pages);
        numbers.unshift("ellipsis");
      } else {
        numbers = ["ellipsis", page, "ellipsis"];
      }
    } else if (page <= half) {
      numbers = _range7(0, buttons - before);
      numbers.push("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
      }
    } else if (page >= pages - 1 - half) {
      numbers = _range7(pages - (buttons - before), pages);
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.unshift(0);
      }
    } else {
      numbers = _range7(page - half + before, page + half - after);
      numbers.push("ellipsis");
      numbers.unshift("ellipsis");
      if (addFirstLast) {
        numbers.push(pages - 1);
        numbers.unshift(0);
      }
    }
    return numbers;
  }
  var __lengthCounter7 = 0;
  DataTable7.feature.register("pageLength", function(settings, opts) {
    var features = settings.oFeatures;
    if (!features.bPaginate || !features.bLengthChange) {
      return null;
    }
    opts = $17.extend({
      menu: settings.aLengthMenu,
      text: settings.oLanguage.sLengthMenu
    }, opts);
    var classes = settings.oClasses.length, tableId = settings.sTableId, menu = opts.menu, lengths = [], language = [], i;
    if (Array.isArray(menu[0])) {
      lengths = menu[0];
      language = menu[1];
    } else {
      for (i = 0; i < menu.length; i++) {
        if ($17.isPlainObject(menu[i])) {
          lengths.push(menu[i].value);
          language.push(menu[i].label);
        } else {
          lengths.push(menu[i]);
          language.push(menu[i]);
        }
      }
    }
    var end = opts.text.match(/_MENU_$/);
    var start = opts.text.match(/^_MENU_/);
    var removed = opts.text.replace(/_MENU_/, "");
    var str = "<label>" + opts.text + "</label>";
    if (start) {
      str = "_MENU_<label>" + removed + "</label>";
    } else if (end) {
      str = "<label>" + removed + "</label>_MENU_";
    }
    var div = $17("<div/>").addClass(classes.container).append(
      str.replace("_MENU_", "<span></span>")
    );
    var textNodes = [];
    div.find("label")[0].childNodes.forEach(function(el) {
      if (el.nodeType === Node.TEXT_NODE) {
        textNodes.push({
          el,
          text: el.textContent
        });
      }
    });
    var updateEntries = function(len) {
      textNodes.forEach(function(node) {
        node.el.textContent = _fnMacros7(settings, node.text, len);
      });
    };
    var select = $17("<select/>", {
      "name": tableId + "_length",
      "aria-controls": tableId,
      "class": classes.select
    });
    for (i = 0; i < lengths.length; i++) {
      select[0][i] = new Option(
        typeof language[i] === "number" ? settings.fnFormatNumber(language[i]) : language[i],
        lengths[i]
      );
    }
    div.find("label").attr("for", "dt-length-" + __lengthCounter7);
    select.attr("id", "dt-length-" + __lengthCounter7);
    __lengthCounter7++;
    div.find("span").replaceWith(select);
    $17("select", div).val(settings._iDisplayLength).on("change.DT", function() {
      _fnLengthChange7(settings, $17(this).val());
      _fnDraw7(settings);
    });
    $17(settings.nTable).on("length.dt.DT", function(e, s, len) {
      if (settings === s) {
        $17("select", div).val(len);
        updateEntries(len);
      }
    });
    updateEntries(settings._iDisplayLength);
    return div;
  }, "l");
  $17.fn.dataTable = DataTable7;
  DataTable7.$ = $17;
  $17.fn.dataTableSettings = DataTable7.settings;
  $17.fn.dataTableExt = DataTable7.ext;
  $17.fn.DataTable = function(opts) {
    return $17(this).dataTable(opts).api();
  };
  $17.each(DataTable7, function(prop, val) {
    $17.fn.DataTable[prop] = val;
  });
  var dataTables_default7 = DataTable7;

  // node_modules/datatables.net-rowgroup/js/dataTables.rowGroup.mjs
  var $18 = import_jquery20.default;
  var RowGroup = function(dt, opts) {
    if (!dataTables_default7.versionCheck || !dataTables_default7.versionCheck("1.11")) {
      throw "RowGroup requires DataTables 1.11 or newer";
    }
    this.c = $18.extend(true, {}, dataTables_default7.defaults.rowGroup, RowGroup.defaults, opts);
    this.s = {
      dt: new dataTables_default7.Api(dt)
    };
    this.dom = {};
    var settings = this.s.dt.settings()[0];
    var existing = settings.rowGroup;
    if (existing) {
      return existing;
    }
    settings.rowGroup = this;
    this._constructor();
  };
  $18.extend(RowGroup.prototype, {
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * API methods for DataTables API interface
     */
    /**
     * Get/set the grouping data source - need to call draw after this is
     * executed as a setter
     * @returns string~RowGroup
     */
    dataSrc: function(val) {
      if (val === void 0) {
        return this.c.dataSrc;
      }
      var dt = this.s.dt;
      this.c.dataSrc = val;
      $18(dt.table().node()).triggerHandler("rowgroup-datasrc.dt", [dt, val]);
      return this;
    },
    /**
     * Disable - need to call draw after this is executed
     * @returns RowGroup
     */
    disable: function() {
      this.c.enable = false;
      return this;
    },
    /**
     * Enable - need to call draw after this is executed
     * @returns RowGroup
     */
    enable: function(flag) {
      if (flag === false) {
        return this.disable();
      }
      this.c.enable = true;
      return this;
    },
    /**
     * Get enabled flag
     * @returns boolean
     */
    enabled: function() {
      return this.c.enable;
    },
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Constructor
     */
    _constructor: function() {
      var that = this;
      var dt = this.s.dt;
      var hostSettings = dt.settings()[0];
      dt.on("draw.dtrg", function(e, s) {
        if (that.c.enable && hostSettings === s) {
          that._draw();
        }
      });
      dt.on("column-visibility.dt.dtrg responsive-resize.dt.dtrg", function() {
        that._adjustColspan();
      });
      dt.on("destroy", function() {
        dt.off(".dtrg");
      });
    },
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Private methods
     */
    /**
     * Adjust column span when column visibility changes
     * @private
     */
    _adjustColspan: function() {
      $18("tr." + this.c.className, this.s.dt.table().body()).find("th:visible, td:visible").attr("colspan", this._colspan());
    },
    /**
     * Get the number of columns that a grouping row should span
     * @private
     */
    _colspan: function() {
      return this.s.dt.columns().visible().reduce(function(a, b) {
        return a + b;
      }, 0);
    },
    /**
     * Update function that is called whenever we need to draw the grouping rows.
     * This is basically a bootstrap for the self iterative _group and _groupDisplay
     * methods
     * @private
     */
    _draw: function() {
      var dt = this.s.dt;
      var groupedRows = this._group(0, dt.rows({ page: "current" }).indexes());
      this._groupDisplay(0, groupedRows);
    },
    /**
     * Get the grouping information from a data set (index) of rows
     * @param {number} level Nesting level
     * @param {DataTables.Api} rows API of the rows to consider for this group
     * @returns {object[]} Nested grouping information - it is structured like this:
     *	{
     *		dataPoint: 'Edinburgh',
     *		rows: [ 1,2,3,4,5,6,7 ],
     *		children: [ {
     *			dataPoint: 'developer'
     *			rows: [ 1, 2, 3 ]
     *		},
     *		{
     *			dataPoint: 'support',
     *			rows: [ 4, 5, 6, 7 ]
     *		} ]
     *	}
     * @private
     */
    _group: function(level, rows) {
      var fns = Array.isArray(this.c.dataSrc) ? this.c.dataSrc : [this.c.dataSrc];
      var fn = dataTables_default7.util.get(fns[level]);
      var dt = this.s.dt;
      var group, last;
      var i, ien;
      var data = [];
      var that = this;
      for (i = 0, ien = rows.length; i < ien; i++) {
        var rowIndex = rows[i];
        var rowData = dt.row(rowIndex).data();
        group = fn(rowData, level);
        if (group === null || group === void 0) {
          group = that.c.emptyDataGroup;
        }
        if (last === void 0 || group !== last) {
          data.push({
            dataPoint: group,
            rows: []
          });
          last = group;
        }
        data[data.length - 1].rows.push(rowIndex);
      }
      if (fns[level + 1] !== void 0) {
        for (i = 0, ien = data.length; i < ien; i++) {
          data[i].children = this._group(level + 1, data[i].rows);
        }
      }
      return data;
    },
    /**
     * Row group display - insert the rows into the document
     * @param {number} level Nesting level
     * @param {object[]} groups Takes the nested array from `_group`
     * @private
     */
    _groupDisplay: function(level, groups) {
      var dt = this.s.dt;
      var display;
      for (var i = 0, ien = groups.length; i < ien; i++) {
        var group = groups[i];
        var groupName = group.dataPoint;
        var row;
        var rows = group.rows;
        if (this.c.startRender) {
          display = this.c.startRender.call(this, dt.rows(rows), groupName, level);
          row = this._rowWrap(display, this.c.startClassName, level);
          if (row) {
            row.insertBefore(dt.row(rows[0]).node());
          }
        }
        if (this.c.endRender) {
          display = this.c.endRender.call(this, dt.rows(rows), groupName, level);
          row = this._rowWrap(display, this.c.endClassName, level);
          if (row) {
            row.insertAfter(dt.row(rows[rows.length - 1]).node());
          }
        }
        if (group.children) {
          this._groupDisplay(level + 1, group.children);
        }
      }
    },
    /**
     * Take a rendered value from an end user and make it suitable for display
     * as a row, by wrapping it in a row, or detecting that it is a row.
     * @param {node|jQuery|string} display Display value
     * @param {string} className Class to add to the row
     * @param {array} group
     * @param {number} group level
     * @private
     */
    _rowWrap: function(display, className, level) {
      var row;
      if (display === null || display === "") {
        display = this.c.emptyDataGroup;
      }
      if (display === void 0 || display === null) {
        return null;
      }
      if (typeof display === "object" && display.nodeName && display.nodeName.toLowerCase() === "tr") {
        row = $18(display);
      } else if (display instanceof $18 && display.length && display[0].nodeName.toLowerCase() === "tr") {
        row = display;
      } else {
        row = $18("<tr/>").append(
          $18("<th/>").attr("colspan", this._colspan()).attr("scope", "row").append(display)
        );
      }
      return row.addClass(this.c.className).addClass(className).addClass("dtrg-level-" + level);
    }
  });
  RowGroup.defaults = {
    /**
     * Class to apply to grouping rows - applied to both the start and
     * end grouping rows.
     * @type string
     */
    className: "dtrg-group",
    /**
     * Data property from which to read the grouping information
     * @type string|integer|array
     */
    dataSrc: 0,
    /**
     * Text to show if no data is found for a group
     * @type string
     */
    emptyDataGroup: "No group",
    /**
     * Initial enablement state
     * @boolean
     */
    enable: true,
    /**
     * Class name to give to the end grouping row
     * @type string
     */
    endClassName: "dtrg-end",
    /**
     * End grouping label function
     * @function
     */
    endRender: null,
    /**
     * Class name to give to the start grouping row
     * @type string
     */
    startClassName: "dtrg-start",
    /**
     * Start grouping label function
     * @function
     */
    startRender: function(rows, group) {
      return group;
    }
  };
  RowGroup.version = "1.5.0";
  $18.fn.dataTable.RowGroup = RowGroup;
  $18.fn.DataTable.RowGroup = RowGroup;
  dataTables_default7.Api.register("rowGroup()", function() {
    return this;
  });
  dataTables_default7.Api.register("rowGroup().disable()", function() {
    return this.iterator("table", function(ctx) {
      if (ctx.rowGroup) {
        ctx.rowGroup.enable(false);
      }
    });
  });
  dataTables_default7.Api.register("rowGroup().enable()", function(opts) {
    return this.iterator("table", function(ctx) {
      if (ctx.rowGroup) {
        ctx.rowGroup.enable(opts === void 0 ? true : opts);
      }
    });
  });
  dataTables_default7.Api.register("rowGroup().enabled()", function() {
    var ctx = this.context;
    return ctx.length && ctx[0].rowGroup ? ctx[0].rowGroup.enabled() : false;
  });
  dataTables_default7.Api.register("rowGroup().dataSrc()", function(val) {
    if (val === void 0) {
      return this.context[0].rowGroup.dataSrc();
    }
    return this.iterator("table", function(ctx) {
      if (ctx.rowGroup) {
        ctx.rowGroup.dataSrc(val);
      }
    });
  });
  $18(document).on("preInit.dt.dtrg", function(e, settings, json) {
    if (e.namespace !== "dt") {
      return;
    }
    var init2 = settings.oInit.rowGroup;
    var defaults = dataTables_default7.defaults.rowGroup;
    if (init2 || defaults) {
      var opts = $18.extend({}, defaults, init2);
      if (init2 !== false) {
        new RowGroup(settings, opts);
      }
    }
  });

  // node_modules/datatables.net-select-bs5/js/select.bootstrap5.mjs
  var import_jquery23 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-select/js/dataTables.select.mjs
  var import_jquery22 = __toESM(require_jquery(), 1);
  var $19 = import_jquery22.default;
  dataTables_default.select = {};
  dataTables_default.select.classes = {
    checkbox: "dt-select-checkbox"
  };
  dataTables_default.select.version = "2.1.0";
  dataTables_default.select.init = function(dt) {
    var ctx = dt.settings()[0];
    if (!dataTables_default.versionCheck("2")) {
      throw "Warning: Select requires DataTables 2 or newer";
    }
    if (ctx._select) {
      return;
    }
    var savedSelected = dt.state.loaded();
    var selectAndSave = function(e, settings, data) {
      if (data === null || data.select === void 0) {
        return;
      }
      if (dt.rows({ selected: true }).any()) {
        dt.rows().deselect();
      }
      if (data.select.rows !== void 0) {
        dt.rows(data.select.rows).select();
      }
      if (dt.columns({ selected: true }).any()) {
        dt.columns().deselect();
      }
      if (data.select.columns !== void 0) {
        dt.columns(data.select.columns).select();
      }
      if (dt.cells({ selected: true }).any()) {
        dt.cells().deselect();
      }
      if (data.select.cells !== void 0) {
        for (var i = 0; i < data.select.cells.length; i++) {
          dt.cell(data.select.cells[i].row, data.select.cells[i].column).select();
        }
      }
      dt.state.save();
    };
    dt.on("stateSaveParams", function(e, settings, data) {
      data.select = {};
      data.select.rows = dt.rows({ selected: true }).ids(true).toArray();
      data.select.columns = dt.columns({ selected: true })[0];
      data.select.cells = dt.cells({ selected: true })[0].map(function(coords) {
        return { row: dt.row(coords.row).id(true), column: coords.column };
      });
    }).on("stateLoadParams", selectAndSave).one("init", function() {
      selectAndSave(void 0, void 0, savedSelected);
    });
    var init2 = ctx.oInit.select;
    var defaults = dataTables_default.defaults.select;
    var opts = init2 === void 0 ? defaults : init2;
    var items = "row";
    var style = "api";
    var blurable = false;
    var toggleable = true;
    var selectable = null;
    var info2 = true;
    var selector = "td, th";
    var className = "selected";
    var headerCheckbox = true;
    var setStyle = false;
    ctx._select = {
      infoEls: []
    };
    if (opts === true) {
      style = "os";
      setStyle = true;
    } else if (typeof opts === "string") {
      style = opts;
      setStyle = true;
    } else if ($19.isPlainObject(opts)) {
      if (opts.blurable !== void 0) {
        blurable = opts.blurable;
      }
      if (opts.toggleable !== void 0) {
        toggleable = opts.toggleable;
      }
      if (opts.info !== void 0) {
        info2 = opts.info;
      }
      if (opts.items !== void 0) {
        items = opts.items;
      }
      if (opts.style !== void 0) {
        style = opts.style;
        setStyle = true;
      } else {
        style = "os";
        setStyle = true;
      }
      if (opts.selector !== void 0) {
        selector = opts.selector;
      }
      if (opts.className !== void 0) {
        className = opts.className;
      }
      if (opts.headerCheckbox !== void 0) {
        headerCheckbox = opts.headerCheckbox;
      }
      if (opts.selectable !== void 0) {
        selectable = opts.selectable;
      }
    }
    dt.select.selector(selector);
    dt.select.items(items);
    dt.select.style(style);
    dt.select.blurable(blurable);
    dt.select.toggleable(toggleable);
    dt.select.info(info2);
    dt.select.selectable(selectable);
    ctx._select.className = className;
    if (!setStyle && $19(dt.table().node()).hasClass("selectable")) {
      dt.select.style("os");
    }
    if (headerCheckbox || headerCheckbox === "select-page" || headerCheckbox === "select-all") {
      dt.ready(function() {
        initCheckboxHeader(dt, headerCheckbox);
      });
    }
  };
  function cellRange(dt, idx, last) {
    var indexes;
    var columnIndexes;
    var rowIndexes;
    var selectColumns = function(start, end) {
      if (start > end) {
        var tmp = end;
        end = start;
        start = tmp;
      }
      var record = false;
      return dt.columns(":visible").indexes().filter(function(i) {
        if (i === start) {
          record = true;
        }
        if (i === end) {
          record = false;
          return true;
        }
        return record;
      });
    };
    var selectRows = function(start, end) {
      var indexes2 = dt.rows({ search: "applied" }).indexes();
      if (indexes2.indexOf(start) > indexes2.indexOf(end)) {
        var tmp = end;
        end = start;
        start = tmp;
      }
      var record = false;
      return indexes2.filter(function(i) {
        if (i === start) {
          record = true;
        }
        if (i === end) {
          record = false;
          return true;
        }
        return record;
      });
    };
    if (!dt.cells({ selected: true }).any() && !last) {
      columnIndexes = selectColumns(0, idx.column);
      rowIndexes = selectRows(0, idx.row);
    } else {
      columnIndexes = selectColumns(last.column, idx.column);
      rowIndexes = selectRows(last.row, idx.row);
    }
    indexes = dt.cells(rowIndexes, columnIndexes).flatten();
    if (!dt.cells(idx, { selected: true }).any()) {
      dt.cells(indexes).select();
    } else {
      dt.cells(indexes).deselect();
    }
  }
  function checkboxClass(selector) {
    var name = dataTables_default.select.classes.checkbox;
    return selector ? name.replace(/ /g, ".") : name;
  }
  function disableMouseSelection(dt) {
    var ctx = dt.settings()[0];
    var selector = ctx._select.selector;
    $19(dt.table().container()).off("mousedown.dtSelect", selector).off("mouseup.dtSelect", selector).off("click.dtSelect", selector);
    $19("body").off("click.dtSelect" + _safeId(dt.table().node()));
  }
  function enableMouseSelection(dt) {
    var container = $19(dt.table().container());
    var ctx = dt.settings()[0];
    var selector = ctx._select.selector;
    var matchSelection;
    container.on("mousedown.dtSelect", selector, function(e) {
      if (e.shiftKey || e.metaKey || e.ctrlKey) {
        container.css("-moz-user-select", "none").one("selectstart.dtSelect", selector, function() {
          return false;
        });
      }
      if (window.getSelection) {
        matchSelection = window.getSelection();
      }
    }).on("mouseup.dtSelect", selector, function() {
      container.css("-moz-user-select", "");
    }).on("click.dtSelect", selector, function(e) {
      var items = dt.select.items();
      var idx;
      if (matchSelection) {
        var selection = window.getSelection();
        if (!selection.anchorNode || $19(selection.anchorNode).closest("table")[0] === dt.table().node()) {
          if (selection !== matchSelection) {
            return;
          }
        }
      }
      var ctx2 = dt.settings()[0];
      var container2 = dt.table().container();
      if ($19(e.target).closest("div.dt-container")[0] != container2) {
        return;
      }
      var cell = dt.cell($19(e.target).closest("td, th"));
      if (!cell.any()) {
        return;
      }
      var event = $19.Event("user-select.dt");
      eventTrigger(dt, event, [items, cell, e]);
      if (event.isDefaultPrevented()) {
        return;
      }
      var cellIndex = cell.index();
      if (items === "row") {
        idx = cellIndex.row;
        typeSelect(e, dt, ctx2, "row", idx);
      } else if (items === "column") {
        idx = cell.index().column;
        typeSelect(e, dt, ctx2, "column", idx);
      } else if (items === "cell") {
        idx = cell.index();
        typeSelect(e, dt, ctx2, "cell", idx);
      }
      ctx2._select_lastCell = cellIndex;
    });
    $19("body").on("click.dtSelect" + _safeId(dt.table().node()), function(e) {
      if (ctx._select.blurable) {
        if ($19(e.target).parents().filter(dt.table().container()).length) {
          return;
        }
        if ($19(e.target).parents("html").length === 0) {
          return;
        }
        if ($19(e.target).parents("div.DTE").length) {
          return;
        }
        var event = $19.Event("select-blur.dt");
        eventTrigger(dt, event, [e.target, e]);
        if (event.isDefaultPrevented()) {
          return;
        }
        clear(ctx, true);
      }
    });
  }
  function eventTrigger(api, type, args, any) {
    if (any && !api.flatten().length) {
      return;
    }
    if (typeof type === "string") {
      type = type + ".dt";
    }
    args.unshift(api);
    $19(api.table().node()).trigger(type, args);
  }
  function isCheckboxColumn(col) {
    return col.mRender && col.mRender._name === "selectCheckbox";
  }
  function info(api, node) {
    if (api.select.style() === "api" || api.select.info() === false) {
      return;
    }
    var rowSetLength = api.settings()[0]._select_set.length;
    var rows = rowSetLength ? rowSetLength : api.rows({ selected: true }).count();
    var columns = api.columns({ selected: true }).count();
    var cells = api.cells({ selected: true }).count();
    var add = function(el2, name, num) {
      el2.append(
        $19('<span class="select-item"/>').append(
          api.i18n(
            "select." + name + "s",
            { _: "%d " + name + "s selected", 0: "", 1: "1 " + name + " selected" },
            num
          )
        )
      );
    };
    var el = $19(node);
    var output = $19('<span class="select-info"/>');
    add(output, "row", rows);
    add(output, "column", columns);
    add(output, "cell", cells);
    var existing = el.children("span.select-info");
    if (existing.length) {
      existing.remove();
    }
    if (output.text() !== "") {
      el.append(output);
    }
  }
  function initCheckboxHeader(dt, headerCheckbox) {
    var dtSettings = dt.settings()[0];
    var dtInternalColumns = dtSettings.aoColumns;
    dt.columns().iterator("column", function(s, idx) {
      var col = dtInternalColumns[idx];
      if (!isCheckboxColumn(col)) {
        return;
      }
      var header = dt.column(idx).header();
      if (!$19("input", header).length) {
        var input = $19("<input>").attr({
          class: checkboxClass(true),
          type: "checkbox",
          "aria-label": dt.i18n("select.aria.headerCheckbox") || "Select all rows"
        }).appendTo(header).on("change", function() {
          if (this.checked) {
            if (headerCheckbox == "select-page") {
              dt.rows({ page: "current" }).select();
            } else {
              dt.rows({ search: "applied" }).select();
            }
          } else {
            if (headerCheckbox == "select-page") {
              dt.rows({ page: "current", selected: true }).deselect();
            } else {
              dt.rows({ selected: true }).deselect();
            }
          }
        }).on("click", function(e) {
          e.stopPropagation();
        });
        dt.on("draw select deselect", function(e, pass, type) {
          if (type === "row" || !type) {
            var nums = headerCheckboxState(dt, headerCheckbox);
            if (nums.search && nums.search <= nums.count && nums.search === nums.available) {
              input.prop("checked", true).prop("indeterminate", false);
            } else if (nums.search === 0 && nums.count === 0) {
              input.prop("checked", false).prop("indeterminate", false);
            } else {
              input.prop("checked", false).prop("indeterminate", true);
            }
          }
        });
      }
    });
  }
  function headerCheckboxState(dt, headerCheckbox) {
    var ctx = dt.settings()[0];
    var selectable = ctx._select.selectable;
    var available = 0;
    var count = headerCheckbox == "select-page" ? dt.rows({ page: "current", selected: true }).count() : dt.rows({ selected: true }).count();
    var search = headerCheckbox == "select-page" ? dt.rows({ page: "current", selected: true }).count() : dt.rows({ search: "applied", selected: true }).count();
    if (!selectable) {
      available = headerCheckbox == "select-page" ? dt.rows({ page: "current" }).count() : dt.rows({ search: "applied" }).count();
    } else {
      var indexes = headerCheckbox == "select-page" ? dt.rows({ page: "current" }).indexes() : dt.rows({ search: "applied" }).indexes();
      for (var i = 0; i < indexes.length; i++) {
        var rowInternal = ctx.aoData[indexes[i]];
        var result = selectable(rowInternal._aData, rowInternal.nTr, indexes[i]);
        if (result) {
          available++;
        }
      }
    }
    return {
      available,
      count,
      search
    };
  }
  function init(ctx) {
    var api = new dataTables_default.Api(ctx);
    ctx._select_init = true;
    ctx._select_set = [];
    ctx.aoRowCreatedCallback.push(
      function(row, data, index) {
        var i, ien;
        var d = ctx.aoData[index];
        var id = api.row(index).id();
        if (d._select_selected || id !== "undefined" && ctx._select_set.includes(id)) {
          d._select_selected = true;
          $19(row).addClass(ctx._select.className).find("input." + checkboxClass(true)).prop("checked", true);
        }
        for (i = 0, ien = ctx.aoColumns.length; i < ien; i++) {
          if (ctx.aoColumns[i]._select_selected || d._selected_cells && d._selected_cells[i]) {
            $19(d.anCells[i]).addClass(ctx._select.className);
          }
        }
      }
    );
    _cumulativeEvents(api);
    api.on("info.dt", function(e, ctx2, node) {
      if (!ctx2._select.infoEls.includes(node)) {
        ctx2._select.infoEls.push(node);
      }
      info(api, node);
    });
    api.on("select.dtSelect.dt deselect.dtSelect.dt", function() {
      ctx._select.infoEls.forEach(function(el) {
        info(api, el);
      });
      api.state.save();
    });
    api.on("destroy.dtSelect", function() {
      $19(api.rows({ selected: true }).nodes()).removeClass(api.settings()[0]._select.className);
      $19("input." + checkboxClass(true), api.table().header()).remove();
      disableMouseSelection(api);
      api.off(".dtSelect");
      $19("body").off(".dtSelect" + _safeId(api.table().node()));
    });
  }
  function rowColumnRange(dt, type, idx, last) {
    var indexes = dt[type + "s"]({ search: "applied" }).indexes();
    var idx1 = indexes.indexOf(last);
    var idx2 = indexes.indexOf(idx);
    if (!dt[type + "s"]({ selected: true }).any() && idx1 === -1) {
      indexes.splice(indexes.indexOf(idx) + 1, indexes.length);
    } else {
      if (idx1 > idx2) {
        var tmp = idx2;
        idx2 = idx1;
        idx1 = tmp;
      }
      indexes.splice(idx2 + 1, indexes.length);
      indexes.splice(0, idx1);
    }
    if (!dt[type](idx, { selected: true }).any()) {
      dt[type + "s"](indexes).select();
    } else {
      indexes.splice(indexes.indexOf(idx), 1);
      dt[type + "s"](indexes).deselect();
    }
  }
  function clear(ctx, force) {
    if (force || ctx._select.style === "single") {
      var api = new dataTables_default.Api(ctx);
      api.rows({ selected: true }).deselect();
      api.columns({ selected: true }).deselect();
      api.cells({ selected: true }).deselect();
    }
  }
  function typeSelect(e, dt, ctx, type, idx) {
    var style = dt.select.style();
    var toggleable = dt.select.toggleable();
    var isSelected = dt[type](idx, { selected: true }).any();
    if (isSelected && !toggleable) {
      return;
    }
    if (style === "os") {
      if (e.ctrlKey || e.metaKey) {
        dt[type](idx).select(!isSelected);
      } else if (e.shiftKey) {
        if (type === "cell") {
          cellRange(dt, idx, ctx._select_lastCell || null);
        } else {
          rowColumnRange(
            dt,
            type,
            idx,
            ctx._select_lastCell ? ctx._select_lastCell[type] : null
          );
        }
      } else {
        var selected = dt[type + "s"]({ selected: true });
        if (isSelected && selected.flatten().length === 1) {
          dt[type](idx).deselect();
        } else {
          selected.deselect();
          dt[type](idx).select();
        }
      }
    } else if (style == "multi+shift") {
      if (e.shiftKey) {
        if (type === "cell") {
          cellRange(dt, idx, ctx._select_lastCell || null);
        } else {
          rowColumnRange(
            dt,
            type,
            idx,
            ctx._select_lastCell ? ctx._select_lastCell[type] : null
          );
        }
      } else {
        dt[type](idx).select(!isSelected);
      }
    } else {
      dt[type](idx).select(!isSelected);
    }
  }
  function _safeId(node) {
    return node.id.replace(/[^a-zA-Z0-9\-\_]/g, "-");
  }
  function _cumulativeEvents(api) {
    api.on("select", function(e, dt, type, indexes) {
      if (type !== "row") {
        return;
      }
      var ctx = api.settings()[0];
      _add(api, ctx._select_set, indexes);
    });
    api.on("deselect", function(e, dt, type, indexes) {
      if (type !== "row") {
        return;
      }
      var ctx = api.settings()[0];
      _remove(api, ctx._select_set, indexes);
    });
  }
  function _add(api, arr, indexes) {
    for (var i = 0; i < indexes.length; i++) {
      var id = api.row(indexes[i]).id();
      if (id && id !== "undefined" && !arr.includes(id)) {
        arr.push(id);
      }
    }
  }
  function _remove(api, arr, indexes) {
    for (var i = 0; i < indexes.length; i++) {
      var id = api.row(indexes[i]).id();
      var idx = arr.indexOf(id);
      if (idx !== -1) {
        arr.splice(idx, 1);
      }
    }
  }
  $19.each(
    [
      { type: "row", prop: "aoData" },
      { type: "column", prop: "aoColumns" }
    ],
    function(i, o) {
      dataTables_default.ext.selector[o.type].push(function(settings, opts, indexes) {
        var selected = opts.selected;
        var data;
        var out = [];
        if (selected !== true && selected !== false) {
          return indexes;
        }
        for (var i2 = 0, ien = indexes.length; i2 < ien; i2++) {
          data = settings[o.prop][indexes[i2]];
          if (data && (selected === true && data._select_selected === true || selected === false && !data._select_selected)) {
            out.push(indexes[i2]);
          }
        }
        return out;
      });
    }
  );
  dataTables_default.ext.selector.cell.push(function(settings, opts, cells) {
    var selected = opts.selected;
    var rowData;
    var out = [];
    if (selected === void 0) {
      return cells;
    }
    for (var i = 0, ien = cells.length; i < ien; i++) {
      rowData = settings.aoData[cells[i].row];
      if (rowData && (selected === true && rowData._selected_cells && rowData._selected_cells[cells[i].column] === true || selected === false && (!rowData._selected_cells || !rowData._selected_cells[cells[i].column]))) {
        out.push(cells[i]);
      }
    }
    return out;
  });
  var apiRegister = dataTables_default.Api.register;
  var apiRegisterPlural = dataTables_default.Api.registerPlural;
  apiRegister("select()", function() {
    return this.iterator("table", function(ctx) {
      dataTables_default.select.init(new dataTables_default.Api(ctx));
    });
  });
  apiRegister("select.blurable()", function(flag) {
    if (flag === void 0) {
      return this.context[0]._select.blurable;
    }
    return this.iterator("table", function(ctx) {
      ctx._select.blurable = flag;
    });
  });
  apiRegister("select.toggleable()", function(flag) {
    if (flag === void 0) {
      return this.context[0]._select.toggleable;
    }
    return this.iterator("table", function(ctx) {
      ctx._select.toggleable = flag;
    });
  });
  apiRegister("select.info()", function(flag) {
    if (flag === void 0) {
      return this.context[0]._select.info;
    }
    return this.iterator("table", function(ctx) {
      ctx._select.info = flag;
    });
  });
  apiRegister("select.items()", function(items) {
    if (items === void 0) {
      return this.context[0]._select.items;
    }
    return this.iterator("table", function(ctx) {
      ctx._select.items = items;
      eventTrigger(new dataTables_default.Api(ctx), "selectItems", [items]);
    });
  });
  apiRegister("select.style()", function(style) {
    if (style === void 0) {
      return this.context[0]._select.style;
    }
    return this.iterator("table", function(ctx) {
      if (!ctx._select) {
        dataTables_default.select.init(new dataTables_default.Api(ctx));
      }
      if (!ctx._select_init) {
        init(ctx);
      }
      ctx._select.style = style;
      var dt = new dataTables_default.Api(ctx);
      if (style !== "api") {
        dt.ready(function() {
          disableMouseSelection(dt);
          enableMouseSelection(dt);
        });
      } else {
        disableMouseSelection(dt);
      }
      eventTrigger(new dataTables_default.Api(ctx), "selectStyle", [style]);
    });
  });
  apiRegister("select.selector()", function(selector) {
    if (selector === void 0) {
      return this.context[0]._select.selector;
    }
    return this.iterator("table", function(ctx) {
      var dt = new dataTables_default.Api(ctx);
      var style = ctx._select.style;
      disableMouseSelection(dt);
      ctx._select.selector = selector;
      if (style && style !== "api") {
        dt.ready(function() {
          disableMouseSelection(dt);
          enableMouseSelection(dt);
        });
      } else {
        disableMouseSelection(dt);
      }
    });
  });
  apiRegister("select.selectable()", function(set) {
    let ctx = this.context[0];
    if (set) {
      ctx._select.selectable = set;
      return this;
    }
    return ctx._select.selectable;
  });
  apiRegister("select.last()", function(set) {
    let ctx = this.context[0];
    if (set) {
      ctx._select_lastCell = set;
      return this;
    }
    return ctx._select_lastCell;
  });
  apiRegister("select.cumulative()", function() {
    let ctx = this.context[0];
    return ctx && ctx._select_set ? ctx._select_set : [];
  });
  apiRegisterPlural("rows().select()", "row().select()", function(select) {
    var api = this;
    var selectedIndexes = [];
    if (select === false) {
      return this.deselect();
    }
    this.iterator("row", function(ctx, idx) {
      clear(ctx);
      var dtData = ctx.aoData[idx];
      var dtColumns = ctx.aoColumns;
      if (ctx._select.selectable) {
        var result = ctx._select.selectable(dtData._aData, dtData.nTr, idx);
        if (result === false) {
          return;
        }
      }
      $19(dtData.nTr).addClass(ctx._select.className);
      dtData._select_selected = true;
      selectedIndexes.push(idx);
      for (var i = 0; i < dtColumns.length; i++) {
        var col = dtColumns[i];
        if (col.sType === null) {
          api.columns().types();
        }
        if (isCheckboxColumn(col)) {
          var cells = dtData.anCells;
          if (cells && cells[i]) {
            $19("input." + checkboxClass(true), cells[i]).prop("checked", true);
          }
          if (dtData._aSortData !== null) {
            dtData._aSortData[i] = null;
          }
        }
      }
    });
    this.iterator("table", function(ct) {
      eventTrigger(api, "select", ["row", selectedIndexes], true);
    });
    return this;
  });
  apiRegister("row().selected()", function() {
    var ctx = this.context[0];
    if (ctx && this.length && ctx.aoData[this[0]] && ctx.aoData[this[0]]._select_selected) {
      return true;
    }
    return false;
  });
  apiRegisterPlural("columns().select()", "column().select()", function(select) {
    var api = this;
    if (select === false) {
      return this.deselect();
    }
    this.iterator("column", function(ctx, idx) {
      clear(ctx);
      ctx.aoColumns[idx]._select_selected = true;
      var column = new dataTables_default.Api(ctx).column(idx);
      $19(column.header()).addClass(ctx._select.className);
      $19(column.footer()).addClass(ctx._select.className);
      column.nodes().to$().addClass(ctx._select.className);
    });
    this.iterator("table", function(ctx, i) {
      eventTrigger(api, "select", ["column", api[i]], true);
    });
    return this;
  });
  apiRegister("column().selected()", function() {
    var ctx = this.context[0];
    if (ctx && this.length && ctx.aoColumns[this[0]] && ctx.aoColumns[this[0]]._select_selected) {
      return true;
    }
    return false;
  });
  apiRegisterPlural("cells().select()", "cell().select()", function(select) {
    var api = this;
    if (select === false) {
      return this.deselect();
    }
    this.iterator("cell", function(ctx, rowIdx, colIdx) {
      clear(ctx);
      var data = ctx.aoData[rowIdx];
      if (data._selected_cells === void 0) {
        data._selected_cells = [];
      }
      data._selected_cells[colIdx] = true;
      if (data.anCells) {
        $19(data.anCells[colIdx]).addClass(ctx._select.className);
      }
    });
    this.iterator("table", function(ctx, i) {
      eventTrigger(api, "select", ["cell", api.cells(api[i]).indexes().toArray()], true);
    });
    return this;
  });
  apiRegister("cell().selected()", function() {
    var ctx = this.context[0];
    if (ctx && this.length) {
      var row = ctx.aoData[this[0][0].row];
      if (row && row._selected_cells && row._selected_cells[this[0][0].column]) {
        return true;
      }
    }
    return false;
  });
  apiRegisterPlural("rows().deselect()", "row().deselect()", function() {
    var api = this;
    this.iterator("row", function(ctx, idx) {
      var dtData = ctx.aoData[idx];
      var dtColumns = ctx.aoColumns;
      $19(dtData.nTr).removeClass(ctx._select.className);
      dtData._select_selected = false;
      ctx._select_lastCell = null;
      for (var i = 0; i < dtColumns.length; i++) {
        var col = dtColumns[i];
        if (col.sType === null) {
          api.columns().types();
        }
        if (isCheckboxColumn(col)) {
          var cells = dtData.anCells;
          if (cells && cells[i]) {
            $19("input." + checkboxClass(true), dtData.anCells[i]).prop("checked", false);
          }
          if (dtData._aSortData !== null) {
            dtData._aSortData[i] = null;
          }
        }
      }
    });
    this.iterator("table", function(ctx, i) {
      eventTrigger(api, "deselect", ["row", api[i]], true);
    });
    return this;
  });
  apiRegisterPlural("columns().deselect()", "column().deselect()", function() {
    var api = this;
    this.iterator("column", function(ctx, idx) {
      ctx.aoColumns[idx]._select_selected = false;
      var api2 = new dataTables_default.Api(ctx);
      var column = api2.column(idx);
      $19(column.header()).removeClass(ctx._select.className);
      $19(column.footer()).removeClass(ctx._select.className);
      api2.cells(null, idx).indexes().each(function(cellIdx) {
        var data = ctx.aoData[cellIdx.row];
        var cellSelected = data._selected_cells;
        if (data.anCells && (!cellSelected || !cellSelected[cellIdx.column])) {
          $19(data.anCells[cellIdx.column]).removeClass(ctx._select.className);
        }
      });
    });
    this.iterator("table", function(ctx, i) {
      eventTrigger(api, "deselect", ["column", api[i]], true);
    });
    return this;
  });
  apiRegisterPlural("cells().deselect()", "cell().deselect()", function() {
    var api = this;
    this.iterator("cell", function(ctx, rowIdx, colIdx) {
      var data = ctx.aoData[rowIdx];
      if (data._selected_cells !== void 0) {
        data._selected_cells[colIdx] = false;
      }
      if (data.anCells && !ctx.aoColumns[colIdx]._select_selected) {
        $19(data.anCells[colIdx]).removeClass(ctx._select.className);
      }
    });
    this.iterator("table", function(ctx, i) {
      eventTrigger(api, "deselect", ["cell", api[i]], true);
    });
    return this;
  });
  function i18n(label, def) {
    return function(dt) {
      return dt.i18n("buttons." + label, def);
    };
  }
  function namespacedEvents(config) {
    var unique = config._eventNamespace;
    return "draw.dt.DT" + unique + " select.dt.DT" + unique + " deselect.dt.DT" + unique;
  }
  function enabled(dt, config) {
    if (config.limitTo.indexOf("rows") !== -1 && dt.rows({ selected: true }).any()) {
      return true;
    }
    if (config.limitTo.indexOf("columns") !== -1 && dt.columns({ selected: true }).any()) {
      return true;
    }
    if (config.limitTo.indexOf("cells") !== -1 && dt.cells({ selected: true }).any()) {
      return true;
    }
    return false;
  }
  var _buttonNamespace = 0;
  $19.extend(dataTables_default.ext.buttons, {
    selected: {
      text: i18n("selected", "Selected"),
      className: "buttons-selected",
      limitTo: ["rows", "columns", "cells"],
      init: function(dt, node, config) {
        var that = this;
        config._eventNamespace = ".select" + _buttonNamespace++;
        dt.on(namespacedEvents(config), function() {
          that.enable(enabled(dt, config));
        });
        this.disable();
      },
      destroy: function(dt, node, config) {
        dt.off(config._eventNamespace);
      }
    },
    selectedSingle: {
      text: i18n("selectedSingle", "Selected single"),
      className: "buttons-selected-single",
      init: function(dt, node, config) {
        var that = this;
        config._eventNamespace = ".select" + _buttonNamespace++;
        dt.on(namespacedEvents(config), function() {
          var count = dt.rows({ selected: true }).flatten().length + dt.columns({ selected: true }).flatten().length + dt.cells({ selected: true }).flatten().length;
          that.enable(count === 1);
        });
        this.disable();
      },
      destroy: function(dt, node, config) {
        dt.off(config._eventNamespace);
      }
    },
    selectAll: {
      text: i18n("selectAll", "Select all"),
      className: "buttons-select-all",
      action: function(e, dt, node, config) {
        var items = this.select.items();
        var mod = config.selectorModifier;
        if (mod) {
          if (typeof mod === "function") {
            mod = mod.call(dt, e, dt, node, config);
          }
          this[items + "s"](mod).select();
        } else {
          this[items + "s"]().select();
        }
      }
      // selectorModifier can be specified
    },
    selectNone: {
      text: i18n("selectNone", "Deselect all"),
      className: "buttons-select-none",
      action: function() {
        clear(this.settings()[0], true);
      },
      init: function(dt, node, config) {
        var that = this;
        config._eventNamespace = ".select" + _buttonNamespace++;
        dt.on(namespacedEvents(config), function() {
          var count = dt.rows({ selected: true }).flatten().length + dt.columns({ selected: true }).flatten().length + dt.cells({ selected: true }).flatten().length;
          that.enable(count > 0);
        });
        this.disable();
      },
      destroy: function(dt, node, config) {
        dt.off(config._eventNamespace);
      }
    },
    showSelected: {
      text: i18n("showSelected", "Show only selected"),
      className: "buttons-show-selected",
      action: function(e, dt) {
        if (dt.search.fixed("dt-select")) {
          dt.search.fixed("dt-select", null);
          this.active(false);
        } else {
          var dataSrc = dt.settings()[0].aoData;
          dt.search.fixed("dt-select", function(text, data, idx) {
            return dataSrc[idx]._select_selected;
          });
          this.active(true);
        }
        dt.draw();
      }
    }
  });
  $19.each(["Row", "Column", "Cell"], function(i, item) {
    var lc = item.toLowerCase();
    dataTables_default.ext.buttons["select" + item + "s"] = {
      text: i18n("select" + item + "s", "Select " + lc + "s"),
      className: "buttons-select-" + lc + "s",
      action: function() {
        this.select.items(lc);
      },
      init: function(dt) {
        var that = this;
        this.active(dt.select.items() === lc);
        dt.on("selectItems.dt.DT", function(e, ctx, items) {
          that.active(items === lc);
        });
      }
    };
  });
  dataTables_default.type("select-checkbox", {
    className: "dt-select",
    detect: dataTables_default.versionCheck("2.1") ? {
      oneOf: function() {
        return false;
      },
      allOf: function() {
        return false;
      },
      init: function(settings, col, idx) {
        return isCheckboxColumn(col);
      }
    } : function(data) {
      return data === "select-checkbox" ? data : false;
    },
    order: {
      pre: function(d) {
        return d === "X" ? -1 : 0;
      }
    }
  });
  $19.extend(true, dataTables_default.defaults.oLanguage, {
    select: {
      aria: {
        rowCheckbox: "Select row"
      }
    }
  });
  dataTables_default.render.select = function(valueProp, nameProp) {
    var valueFn = valueProp ? dataTables_default.util.get(valueProp) : null;
    var nameFn = nameProp ? dataTables_default.util.get(nameProp) : null;
    var fn = function(data, type, row, meta) {
      var dtRow = meta.settings.aoData[meta.row];
      var selected = dtRow._select_selected;
      var ariaLabel = meta.settings.oLanguage.select.aria.rowCheckbox;
      var selectable = meta.settings._select.selectable;
      if (type === "display") {
        if (selectable) {
          var result = selectable(row, dtRow.nTr, meta.row);
          if (result === false) {
            return "";
          }
        }
        return $19("<input>").attr({
          "aria-label": ariaLabel,
          class: checkboxClass(),
          name: nameFn ? nameFn(row) : null,
          type: "checkbox",
          value: valueFn ? valueFn(row) : null,
          checked: selected
        }).on("input", function(e) {
          e.preventDefault();
          this.checked = $19(this).closest("tr").hasClass("selected");
        })[0];
      } else if (type === "type") {
        return "select-checkbox";
      } else if (type === "filter") {
        return "";
      }
      return selected ? "X" : "";
    };
    fn._name = "selectCheckbox";
    return fn;
  };
  dataTables_default.ext.order["select-checkbox"] = function(settings, col) {
    return this.api().column(col, { order: "index" }).nodes().map(function(td) {
      if (settings._select.items === "row") {
        return $19(td).parent().hasClass(settings._select.className).toString();
      } else if (settings._select.items === "cell") {
        return $19(td).hasClass(settings._select.className).toString();
      }
      return false;
    });
  };
  $19.fn.DataTable.select = dataTables_default.select;
  $19(document).on("i18n.dt.dtSelect preInit.dt.dtSelect", function(e, ctx) {
    if (e.namespace !== "dt") {
      return;
    }
    dataTables_default.select.init(new dataTables_default.Api(ctx));
  });

  // node_modules/datatables.net-select-bs5/js/select.bootstrap5.mjs
  dataTables_bootstrap5_default.select.classes.checkbox = "form-check-input";

  // src/utils/isString.js
  var isString_default = (v) => {
    return typeof v == "string";
  };

  // src/utils/getGlobalFn.js
  var getGlobalFn_default = (fn) => fn.split(".").reduce((r, p) => r[p], window);

  // src/utils/replaceCallbacks.js
  var replaceCallbacks = (obj) => {
    if (isString_default(obj)) {
      obj = obj[0] == "{" ? JSON.parse(obj) : getGlobalFn_default(obj);
    }
    for (const [k, v] of Object.entries(obj)) {
      if (v && typeof v == "object") {
        const fn = v["__fn"];
        if (isString_default(fn)) {
          obj[k] = getGlobalFn_default(fn);
        } else {
          replaceCallbacks(v);
        }
      }
    }
    return obj;
  };
  var replaceCallbacks_default = replaceCallbacks;

  // src/utils/simpleConfig.js
  var simpleConfig_default = (str) => {
    if (!str) {
      return {};
    }
    if (str[0] != "{" && str.includes(":")) {
      str = `{${str.replace(/([\w]*)\s*:\s*([\w"'\[\]]*)/g, (m2, p1, p2) => `"${p1}":${p2.replace(/'/g, '"')}`)}}`;
    }
    return str[0] == "{" ? JSON.parse(str) : getGlobalFn_default(str);
  };

  // src/utils/whenParsed.js
  var whenParsed = (el) => {
    let ref = el;
    do {
      if (ref.nextSibling) {
        el.parsedCallback();
        return;
      }
      ref = ref.parentNode;
    } while (ref);
    setTimeout(() => {
      el.parsedCallback();
    });
  };
  var whenParsed_default = whenParsed;

  // src/utils/FormidableElement.js
  var ID_KEY = "__fe_id";
  window[ID_KEY] = window[ID_KEY] || 0;
  var m = /* @__PURE__ */ new Map();
  var FormidableElement = class extends HTMLElement {
    constructor() {
      super();
      this.id = this.id || `fe-${window[ID_KEY]++}`;
      const o = m.get(this.id);
      if (o) {
        if (o != this.innerHTML) {
          this.innerHTML = o;
        }
      } else {
        m.set(this.id, this.innerHTML);
      }
    }
    /**
     * This can get called multiple times
     */
    connectedCallback() {
      if (this._t) {
        clearTimeout(this._t);
      }
      whenParsed_default(this);
    }
    disconnectedCallback() {
      this.disconnected();
      this._t = setTimeout(() => {
        this.destroyed();
        this.config = null;
        if (!document.getElementById(this.id)) {
          m.delete(this.id);
        }
      }, 1e3);
    }
    parsedCallback() {
      if (!this.config) {
        this.config = replaceCallbacks_default(simpleConfig_default(this.dataset.config));
        this.created();
      }
      this.connected();
    }
    /**
     * Called only once in component lifecycle
     * Config is parsed again just before created is called
     */
    created() {
    }
    /**
     * Called if the element is not reconnected quickly after being disconnected
     * Will set config to null
     */
    destroyed() {
    }
    /**
     * Called each time the component is connected (inserted)
     */
    connected() {
    }
    /**
     * Called each time the component is disconnected (removed or destroyed)
     */
    disconnected() {
    }
  };
  var FormidableElement_default = FormidableElement;

  // src/utils/EventfulElement.js
  var observer = new window.IntersectionObserver((entries, obs) => {
    entries.filter((entry) => entry.isIntersecting).forEach((entry) => {
      const target = entry.target;
      obs.unobserve(target);
      target.doCreate();
    });
  });
  var EventfulElement = class extends FormidableElement_default {
    get events() {
      return [];
    }
    parsedCallback() {
      this.lazy = this.hasAttribute("lazy");
      if (!this.config) {
        if (this.lazy) {
          observer.observe(this);
        } else {
          this.doCreate();
        }
      }
      if (this.config) {
        this.connected();
      }
    }
    doCreate() {
      this.config = replaceCallbacks_default(simpleConfig_default(this.dataset.config));
      this.created();
    }
    connectedCallback() {
      super.connectedCallback();
      this.events.forEach((t) => this.addEventListener(t, this));
    }
    trackFocus(ev) {
      if (ev.type == "focusin") {
        this.classList.add("has-focus");
      } else if (ev.type == "focusout") {
        this.classList.remove("has-focus");
      }
    }
    // Use arrow function to make sure that the scope is always this and cannot be rebound
    // Automatically call any $event method (don't use "on" as prefix as it will collide with existing handler)
    handleEvent = (ev) => {
      this.trackFocus(ev);
      this[`$${ev.type}`](ev);
    };
    disconnectedCallback() {
      if (this.lazy && this.config) {
        observer.unobserve(this);
      }
      this.events.forEach((t) => this.removeEventListener(t, this));
      super.disconnectedCallback();
    }
  };
  var EventfulElement_default = EventfulElement;

  // src/utils/icons.js
  var iconFirst = '<svg width="24" height="24" viewBox="0 0 24 24"><path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z" fill="currentColor"/></svg>';
  var iconLast = '<svg width="24" height="24" viewBox="0 0 24 24"><path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z" fill="currentColor"/></svg>';
  var iconNext = '<svg width="24" height="24" viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" fill="currentColor"/></svg>';
  var iconPrev = '<svg width="24" height="24" viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" fill="currentColor"/></svg>';

  // src/utils/getDelete.js
  var getDelete_default = (obj, k, defaults = null) => {
    const v = obj[k] ?? defaults;
    delete obj[k];
    return v;
  };

  // src/utils/fetchWrapper.js
  var map = /* @__PURE__ */ new Map();
  var fetchWrapper_default = (url, params = {}, options = {}) => {
    if (url instanceof URL) {
      url = url.toString();
    }
    const base = {
      method: "GET"
    };
    if (!options.signal) {
      let ctrl = map.get(url);
      if (ctrl) {
        ctrl.abort();
      }
      ctrl = new AbortController();
      map.set(url, ctrl);
      base["signal"] = ctrl.signal;
    }
    let fetchOptions = Object.assign(base, options);
    const headers = fetchOptions.headers || {};
    if (!url.includes("https://cdn.jsdelivr.net")) {
      headers["X-Requested-With"] = "XMLHttpRequest";
    }
    fetchOptions.headers = headers;
    const searchParams = new URLSearchParams(params);
    if (fetchOptions.method === "POST" && !fetchOptions.body) {
      fetchOptions.body = searchParams;
      fetchOptions.headers["Content-Type"] = "application/x-www-form-urlencoded";
    } else {
      url += "?" + searchParams.toString();
    }
    return fetch(url, fetchOptions);
  };

  // src/utils/fetchJson.js
  var fetchJson_default = (url, params = {}, options = {}) => {
    const headers = options.headers || {};
    headers["Accept"] = "application/json";
    if (options.body && typeof options.body != "string" && options.method == "POST") {
      headers["Content-Type"] = "application/json";
      options.body = JSON.stringify(options.body);
    }
    options.headers = headers;
    return fetchWrapper_default(url, params, options).then((response) => {
      return response.text().then((text) => {
        let data;
        let showError = !response.ok;
        try {
          data = text && JSON.parse(text);
        } catch (e) {
          showError = true;
          data = {
            message: "Invalid JSON response"
          };
        }
        if (showError) {
          const error = data && data.message || response.statusText;
          return Promise.reject(error);
        }
        return data;
      });
    });
  };

  // src/classes/DataTableElement.js
  var DataTableElement = class extends EventfulElement_default {
    /**
     * @returns {HTMLDivElement}
     */
    get el() {
      return this.firstElementChild;
    }
    created() {
      if (!this.el) {
        this.innerHTML = "<table></table>";
      }
      this.buildDatatable();
    }
    async buildDatatable() {
      const el = this.el;
      const config = this.config;
      if (!config.language) {
        const fullLocales = {
          fr: "fr-FR",
          nl: "nl-NL",
          es: "es-ES"
        };
        const lang = navigator.language.split("-")[0];
        const locale = fullLocales[lang] || lang;
        const abortController = new AbortController();
        const langData = await fetchJson_default(
          "https://cdn.jsdelivr.net/npm/datatables.net-plugins@2/i18n/" + locale + ".json",
          {},
          {
            signal: abortController.signal
          }
        );
        if (langData) {
          langData["paginate"] = {
            first: iconFirst.replace(/\"24\"/g, "18"),
            last: iconLast.replace(/\"24\"/g, "18"),
            next: iconNext.replace(/\"24\"/g, "18"),
            previous: iconPrev.replace(/\"24\"/g, "18")
          };
          config.language = langData;
        }
      }
      if (config.data && typeof config.data == "function") {
        config.data = config.data.call();
      }
      if (config.responsive) {
        this.el.classList.add(...["responsive", "nowrap"]);
        this.el.setAttribute("width", "100%");
      }
      const groupCol = this.el.querySelector("thead th[data-group]");
      if (groupCol) {
        const groupColIdx = [...groupCol.parentNode.children].indexOf(groupCol);
        config["rowGroup"] = config["rowGroup"] || {};
        config["rowGroup"]["dataSrc"] = groupColIdx;
        config["orderFixed"] = [[groupColIdx, "asc"]];
      }
      const selectCol = this.el.querySelector("thead th[data-select]");
      if (selectCol) {
        config["columnDefs"] = config["columnDefs"] || [];
        config["columnDefs"] = [
          {
            orderable: false,
            render: dataTables_bootstrap5_default.render.select(),
            targets: 0,
            width: "40px"
          }
        ].concat(config["columnDefs"]);
        config["select"] = {
          style: "os",
          selector: "td:first-child"
        };
        config["order"] = [[1, "asc"]];
      }
      const initCallback = getDelete_default(config, "_initCallback");
      const configCallback = getDelete_default(config, "_configCallback");
      if (configCallback) {
        configCallback(config);
      }
      const datatable = new dataTables_bootstrap5_default(el, config);
      this.datatable = datatable;
      if (initCallback) {
        initCallback(datatable, this);
      }
    }
    getSelectedIds() {
      let arr = [];
      this.datatable.rows({ selected: true }).every(function(rowIdx, tableLoop, rowLoop) {
        let id = this.id();
        if (id === void 0 || id === "undefined") {
          id = this.node().getAttribute("data-id");
        }
        arr.push(id);
      });
      return arr;
    }
    destroyed() {
      if (this.datatable) {
        this.datatable.destroy();
        this.datatable = null;
      }
    }
  };
  var DataTableElement_default = DataTableElement;

  // src/utils/defineEl.js
  var registry = customElements;
  var defineEl_default = (name, cls) => {
    if (!registry.get(name)) {
      registry.define(name, cls);
    }
  };

  // src/data-table.raw.js
  defineEl_default("data-table", DataTableElement_default);
  var data_table_raw_default = DataTableElement_default;
})();
/*! Bundled license information:

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

datatables.net/js/dataTables.mjs:
  (*! DataTables 2.1.7
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-bs5/js/dataTables.bootstrap5.mjs:
  (*! DataTables Bootstrap 5 integration
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net/js/dataTables.mjs:
  (*! DataTables 2.0.5
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-bs5/js/dataTables.bootstrap5.mjs:
  (*! DataTables Bootstrap 5 integration
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net/js/dataTables.mjs:
  (*! DataTables 2.0.5
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-fixedcolumns/js/dataTables.fixedColumns.mjs:
  (*! FixedColumns 5.0.0
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-fixedcolumns-bs5/js/fixedColumns.bootstrap5.mjs:
  (*! Bootstrap 5 integration for DataTables' FixedColumns
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net/js/dataTables.mjs:
  (*! DataTables 2.0.5
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-bs5/js/dataTables.bootstrap5.mjs:
  (*! DataTables Bootstrap 5 integration
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net/js/dataTables.mjs:
  (*! DataTables 2.0.5
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-fixedheader/js/dataTables.fixedHeader.mjs:
  (*! FixedHeader 4.0.1
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-fixedheader-bs5/js/fixedHeader.bootstrap5.mjs:
  (*! Bootstrap 5 styling wrapper for FixedHeader
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-buttons/js/dataTables.buttons.mjs:
  (*! Buttons for DataTables 3.1.2
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-buttons-bs5/js/buttons.bootstrap5.mjs:
  (*! Bootstrap integration for DataTables' Buttons
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-responsive/js/dataTables.responsive.mjs:
  (*! Responsive 3.0.3
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-responsive-bs5/js/responsive.bootstrap5.mjs:
  (*! Bootstrap 5 integration for DataTables' Responsive
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net/js/dataTables.mjs:
  (*! DataTables 2.0.5
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-bs5/js/dataTables.bootstrap5.mjs:
  (*! DataTables Bootstrap 5 integration
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net/js/dataTables.mjs:
  (*! DataTables 2.0.5
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-rowgroup/js/dataTables.rowGroup.mjs:
  (*! RowGroup 1.5.0
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-rowgroup-bs5/js/rowGroup.bootstrap5.mjs:
  (*! Bootstrap 5 styling wrapper for RowGroup
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-select/js/dataTables.select.mjs:
  (*! Select for DataTables 2.1.0
   *  SpryMedia Ltd - datatables.net/license/mit
   *)

datatables.net-select-bs5/js/select.bootstrap5.mjs:
  (*! Bootstrap 5 styling wrapper for Select
   *  SpryMedia Ltd - datatables.net/license
   *)
*/
